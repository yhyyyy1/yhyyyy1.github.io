<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法题方法介绍02：进制转换</title>
      <link href="/2024/08/14/%E7%AE%97%E6%B3%95%E9%A2%98%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D02/"/>
      <url>/2024/08/14/%E7%AE%97%E6%B3%95%E9%A2%98%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D02/</url>
      
        <content type="html"><![CDATA[<blockquote><p>进制转换的核心：</p><p><strong>其他进制</strong> ——&gt; <strong>十进制</strong> ——&gt; <strong>其他进制</strong></p></blockquote><h3 id="其他进制转成十进制——valueOf-方法-or-parseInt-方法"><a href="#其他进制转成十进制——valueOf-方法-or-parseInt-方法" class="headerlink" title="其他进制转成十进制——valueOf( )方法 or parseInt( )方法"></a>其他进制转成十进制——valueOf( )方法 or parseInt( )方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line"><span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(String s)</span></span><br><span class="line"><span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(String s, <span class="type">int</span> radix)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外的方法：</span></span><br><span class="line"><span class="keyword">static</span> Integer <span class="title function_">parseInt</span><span class="params">(String s, <span class="type">int</span> radix)</span></span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li><code>i</code>——Integer 对象的整数</li><li><code>s</code>——Integer 对象的字符串</li><li><code>radix</code>——在解析字符串 s 时使用的进制数，用于指定使用的进制数</li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul><li>**Integer.valueOf(int i)**：返回一个表示指定的 int 值的 Integer 实例。</li><li>**Integer.valueOf(String s)**：返回保存指定的 String 的值的 Integer 对象。</li><li>**Integer.valueOf(String s, int radix)**：返回一个 Integer 对象，该对象中保存了用第二个参数提供的基数进行解析时从指定的 String 中提取的值。</li></ul><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Integer.valueOf(<span class="string">&quot;25&quot;</span>,<span class="number">16</span>)); <span class="comment">// 16进制的25转成10进制的值</span></span><br><span class="line">    System.out.println(Integer.valueOf(<span class="string">&quot;25&quot;</span>,<span class="number">8</span>)); <span class="comment">// 8进制的25转成10进制的值</span></span><br><span class="line">    System.out.println(Integer.valueOf(<span class="string">&quot;25&quot;</span>,<span class="number">10</span>)); <span class="comment">// 10进制的25转成10进制的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">37</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><p>或者使用<code>Integer.parseInt()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Integer.parseInt(<span class="string">&quot;25&quot;</span>,<span class="number">16</span>));</span><br><span class="line">    System.out.println(Integer.parseInt(<span class="string">&quot;25&quot;</span>,<span class="number">8</span>));</span><br><span class="line">    System.out.println(Integer.parseInt(<span class="string">&quot;25&quot;</span>,<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十进制转成其他进制——toString-方法"><a href="#十进制转成其他进制——toString-方法" class="headerlink" title="十进制转成其他进制——toString( )方法"></a>十进制转成其他进制——toString( )方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> radix)</span></span><br></pre></td></tr></table></figure><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul><li><code>i</code>—— 要转换的整数</li><li><code>radix</code>——用于指定要转换的目标进制</li></ul><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><ul><li><strong>toString():</strong> 返回表示 Integer 值的 String 对象。</li><li><strong>toString(int i, int radix):</strong> 返回表示指定 int 转为指定 radix 进制 的 String 对象。</li></ul><h4 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Integer.toString(<span class="number">25</span>,<span class="number">2</span>)); <span class="comment">// 将10进制的25转成2进制的值</span></span><br><span class="line">    System.out.println(Integer.toString(<span class="number">25</span>,<span class="number">8</span>)); <span class="comment">// 将10进制的25转成8进制的值</span></span><br><span class="line">    System.out.println(Integer.toString(<span class="number">25</span>,<span class="number">16</span>)); <span class="comment">// 将10进制的25转成16进制的值</span></span><br><span class="line">    System.out.println(Integer.toString(<span class="number">25</span>,<span class="number">12</span>)); <span class="comment">// 将10进制的25转成12进制的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用其他方式：（Binary——2进制、Octal——8进制、Hex——16进制）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Integer.toBinaryString(<span class="number">25</span>)); <span class="comment">// 将10进制的25转成2进制的值</span></span><br><span class="line">    System.out.println(Integer.toOctalString(<span class="number">25</span>)); <span class="comment">// 将10进制的25转成8进制的值</span></span><br><span class="line">    System.out.println(Integer.toHexString(<span class="number">25</span>)); <span class="comment">// 将10进制的25转成16进制的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任意进制转换"><a href="#任意进制转换" class="headerlink" title="任意进制转换"></a>任意进制转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将任意进制的字符串转成目标进制的字符串</span></span><br><span class="line"><span class="comment">// i -&gt; e</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toRadixEvery</span><span class="params">(String s,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    Integer tem=Integer.valueOf(s,i); <span class="comment">// 将i进制的字符串转成10进制的整数</span></span><br><span class="line">    <span class="keyword">return</span> Integer.toString(tem,e); <span class="comment">// 将10进制的tem转成e进制</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// return Integer.toString(Integer.valueOf(s,i),e); 整合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024-8-7-刷题日记</title>
      <link href="/2024/08/07/2024-8-7-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/08/07/2024-8-7-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>来源于leetcode一道题——<a href="https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked">最小覆盖字串</a></p><p><strong>题目描述：</strong></p><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。<strong>返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串</strong>。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。（注意是涵盖，所以不要求顺序）（对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量）</p><p><strong>示例</strong><br>        输入：s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC”<br>        输出：”BANC”</p><p>​输入：s &#x3D; “a”, t &#x3D; “aa”<br>​输出：””</p></blockquote><span id="more"></span><h3 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h3><p>有想到<strong>滑动窗口</strong>，但是题目没有要求t的绝对有序（涵盖），就没想到怎么记录出现的位置与次数</p><p>以及左指针向右移动后，如何判断是否依旧满足“涵盖”</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h3><p><strong>滑动窗口</strong></p><p>我们<strong>枚举 s 子串的右端点 right（子串最后一个字母的下标），如果子串涵盖 t，就不断移动左端点 left 直到不涵盖为止。在移动过程中更新最短子串的左右端点</strong>。</p><h4 id="具体流程："><a href="#具体流程：" class="headerlink" title="具体流程："></a>具体流程：</h4><ol><li><p>初始化 ansLeft&#x3D;−1, ansRight&#x3D;m，用来记录最短子串的左右端点，其中 m 是 s 的长度。</p></li><li><p>用一个哈希表（或者数组）cntT 统计 t 中每个字母的出现次数。</p></li><li><p>初始化 left&#x3D;0，以及一个空哈希表（或者数组）cntS，用来统计 s 子串中每个字母的出现次数。</p></li><li><p>遍历 s，设当前枚举的子串右端点为 right，把 s[right] 的出现次数加一。</p></li><li><p>遍历 cntS 中的每个字母及其出现次数，如果出现次数都大于等于 cntT 中的字母出现次数（出现了“涵盖”）：</p><ol><li><p>如果 right−left&lt;ansRight−ansLeft，说明我们找到了更短的子串，更新 ansLeft&#x3D;left, ansRight&#x3D;right。</p></li><li><p>把 s[left] 的出现次数减一。</p></li><li><p>左端点右移，即 left 加一。</p></li><li><p>重复上述三步，直到 cntS 有字母的出现次数小于 cntT 中该字母的出现次数为止（不再“涵盖”）。</p></li></ol></li><li><p>最后，如果 ansLeft&lt;0，说明没有找到符合要求的子串，返回空字符串，否则返回下标 ansLeft 到下标 ansRight 之间的子串。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String S, String t)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ansLeft</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ansRight</span> <span class="operator">=</span> m;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] cntS = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>]; <span class="comment">// s 子串字母的出现次数</span></span><br><span class="line">        <span class="type">int</span>[] cntT = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>]; <span class="comment">// t 中字母的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">            cntT[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; m; right++) &#123; <span class="comment">// 移动子串右端点</span></span><br><span class="line">            cntS[s[right]]++; <span class="comment">// 右端点字母移入子串</span></span><br><span class="line">            <span class="keyword">while</span> (isCovered(cntS, cntT)) &#123; <span class="comment">// 涵盖</span></span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; ansRight - ansLeft) &#123; <span class="comment">// 找到更短的子串</span></span><br><span class="line">                    ansLeft = left; <span class="comment">// 记录此时的左右端点</span></span><br><span class="line">                    ansRight = right;</span><br><span class="line">                &#125;</span><br><span class="line">                cntS[s[left++]]--; <span class="comment">// 左端点字母移出子串</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansLeft &lt; <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : S.substring(ansLeft, ansRight + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isCovered</span><span class="params">(<span class="type">int</span>[] cntS, <span class="type">int</span>[] cntT)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; i &lt;= <span class="string">&#x27;Z&#x27;</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cntS[i] &lt; cntT[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cntS[i] &lt; cntT[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是右指针一直向右移动，在每次移动时记录是否“涵盖”；</p><p>如果出现“涵盖”则尝试更新最短字串，并开始移动左指针（每次也要判断是否“涵盖”）直到不“涵盖”</p><p>再开始移动右指针，循环往复~</p><blockquote><p>这种方法需要每次移动指针都判断是否 “涵盖”，有点麻烦了</p></blockquote><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h3><ul><li>ansL &amp; ansR记录最终符合条件且最短字符串的始末位置</li><li>l &amp; r作滑动窗口上下界</li><li><strong>cnt数组存储t中每个字符出现次数</strong></li><li><strong>当cntT表示t中还要多少字符没被“涵盖”，为0时表示t中所有字符已被当前窗口包含</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) cnt[t.charAt(i)]++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, ansL = <span class="number">0</span>, ansR = <span class="number">0</span>, ans = Integer.MAX_VALUE, cntT = t.length();</span><br><span class="line">        <span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[s.charAt(r++)]-- &gt; <span class="number">0</span>) cntT--; <span class="comment">// 包含了右指针右移 和 cnt数组更新的操作</span></span><br><span class="line">            <span class="keyword">while</span> (cntT == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l &lt; ans) &#123;</span><br><span class="line">                    ans = r - l;</span><br><span class="line">                    ansL = l;</span><br><span class="line">                    ansR = r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt[s.charAt(l++)]++ == <span class="number">0</span>) cntT++; <span class="comment">// 包含了左指针右移 和 cnt数组更新的操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(ansL, ansR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和解法 1 的思路一样，但是通过 cnt数组 和 cntT化解了需要一直判断涵盖的问题</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题总结 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 字串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024-8-3-柠檬微趣笔试</title>
      <link href="/2024/08/04/2024-8-3-%E6%9F%A0%E6%AA%AC%E5%BE%AE%E8%B6%A3%E7%AC%94%E8%AF%95/"/>
      <url>/2024/08/04/2024-8-3-%E6%9F%A0%E6%AA%AC%E5%BE%AE%E8%B6%A3%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2024-8-3 柠檬微趣笔试，4道题A了1道，针对其余的题目，进行记录</p></blockquote><h3 id="T2-Regular-Expresssion"><a href="#T2-Regular-Expresssion" class="headerlink" title="T2 Regular Expresssion"></a>T2 Regular Expresssion</h3><p>可以参考 <a href="https://leetcode.cn/problems/regular-expression-matching/description/">leetcode T 10</a></p><p>实现简单的正则表达式匹配，本题中模式字符串所包含的字符的范围为字母、“.”、“*”、“?”、其中：</p><ul><li>“.” 匹配任何单个字符；</li><li>“*” 与模式字符串前一个字符组成一组，匹配零个或多个前面的字符；</li><li>“?” 与模式字符串前一个字符组成一组，匹配一个或多个前面的字符；</li></ul><p>匹配应该覆盖到整个输入的字符串（而不是局部的），测试用例中不会出现超出匹配字符范围之外的字符，也不会出现非法的模式字符串。<strong>使用语言提供的正则表达式库将算作无效答案。</strong></p><span id="more"></span><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>输入的第一行为需要检测匹配的用例数，接下来的每一行包括两个字符串，前一个字符串为待匹配的字符串，后一个字符串为模式字符串，</p><p>待匹配字符串的长度不超过10。</p><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><p>对于每一个测试用例，如果匹配则输出一行true，如果不匹配则输出一行false。</p><h4 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h4><table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>3<br />aa     a<br />aa     aa<br />aaa     aa</td><td><br />false<br />true<br />false</td></tr><tr><td>5<br />a     a.<br />a     a.*<br />ab     .*<br />ab     .?<br />b     a?</td><td><br />false<br />true<br />true<br />true<br />false</td></tr></tbody></table><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>首先<strong>理解各个符号的意思</strong>：</p><ul><li>“.”自己作为一组，匹配任意字符</li><li>“*”和前面的字符成为一组，表示 0—任意多的前面的字符，所以a 和 c*是可以匹配成功的</li><li>“?” 和前面的字符成为一组，表示 1—任意多的前面的字符</li><li>PS：“.”和“*”or“?” 配合可以形成多个.</li></ul><p>总体思路是<strong>从 s[:1] 和 p[:1] 开始判断是否能匹配</strong>，<strong>每轮添加一个字符并判断是否能匹配</strong>，直至添加完整个字符串 s 和 p 。</p><p>展开来看，假设 s[:i] 与 p[:j] 可以匹配，那么下一状态有两种：</p><ol><li>添加一个字符 s i+1后是否能匹配？</li><li>添加字符 p j+1 后是否能匹配？</li></ol><p>显而易见——<strong>动态规划</strong></p><ul><li><p><strong>状态定义</strong>：</p><p>本题状态有m * n 种，所以定义dp[m][n]，<strong>dp[i][j]表示s的前 i 个字符和 p的前 j 个字符能否匹配</strong></p></li><li><p><strong>转移方程</strong>：</p><p>由于<code>dp[0][0]</code>表示空字符串匹配，所以<code>dp[i][j]</code>对应的是<code>s[i-1]</code>和<code>p[j-1]</code></p><ul><li>当<code>p[j-1] == &#39;*&#39;</code>时，<code>dp[i][j]</code> 在当以下任一情况为 true 时等于 true ：<ul><li><code>dp[i][j-2]</code>：也就是不用<code>p[j-2]</code>，能否匹配</li><li><code>dp[i-1][j]</code> 且 <code>s[i-1] == p[j-2]</code>：即让字符 <code>p[j - 2]</code> 多出现 1 次时，能否匹配</li><li><code>dp[i - 1][j]</code> 且 <code>p[j - 2] = &#39;.&#39;</code>：即让字符 <code>&#39;.&#39;</code> 多出现 1 次时，能否匹配</li></ul></li><li>当 <code>p[j - 1] != &#39;*&#39;</code> 时， <code>dp[i][j]</code> 在当以下任一情况为 true 时等于 true ：<ul><li><code>dp[i - 1][j - 1] </code>且 <code>s[i - 1] = p[j - 1]</code> 或者  <code>p[j - 1] = &#39;?&#39;</code>： 即让字符 <code>p[j - 1] </code>多出现一次时，能否匹配</li><li><code>dp[i - 1][j - 1] </code>且 <code>p[j - 1] = &#39;.&#39;</code>： 即将字符 . 看作字符<code> s[i - 1]</code> 时，能否匹配</li></ul></li></ul></li><li><p><strong>初始化</strong>： 需要先初始化 <code>dp</code> 矩阵首行，以避免状态转移时索引越界</p><ul><li><code>dp[0][0] = true</code></li><li><code>dp[0][j] = dp[0][j - 2]</code> 且 <code>p[j - 1] = &#39;\*&#39;</code>：首行 s 为空字符串，因此当 p 的偶数位为 * 时才能够匹配（即让 p 的奇数位出现 0 次，保持 p 是空字符串）。因此，循环遍历字符串 p ，步长为 2（即只看偶数位）</li></ul></li></ul><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        in.nextLine();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            String[] input = in.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (isMatch(input[<span class="number">0</span>], input[<span class="number">1</span>])) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = p.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= n; j += <span class="number">2</span>)</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>] &amp;&amp; p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充 dp 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="comment">//                System.out.println(&quot;i: &quot; + i + &quot; j: &quot; + j);</span></span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j - <span class="number">2</span>]) dp[i][j] = <span class="literal">true</span>;                                            <span class="comment">// 1.</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &amp;&amp; s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">2</span>)) dp[i][j] = <span class="literal">true</span>; <span class="comment">// 2.</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &amp;&amp; p.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>) dp[i][j] = <span class="literal">true</span>;             <span class="comment">// 3.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;?&#x27;</span> || s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                System.out.println(dp[i][j]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题总结 </tag>
            
            <tag> 笔试总结 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式01：单例、代理、适配器、责任链、简单工厂</title>
      <link href="/2024/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F01/"/>
      <url>/2024/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F01/</url>
      
        <content type="html"><![CDATA[<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote><p><strong>单例模式</strong>是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p></blockquote><h4 id="特点与实现逻辑"><a href="#特点与实现逻辑" class="headerlink" title="特点与实现逻辑"></a>特点与实现逻辑</h4><p><strong>特点</strong>：</p><ul><li><p><strong>保证一个类只有一个实例</strong></p><p> 目的：控制某些共享资源 （例如数据库或文件） 的访问权限。</p><p> 行为逻辑：如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。</p></li><li><p><strong>为该实例提供了一个全局访问节点</strong></p></li></ul><p>单例的实现通常包括下面的步骤：</p><ul><li><strong>将默认的构造函数设为私有private</strong>，防止其他对象使用单例类的 new 运算符，除了当前类的getInstance方法</li><li><strong>新建一个静态 static 构建方法（getInstance）作为构造函数</strong>，该函数会保证只有一个对象（如果没有实例化对象则新建，如果有则返回这个对象）</li><li>在类中添加一个私有静态成员变量用于保存单例实例</li><li>将对单例的构造函数的调用替换为对其静态构建方法的调用。</li></ul><h4 id="结构与伪代码"><a href="#结构与伪代码" class="headerlink" title="结构与伪代码"></a>结构与伪代码</h4><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-8-5-Singleton01.png" alt="2024-8-5-Singleton01"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生成了一个实例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题方法介绍01：快速幂代替pow函数</title>
      <link href="/2024/08/01/%E7%AE%97%E6%B3%95%E9%A2%98%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D01/"/>
      <url>/2024/08/01/%E7%AE%97%E6%B3%95%E9%A2%98%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2024.3.16美团笔试T3</p></blockquote><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小美拿到了一个数组，她每次操作会将除了第x个元素的其余元素翻倍，一共操作了q次。请你帮小美计算操作结束后所有元素之和。</p><p>由于答案过大，请对$10^9+7$取模。</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>第一行输入两个正整数n , q，代表数组的大小和操作次数。<br>第二行输入n个正整数$$a_i$$，代表数组的元素。<br>接下来的q行，每行输入一个正整数$$x_i$$，代表第 i 次操作未被翻倍的元素。<br>$1&lt;&#x3D;n，q&lt;&#x3D;10^5$<br>$1&lt;&#x3D;x_i&lt;&#x3D;n$<br>$1&lt;&#x3D;a_i&lt;&#x3D;10^9$</p><span id="more"></span><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><p>一个整数，代表操作结束后所有元素之和模$10^9+7$的值。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li><p>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 2 3 4</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure></li><li><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">34</span><br></pre></td></tr></table></figure></li><li><p>说明</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一次操作后，数组变成[1,4,6,8]</span><br><span class="line">第二次操作后，数组变成[2,4,12,16]</span><br><span class="line">所有元素之和为 34。</span><br></pre></td></tr></table></figure></li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>使用数组记录翻倍次数。但是注意这里不能直接使用pow函数，<strong>因为这里的翻倍次数非常大，所以要使用快速幂来优化。</strong></p><p>二进制取幂的想法是，我们将取幂的任务按照指数的 <strong>二进制表示</strong> 来分割成更小的任务。</p><p>本人实测，使用pow函数求$10^9+7$直接超时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意类名必须为 Main, 不要有任何 package xxx 信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt(); </span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> scanner.nextInt(); </span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n]; </span><br><span class="line">        <span class="type">int</span>[] times = <span class="keyword">new</span> <span class="title class_">int</span>[n]; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] = scanner.nextInt();</span><br><span class="line">            times[i] = q; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            times[x - <span class="number">1</span>]--; </span><br><span class="line">        &#125; <span class="comment">//累计一下每个位置需要翻倍的次数n也就是 x^n</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">val</span> <span class="operator">=</span> (<span class="type">long</span>) nums[i] * powMod(<span class="number">2</span>, times[i], MOD) % MOD; </span><br><span class="line">            sum = (sum + val) % MOD; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">powMod</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> n, <span class="type">int</span> MOD)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        x = x % MOD;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 奇数，就单独拿出来</span></span><br><span class="line">                result = (result * x) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            x = (x * x) % MOD;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂思想"><a href="#快速幂思想" class="headerlink" title="快速幂思想"></a>快速幂思想</h3><p><strong>快速幂</strong>，就是处理指数爆炸时的问题，特别是经常有题目挖坑，$a^b % c$ 但是$a^b$一定是会超限的，所以可以转化成$(a^2)^{b&#x2F;2}$的形式，而且取模运算不会影响余下的数的运算，所以有$(a^2 % c)^{b&#x2F;2}$</p><ol><li><p>如果b是奇数，那就取出来一个a * 到结果上，每次*运算都要取模，之后再更新a</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 奇数，就单独拿出来</span></span><br><span class="line">    result = (result * a) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果b是偶数，更新a &#x3D; a*a（因为之后如果是奇数，要做乘法更新底数的值；总有奇数的时候）</p></li></ol><h4 id="整体代码："><a href="#整体代码：" class="headerlink" title="整体代码："></a>整体代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">powMod</span><span class="params">(<span class="type">long</span> a, <span class="type">int</span> b, <span class="type">int</span> MOD)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    a = a % MOD;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 奇数，就单独拿出来</span></span><br><span class="line">            result = (result * a) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        a = (a * a) % MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>; <span class="comment">//相当于b = b/2，移位运算就是向0取整，非常合适</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring核心知识08：常见面试题</title>
      <link href="/2024/07/31/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8608/"/>
      <url>/2024/07/31/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8608/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring-中的设计模式有哪些"><a href="#Spring-中的设计模式有哪些" class="headerlink" title="Spring 中的设计模式有哪些"></a>Spring 中的设计模式有哪些</h3><p>借鉴：<a href="https://javaguide.cn/system-design/framework/spring/spring-design-patterns-summary.html">https://javaguide.cn/system-design/framework/spring/spring-design-patterns-summary.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring核心知识07：常用注解</title>
      <link href="/2024/07/31/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8607/"/>
      <url>/2024/07/31/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8607/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring常见的注解"><a href="#Spring常见的注解" class="headerlink" title="Spring常见的注解"></a>Spring常见的注解</h3><p>重点——<strong>Bean的实例化，依赖注入</strong>相关</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td><code>@Component</code>、<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code></td><td>使用在类上，用于实例化Bean<br />（<code>@Component</code>是后面三个的汇总，没法用其余的情况，就用这个）</td></tr><tr><td><code>@Autowired</code></td><td>使用在字段上用于根据类型的依赖注入</td></tr><tr><td><code>@Qualifier</code></td><td>结合<code>@Autowired</code>一起使用，用于根据名称进行依赖注入</td></tr><tr><td><code>@Scope</code></td><td>注释Bean的作用范围，默认是单例</td></tr><tr><td><code>@Configuration</code></td><td>指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解</td></tr><tr><td><code>@ComponentScan</code></td><td>用于指定Spring在初始化容器时要扫描的包</td></tr><tr><td><code>@Bean</code></td><td>使用在方法上，标注将该方法的返回值存储到Spring容器中</td></tr><tr><td><code>@Import</code></td><td>使用 <code>@Import</code> 导入的类会被Spring加载到IoC容器中</td></tr><tr><td><code>@Aspect</code>、<code>@Before</code>、<code>@After</code>、<code>@Around</code>、<code>@Pointcut</code></td><td>用于切面编程</td></tr></tbody></table><span id="more"></span><h3 id="SpringMVC常见注解"><a href="#SpringMVC常见注解" class="headerlink" title="SpringMVC常见注解"></a>SpringMVC常见注解</h3><p>重点——<strong>请求和响应</strong>相关</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td><code>@RequestMapping</code></td><td>用于映射请求路径，可以定义在类上和方法上。用于类上，则表示类中的所有方法都是以该地址作为父路径</td></tr><tr><td><code>@RequestBody</code></td><td>注解实现接收http请求的json数据，<strong>将json转换为java对象</strong></td></tr><tr><td><code>@RequestParam</code></td><td>指定请求参数的名称</td></tr><tr><td><code>@PathViriable</code></td><td>从请求路径中获取请求参数{&#x2F;user&#x2F;{id}}，作为传递给该方法的形式参数，Restful风格</td></tr><tr><td><code>@ResponseBody</code></td><td>注解实现将controller方法的返回值对象转化为json响应给客户端</td></tr><tr><td><code>@RequestHeader</code></td><td>获取指定的请求头部数据</td></tr><tr><td><code>@RestController</code></td><td><code>@Controller</code> +<code> @ResponseBody</code></td></tr></tbody></table><h3 id="SpringBoot常见注解"><a href="#SpringBoot常见注解" class="headerlink" title="SpringBoot常见注解"></a>SpringBoot常见注解</h3><p>重点——<strong>自动配置</strong>相关</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td><code>@SpringBootConfiguration</code></td><td>组合了-<code>@Configuration</code>注解，实现了配置文件的功能</td></tr><tr><td><code>@EnableAutoConfiguration</code></td><td>打开了自动配置的功能，也可以关闭某个自动配置</td></tr><tr><td><code>@ComponentScan</code></td><td>Spring组件扫描</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring核心知识06：事务传播机制</title>
      <link href="/2024/07/31/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8606/"/>
      <url>/2024/07/31/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8606/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在某些业务场景下，如果<strong>一个请求中，需要同时写入多张表的数据</strong>。为了保证操作的原子性（要么同时成功，要么同时失败），避免数据不一致的情况，我们一般都会用到 spring 事务。</p></blockquote><p>事务嘛，还是ACID，和MySQL中的一样，都是通过保证AID来保证C</p><p>说到底，Spring事务还是对MySQL事务的支持，如果MySQL使用的引擎是innodb（支持事务）则OK，如果使用的是myisam（不支持事务）则不行——MySQL是根</p><h2 id="Spring支持两种方式的事务管理"><a href="#Spring支持两种方式的事务管理" class="headerlink" title="Spring支持两种方式的事务管理"></a>Spring支持两种方式的事务管理</h2><h3 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h3><p>通过  <code>TransactionTemplate</code> 或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用</p><p>使用 <code>TransactionTemplate</code> 进行编程式事务管理的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 业务代码</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>TransactionManager</code> 进行编程式事务管理的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> transactionManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//业务代码</span></span><br><span class="line">        transactionManager.commit(status);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        transactionManager.rollback(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明式事务管理（推荐使用）"><a href="#声明式事务管理（推荐使用）" class="headerlink" title="声明式事务管理（推荐使用）"></a>声明式事务管理（推荐使用）</h3><p>实际是通过AOP实现的（将公共的  <code>TransactionTemplate</code> 或者 <code>TransactionManager</code> 的编程式事务管理实现，抽象为一个切面，做环绕通知就OK了），代码侵入性最小，<strong>基于 <code>@Transactional</code> 的全注解方式使用最多</strong></p><p>使用 <code>@Transactional</code>注解进行事务管理的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">  <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">  b.bMethod();</span><br><span class="line">  c.cMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="Spring-事务管理接口介绍"><a href="#Spring-事务管理接口介绍" class="headerlink" title="Spring 事务管理接口介绍"></a>Spring 事务管理接口介绍</h2><p>Spring 框架种，事务管理相关的最重要的3个接口：</p><ul><li>**<code>PlatformTransationManager</code>**：事务管理器，Spring事务策略的核心</li><li>**<code>TransactionDefinition</code>**：事务定义信息（事务隔离界别、传播行为、超时、只读、回滚规则）</li><li>**<code>TransactionStatus</code>**：事务运行状态</li></ul><p><strong><code>PlatformTransationManager</code> 接口看作是事务上层的管理者</strong>，**<code>TransactionDefinition</code> 和 <code>TransactionStatus</code> 两个接口看作是事务的描述**</p><p><code>PlatformTransationManager</code> 根据 <code>TransactionDefinition</code> 的定义事务的超时时间、隔离级别等属性，进行事务管理；<code>TransactionStatus</code> 接口则是提供了一些方法来获取事务的状态（新事务、回滚等）</p><h3 id="PlatformTransationManager-事务管理接口"><a href="#PlatformTransationManager-事务管理接口" class="headerlink" title="PlatformTransationManager 事务管理接口"></a><code>PlatformTransationManager</code> 事务管理接口</h3><p><strong>Spring 并不直接管理事务，而是提供了多种事务管理器</strong> 。Spring 事务管理器的接口是：**<code>PlatformTransactionManager</code>** </p><p>不同的平台（数据交互），如JDBC、Hibernate、JPA 等有各自的事务管理器基于这个接口</p><p>其中主要有三个方法：</p><ul><li>getTransaction：获取事务（根据事务属性）</li><li>commit：提交事务（根据事务状态）</li><li>rollback：回滚事务（根据事务状态）</li></ul><h3 id="TransactionDefinition-事务属性"><a href="#TransactionDefinition-事务属性" class="headerlink" title="TransactionDefinition 事务属性"></a><code>TransactionDefinition</code> 事务属性</h3><p>事务属性，理解为<strong>事务的一些基本配置，描述了事务策略如何应用到方法上</strong></p><p>事务属性包含了5个方面：（后面会详细说明）</p><ul><li>隔离级别</li><li>传播行为</li><li>回滚规则</li><li>是否只读</li><li>事务超时</li></ul><h3 id="TransactionDefinition-事务状态"><a href="#TransactionDefinition-事务状态" class="headerlink" title="TransactionDefinition 事务状态"></a><code>TransactionDefinition</code> 事务状态</h3><p><strong>用来记录事务的状态</strong>——该接口<strong>定义了一组方法，用来获取或判断事务的相应状态信息</strong></p><p><code>PlatformTransactionManager.getTransaction(…)</code>方法返回的就是一个 <code>TransactionStatus</code> 对象。</p><p>内容包括：</p><ul><li>isNewTransactionL：是否是新事物</li><li>hasSavepoint：是否有恢复点</li><li>setRollbackOnly：设置为只回滚</li><li>isRollbackOnly：是否为只回滚</li><li>isCompleted：是否已完成</li></ul><h2 id="Spring-事务属性详解"><a href="#Spring-事务属性详解" class="headerlink" title="Spring 事务属性详解"></a>Spring 事务属性详解</h2><p>主要解读 <code>@Transactional</code> 注解中的参数</p><h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>：当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p><p>举例：我们在 A 类的<code>aMethod()</code>方法中调用了 B 类的 <code>bMethod()</code> 方法。这个时候就涉及到业务层方法之间互相调用的事务问题。<strong>如果我们的 <code>bMethod()</code>如果发生异常需要回滚，如何配置事务传播行为才能让 <code>aMethod()</code>也跟着回滚呢？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod(); <span class="comment">// 在A类中的方法调用B类中的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TransactionDefinition</code>中定义了如下的表示传播行为的常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionDefinition</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_REQUIRED</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_SUPPORTS</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_MANDATORY</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_REQUIRES_NEW</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NOT_SUPPORTED</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NEVER</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NESTED</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时为了方便，有了如下的枚举类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Propagation</span> &#123;</span><br><span class="line"></span><br><span class="line">    REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line"></span><br><span class="line">    SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line"></span><br><span class="line">    MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line"></span><br><span class="line">    REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line"></span><br><span class="line">    NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line"></span><br><span class="line">    NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line"></span><br><span class="line">    NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    Propagation(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="正确的事务传播行为"><a href="#正确的事务传播行为" class="headerlink" title="正确的事务传播行为"></a>正确的事务传播行为</h4><ol><li><p><code>TransactionDefinition.PROPAGATION_REQUIRED</code>：<strong>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务</strong>（**<code>@Transactional</code>注解默认的事务传播行为**）</p><ul><li><p>如果外部方法没有开启事务，则所修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰</p></li><li><p>如果外部方法开启事务，且事务传播行为也是 <code>PROPAGATION_REQUIRED</code> 的话，则所有 <code>PROPAGATION_REQUIRED</code> 修饰的内部方法（相对外部方法来说）和外部方法均属于同一事务，只要一个方法回滚，整个事务均回滚</p></li></ul><p>总结：<strong>外部无则新建，外部有则加入</strong>，如果有回滚则整个事务都回滚</p></li><li><p><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code>：<strong>创建一个新的事务，如果当前存在事务，则把当前事务挂起</strong>。也就是说不管外部方法是否开启事务，被修饰的内部方法都会开启事务</p><p><strong>例如上述的例子：</strong></p><p>如果我们上面的 <code>bMethod()</code>使用 <code>PROPAGATION_REQUIRES_NEW</code> 事务传播行为修饰，<code>aMethod</code> 还是用 <code>PROPAGATION_REQUIRED</code> 修饰的话。如果 <code>aMethod()</code> 发生异常回滚，**<code>bMethod()</code> 不会跟着回滚，因为 <code>bMethod()</code> 开启了独立的事务。**</p><p>但是如果 <code>bMethod()</code> 抛出了未被捕获的异常并且这个异常满足事务回滚规则的话，<code>aMethod()</code> 同样也会回滚，因为这个异常被 <code>aMethod()</code> 的事务管理机制检测到了。</p></li><li><p><code>TransactionDefinition.PROPAGATION_NESTED</code>：<strong>如果当前存在事务，就在嵌套事务内执行；如果当前没有事务，就执行与 <code>PROPAGATION_REQUIRED</code> 类似的操作</strong></p><ul><li>在外部方法开启事务的情况下，在内部开启一个新的事务，作为嵌套事务存在</li><li>如果外部方法无事务，则单独开启一个事务，与 <code>PROPAGATION_REQUIRED</code> 类似。</li></ul><p><strong>例如上述的例子：</strong></p><p>如果 <code>bMethod()</code> 回滚的话，<code>aMethod()</code>不会回滚。如果 <code>aMethod()</code> 回滚的话，<code>bMethod()</code>会回滚。</p></li><li><p><code>TransactionDefinition.PROPAGATION_MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p></li></ol><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>MySQL那部分介绍的多一点</p><p><code>TransactionDefinition</code> 接口中定义了五个表示隔离级别的常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionDefinition</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_DEFAULT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_READ_UNCOMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_READ_COMMITTED</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_REPEATABLE_READ</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_SERIALIZABLE</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时为了方便，有了如下的枚举类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Isolation</span> &#123;</span><br><span class="line"></span><br><span class="line">  DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line"></span><br><span class="line">  READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line"></span><br><span class="line">  READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line"></span><br><span class="line">  REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line"></span><br><span class="line">  SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">  Isolation(<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :<strong>使用后端数据库默认的隔离级别</strong>，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别，Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li><li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> ：<strong>读未提交</strong>，最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li><li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : <strong>读已提交</strong>，允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li><li><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : <strong>可重复读</strong>，对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li><li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : <strong>串行化</strong>，最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ol><h3 id="事务超时属性"><a href="#事务超时属性" class="headerlink" title="事务超时属性"></a>事务超时属性</h3><p>事务超时，就是指<strong>一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务</strong>。</p><p>在 <code>TransactionDefinition</code> 中以 int 的值来表示超时时间，其单位是秒，默认值为-1，这表示事务的超时时间取决于底层事务系统或者没有超时时间。</p><h3 id="事务只读属性"><a href="#事务只读属性" class="headerlink" title="事务只读属性"></a>事务只读属性</h3><p>在 <code>TransactionDefinition</code> 中声明了一个方法——isReadOnly()，<strong>对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务</strong>；只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中。</p><h4 id="只读为什么要开启事务？"><a href="#只读为什么要开启事务？" class="headerlink" title="只读为什么要开启事务？"></a>只读为什么要开启事务？</h4><ul><li>如果你一次执行<strong>单条查询语句</strong>，则<strong>没有必要启用事务支持</strong>，数据库默认支持 SQL 执行期间的读一致性；</li><li>如果你一次执行<strong>多条查询语句</strong>，例如统计查询，报表查询，在这种场景下，<strong>多条查询 SQL 必须保证整体的读一致性</strong>，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，<strong>应该启用事务支持</strong></li></ul><h3 id="事务回滚规则"><a href="#事务回滚规则" class="headerlink" title="事务回滚规则"></a>事务回滚规则</h3><p>这些规则<strong>定义了哪些异常会导致事务回滚而哪些不会</strong>。<strong>默认情况下，事务只有遇到运行期异常（<code>RuntimeException</code> 的子类）时才会回滚，<code>Error</code> 也会导致事务回滚</strong>，但是，在遇到检查型（Checked）异常时不会回滚。</p><p>回滚自定义的特定异常类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(roolbackFor = MyException.calss)</span></span><br></pre></td></tr></table></figure><h2 id="Transactional-注解使用详解"><a href="#Transactional-注解使用详解" class="headerlink" title="@Transactional 注解使用详解"></a>@Transactional 注解使用详解</h2><h3 id="Transactional-的作用范围"><a href="#Transactional-的作用范围" class="headerlink" title="@Transactional 的作用范围"></a><code>@Transactional</code> 的作用范围</h3><ul><li><strong>方法</strong>：推荐将注解使用于方法上，不过需要注意的是：<strong>该注解只能应用到 public 方法上，否则不生效。</strong></li><li><strong>类</strong>：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</li><li><strong>接口</strong>：不推荐在接口上使用。</li></ul><h3 id="Transactional-的常用配置参数"><a href="#Transactional-的常用配置参数" class="headerlink" title="@Transactional 的常用配置参数"></a><code>@Transactional</code> 的常用配置参数</h3><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>propagation</td><td>事务的传播行为，默认为Required</td></tr><tr><td>isolation</td><td>事务的隔离级别，默认为Default</td></tr><tr><td>timeout</td><td>事务的超时时间，默认值为-1(不会超时)，如果超过该时间限制且事务还未完成，则自动回滚</td></tr><tr><td>readOnly</td><td>指定事务是否为只读事务，默认值为false</td></tr><tr><td>rollbackFor</td><td>指定能够触发事务回滚的异常类型，可指定多个</td></tr></tbody></table><h3 id="Transactional-事务注解原理："><a href="#Transactional-事务注解原理：" class="headerlink" title="@Transactional 事务注解原理："></a><code>@Transactional</code> 事务注解原理：</h3><p><code>@Transactional</code> 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理</p><p>如果一个类或者一个类中的 public 方法上被标注<code>@Transactional</code> 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被<code>@Transactional</code> 注解的 public 方法的时候，实际调用的是，<code>TransactionInterceptor</code> 类中的 <code>invoke()</code>方法（<code>TransactionInterceptor</code> 类中的 <code>invoke()</code>方法内部实际调用的是 <code>TransactionAspectSupport</code> 类的 <code>invokeWithinTransaction()</code>方法。）。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring核心知识05：AOP</title>
      <link href="/2024/07/31/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8605/"/>
      <url>/2024/07/31/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8605/</url>
      
        <content type="html"><![CDATA[<blockquote><p>AOP（Aspect Oriented Peogram）——面向切面编程：<strong>在运行时，动态地将代码切入到类的指定方法、指定位置</strong>上的编程思想</p></blockquote><h3 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h3><p>一般而言，我们管<strong>切入到指定类指定方法的代码片段</strong>称为<strong>切面</strong>，而<strong>切入到哪些类、哪些方法</strong>则叫<strong>切入点</strong>。有了AOP，我们就可以<strong>把几个类共有的代码（多个类&#x2F;业务逻辑代码的大切割），抽取到一个切片中，等到需要时再切入对象中去</strong>，从而改变其原有的行为。</p><blockquote><p>总结：<strong>AOP称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”，减少了系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性</strong></p></blockquote><h4 id="常见的AOP场景"><a href="#常见的AOP场景" class="headerlink" title="常见的AOP场景"></a>常见的AOP场景</h4><ul><li>记录操作日志——日志是公共行为，使用AOP提取</li><li>缓存处理——使用AOP切面<strong>拦截</strong>需要缓存的业务方法（可以看出，AOP其实就是拦截一些方法，执行一些公共方法）</li><li>Spring中内置的事务处理（见06）</li></ul><p>可以将AOP视为OOP的补充——<strong>OOP从纵向上区分出一个个的类来，而AOP则从横向上向对象中加入特定的代码</strong></p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-31-AOP01.png" alt="2024-7-31-AOP01"></p><span id="more"></span><h3 id="AOP相关术语"><a href="#AOP相关术语" class="headerlink" title="AOP相关术语"></a>AOP相关术语</h3><ul><li><p><strong>连接点——Jointpoint</strong>：</p><p>表示需要在程序中插入横切关注点的扩展点，<strong>连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等</strong>，Spring只支持方法执行连接点，</p><p>在AOP中表示为<strong>在哪里干</strong>（在哪里插入）</p></li><li><p><strong>切入点——Pointcut</strong></p><p>选择一组相关连接点的模式，可以认为是<strong>连接点的集合</strong>，在AOP中表示为<strong>在哪里干的集合</strong>（在哪里插入的集合）</p><p>Spring默认使用AspectJ语法，如：**<code>execution(* tech.pdai.springframework.service.*.*(..))</code>**</p><ol><li><strong><code>execution(...)</code></strong>: 这是Spring AOP中用于定义切点的表达式的前缀，指示这是一个方法执行的匹配。</li><li><strong><code>*</code>（第一个星号）</strong>: 表示返回类型可以是任意的</li><li><strong><code>tech.pdai.springframework.service.</code></strong>: 这是包名，表示这个切点匹配的是在<code>tech.pdai.springframework.service</code>包下的类中的方法。</li><li><strong><code>*</code>（第二个星号）</strong>: 表示任意的类名。</li><li><strong><code>*</code>（第三个星号）</strong>: 表示类中的任意方法。</li><li><strong><code>(..)</code></strong>: 表示方法的参数可以是任意类型、任意数量。</li></ol><p>上述表示：切点为<code>tech.pdai.springframework.service</code>包中 all 类中 all 返回类型 + all 参数类型 的 all 方法，也就是整个包中全部的方法</p><p>execution（modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern（param-pattern） throws-pattern?）</p><p>ret-type-pattern——返回类型，</p></li><li><p><strong>通知——Advice</strong>：</p><p><strong>在连接点上执行的行为</strong>，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知（after advice）、环绕通知（around advice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；</p><p>在AOP中表示为<strong>干什么</strong>；</p></li><li><p><strong>切面——Aspect</strong>：</p><p><strong>横切关注点的模块化</strong>，比如日志组件等，一个切面就是一个类。<strong>可以认为是通知、引入和切入点的组合</strong>，但是一个切面可以定义多个通知；在Spring中<strong>可以使用Schema和@AspectJ方式进行组织实现</strong>；</p><p>在AOP中表示为<strong>在哪干和干什么集合</strong>；</p></li><li><p><strong>引入——inter-type declaration</strong>：</p><p>也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现类）到所有被代理对象（目标对象）</p><p>在AOP中表示<strong>干什么&#x2F;引入什么</strong></p></li><li><p><strong>目标对象——Target Object</strong></p><p>需要被植入横切横切关注点的对象，即该对象<strong>是切入点选择的对象</strong>，<strong>需要被通知的对象</strong>，被通知对象；由于Spring AOP是通过代理模式实现的，所以这个对象永远是被代理对象</p><p>在AOP中表示为<strong>对着谁干</strong></p></li><li><p><strong>织入——Weaving</strong></p><p>把切面连接到其他的应用程序or对象上，并创建一个被通知的对象。这样可以在编译时、类加载时和运行时完成</p><p>在AOP中表示为<strong>怎么实现的</strong></p></li><li><p><strong>AOP代理——AOP Proxy</strong></p><p>AOP框架使用代理模式创建的对象，从而<strong>实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面</strong>；在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。</p><p>在AOP中表示为<strong>怎么实现的一种典型方式</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-31-AOP02.png" alt="2024-7-31-AOP02"></p><h4 id="一些切入点表达式的例子"><a href="#一些切入点表达式的例子" class="headerlink" title="一些切入点表达式的例子"></a>一些切入点表达式的例子</h4><ul><li><code>execution(public * *(..))</code>：表示任意公共方式</li><li><code>execution(* set* (..))</code>：表示任意名字以“set”开始的方法</li><li><code>execution(* com.xyz.service.AccountService.* (..))</code>：表示AccountService接口定义的任意方法</li><li><code>execution(* com.xyz.service.*.* (..))</code>：表示service包中定义的任意方法</li><li><code>execution(* com.xyz.service..*.* (..))</code>：表示service或其子包中定义的任意方法</li></ul><h2 id="AOP配置和使用方式"><a href="#AOP配置和使用方式" class="headerlink" title="AOP配置和使用方式"></a>AOP配置和使用方式</h2><h3 id="XML-Schema配置方式"><a href="#XML-Schema配置方式" class="headerlink" title="XML Schema配置方式"></a>XML Schema配置方式</h3><p>Spring提供了使用”aop”命名空间来定义一个切面</p><ul><li><p>定义目标类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.aopdemo.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Yhy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopDemoServiceImpl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doMethod1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AopDemoServiceImpl.doMethod1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doMethod2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AopDemoServiceImpl.doMethod2()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doMethod3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AopDemoServiceImpl.doMethod3()&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;some exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义切面类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.aopdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Yhy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp pjp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知: 进入方法&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知: 退出方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result return val</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterReturning</span><span class="params">(String result)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知, 返回值: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterThrowing</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常通知, 异常: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最终通知.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>XML配置AOP（在resources目录中）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example.aopdemo&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 目标类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.aopdemo.service.AopDemoServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- configure properties of bean here as normal --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.aopdemo.aspect.LogAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- configure properties of aspect here as normal --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;logAspect&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置切入点 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointCutMethod&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* org.example.aopdemo.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 环绕通知 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;doAround&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCutMethod&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 前置通知 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;doBefore&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCutMethod&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 后置通知；returning属性：用于设置后置通知的第二个参数的名称，类型是Object --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;doAfterReturning&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCutMethod&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;result&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 异常通知：如果没有异常，将不会执行增强；throwing属性：用于设置通知第二个参数的的名称、类型--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;doAfterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCutMethod&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;e&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 最终通知 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;doAfter&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCutMethod&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.aopdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.example.aopdemo.service.AopDemoServiceImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// create and configure beans</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;aspects.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// retrieve configured instance</span></span><br><span class="line">        <span class="type">AopDemoServiceImpl</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;demoService&quot;</span>, AopDemoServiceImpl.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use configured instance</span></span><br><span class="line">        service.doMethod1();</span><br><span class="line">        service.doMethod2();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            service.doMethod3();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-----------------------</span><br><span class="line">环绕通知: 进入方法</span><br><span class="line">前置通知</span><br><span class="line">AopDemoServiceImpl.doMethod1()</span><br><span class="line">环绕通知: 退出方法</span><br><span class="line">最终通知</span><br><span class="line">-----------------------</span><br><span class="line">环绕通知: 进入方法</span><br><span class="line">前置通知</span><br><span class="line">AopDemoServiceImpl.doMethod2()</span><br><span class="line">环绕通知: 退出方法</span><br><span class="line">最终通知</span><br><span class="line">后置通知, 返回值: hello world</span><br><span class="line">-----------------------</span><br><span class="line">环绕通知: 进入方法</span><br><span class="line">前置通知</span><br><span class="line">AopDemoServiceImpl.doMethod3()</span><br><span class="line">最终通知</span><br><span class="line">异常通知, 异常: some exception</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="AspectJ-注解方式"><a href="#AspectJ-注解方式" class="headerlink" title="AspectJ 注解方式"></a>AspectJ 注解方式</h3><p>基于XML的声明式AspectJ存在一些不足，需要在Spring配置文件配置大量的代码信息，为了解决这个问题，Spring 使用了@AspectJ框架为AOP的实现提供了一套注解。</p><table><thead><tr><th>注解名称</th><th>作用解释</th></tr></thead><tbody><tr><td><code>@Aspect</code></td><td><strong>用来定义一个切面</strong></td></tr><tr><td><code>@pointcut</code></td><td><strong>用于定义切点表达式</strong>（大多为上面的AspectJ语法表达式）。<strong>在使用时还需要定义一个包含名字和任意参数的方法签名来表示切入点名称</strong>，<strong>这个方法签名就是一个返回值为void，且方法体为空的普通方法</strong>，详见下面的例子</td></tr><tr><td><code>@Before</code></td><td><strong>用于定义前置通知</strong>，相当于BeforeAdvice。在使用时，通常需要指定一个value属性值，该属性值用于指定一个切入点表达式(可以是已有的切入点，也可以直接定义切入点表达式)。</td></tr><tr><td><code>@AfterReturning</code></td><td><strong>用于定义后置通知，相当于AfterReturningAdvice</strong>。在使用时可以指定pointcut &#x2F; value和returning属性</td></tr><tr><td><code>@Around</code></td><td><strong>用于定义环绕通知，相当于MethodInterceptor</strong>，value属性指定切点</td></tr><tr><td><code>@AfterThrowing</code></td><td><strong>用于定义异常通知来处理程序中未处理的异常，相当于ThrowAdvice</strong>，在使用时可指定pointcut &#x2F; value和throwing属性，pointcut &#x2F; value指定切点，<strong>throwing属性值用于指定-一个形参名来表示Advice方法中可定义与此同名的形参，该形参可用于访问目标方法抛出的异常。</strong></td></tr><tr><td><code>@After</code></td><td><strong>用于定义最终final 通知</strong>，value属性指定切点</td></tr></tbody></table><h4 id="接口使用JDK代理"><a href="#接口使用JDK代理" class="headerlink" title="接口使用JDK代理"></a>接口使用JDK代理</h4><ul><li><p>定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Jdk Proxy Service.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Yhy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IJdkProxyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doMethod1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">doMethod2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">doMethod3</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Yhy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyDemoServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IJdkProxyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doMethod1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;JdkProxyServiceImpl.doMethod1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doMethod2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;JdkProxyServiceImpl.doMethod2()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doMethod3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;JdkProxyServiceImpl.doMethod3()&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;some exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.aopdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Yhy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * define point cut.</span></span><br><span class="line"><span class="comment">     * 需要声明一个无参且void的函数，作为切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* tech.pdai.springframework.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pointCutMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp pjp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;pointCutMethod()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知: 进入方法&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知: 退出方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointCutMethod()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result return val</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;pointCutMethod()&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterReturning</span><span class="params">(String result)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知, 返回值: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing(pointcut = &quot;pointCutMethod()&quot;, throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterThrowing</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常通知, 异常: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最终通知.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(&quot;pointCutMethod()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-----------------------</span><br><span class="line">环绕通知: 进入方法</span><br><span class="line">前置通知</span><br><span class="line">JdkProxyServiceImpl.doMethod1()</span><br><span class="line">最终通知</span><br><span class="line">环绕通知: 退出方法</span><br><span class="line">-----------------------</span><br><span class="line">环绕通知: 进入方法</span><br><span class="line">前置通知</span><br><span class="line">JdkProxyServiceImpl.doMethod2()</span><br><span class="line">后置通知, 返回值: hello world</span><br><span class="line">最终通知</span><br><span class="line">环绕通知: 退出方法</span><br><span class="line">-----------------------</span><br><span class="line">环绕通知: 进入方法</span><br><span class="line">前置通知</span><br><span class="line">JdkProxyServiceImpl.doMethod3()</span><br><span class="line">异常通知, 异常: some exception</span><br><span class="line">最终通知</span><br></pre></td></tr></table></figure></li></ul><h4 id="非接口使用Cglib代理"><a href="#非接口使用Cglib代理" class="headerlink" title="非接口使用Cglib代理"></a>非接口使用Cglib代理</h4><ul><li><p>类定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cglib proxy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Yhy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyDemoServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doMethod1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CglibProxyDemoServiceImpl.doMethod1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doMethod2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CglibProxyDemoServiceImpl.doMethod2()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doMethod3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CglibProxyDemoServiceImpl.doMethod3()&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;some exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>切面定义——和上面相同</p></li><li><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-----------------------</span><br><span class="line">环绕通知: 进入方法</span><br><span class="line">前置通知</span><br><span class="line">CglibProxyDemoServiceImpl.doMethod1()</span><br><span class="line">最终通知</span><br><span class="line">环绕通知: 退出方法</span><br><span class="line">-----------------------</span><br><span class="line">环绕通知: 进入方法</span><br><span class="line">前置通知</span><br><span class="line">CglibProxyDemoServiceImpl.doMethod2()</span><br><span class="line">后置通知, 返回值: hello world</span><br><span class="line">最终通知</span><br><span class="line">环绕通知: 退出方法</span><br><span class="line">-----------------------</span><br><span class="line">环绕通知: 进入方法</span><br><span class="line">前置通知</span><br><span class="line">CglibProxyDemoServiceImpl.doMethod3()</span><br><span class="line">异常通知, 异常: some exception</span><br><span class="line">最终通知</span><br></pre></td></tr></table></figure></li></ul><h2 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h2><blockquote><p>关键词：JDK、Cglib、动态代理（理论实现）</p></blockquote><p>AOP 是 IoC 的一个扩展功能，现有的IoC，再有的AOP；AOP只是在IoC的整个流程中新增的一个扩展点而已</p><p>AOP 针对的对象是 Bean，Bean的扩展点在BenaPostProcessor接口</p><h3 id="Spring-AOP的底层实现原理"><a href="#Spring-AOP的底层实现原理" class="headerlink" title="Spring AOP的底层实现原理"></a>Spring AOP的底层实现原理</h3><ul><li>总述：AOP概念、应用场景、动态代理</li><li>分：bean的创建中有一个步骤可以对bean进行扩展实现——BeanPostProcessor；AOP本身就是一个扩展功能，所以在BeanPostProcessor的后置方法中来进行实现<ol><li>代理对象的创建过程（advice，切面，切点）</li><li>通过 jdk 或者 cglib的方式来生成代理对象（如果目标类是接口就一定会使用jdk代理，如果目标类没有可以代理的接口就一定会使用Cglib代理）</li><li>在执行方法调用的时候，会调用到生成的字节码文件中，直接会找到DynamicAdvisedInterceptor类中的intercept方法，从此方法开始执行</li><li>根据之前定义好的通知来生成拦截器链</li><li>从拦截器链中依次获取每一个通知，开始进行执行</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring核心知识04：循环依赖 &amp; 三级缓存</title>
      <link href="/2024/07/30/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8604/"/>
      <url>/2024/07/30/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8604/</url>
      
        <content type="html"><![CDATA[<blockquote><p>循环依赖——两者相互依赖（此部分需要结合05-AOP学习）</p></blockquote><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p><strong>在开发中，经常出现我们写的两个类、甚至多个类相互依赖了；但是很难注意到——因为没有报错，因为Spring会帮我们解决这个问题</strong></p><p>循环依赖，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    BookService bookService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AuthorService authorService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">annotationConfigApplicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) annotationConfigApplicationContext.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        System.out.println(bookService.authorService);</span><br><span class="line"></span><br><span class="line">        <span class="type">AuthorService</span> <span class="variable">authorService</span> <span class="operator">=</span> (AuthorService) annotationConfigApplicationContext.getBean(<span class="string">&quot;authorService&quot;</span>);</span><br><span class="line">        System.out.println(authorService.bookService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到BookService中需要AuthorService，而AuthorService中需要BookSrevice，于是形成了循环依赖，按理说应该出现死锁：</p><ol><li>创建bean B，发现依赖bean A</li><li>创建bean A，发现依赖bean B</li><li>创建bean B，发现依赖Bean A</li><li>创建bean A，发现依赖bean B……死循环</li></ol><p>要创建beanA，它需要beanB，而创建beanB，又需要beanA，然后两个bean都创建不出来</p><p><strong>但是在我们的实践中，却什么问题都没有</strong></p><span id="more"></span><h3 id="Spirng不能解决的循环依赖场景"><a href="#Spirng不能解决的循环依赖场景" class="headerlink" title="Spirng不能解决的循环依赖场景"></a>Spirng不能解决的循环依赖场景</h3><ol><li><p><strong>原型Bean</strong>的循环依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope(BeanDefinition.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AuthorService authorService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope(BeanDefinition.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    BookService bookService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>构造参数注入</strong>的循环依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorService</span> &#123;</span><br><span class="line">    BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthorService</span><span class="params">(BookService bookService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookService = bookService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    AuthorService authorService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookService</span><span class="params">(AuthorService authorService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.authorService = authorService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环依赖被关闭</p></li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">        applicationContext.setAllowCircularReferences(<span class="literal">false</span>);</span><br><span class="line">        applicationContext.register(AppConfig.class); <span class="comment">// 一定要注意此处，实例化之后，设置不允许循环依赖，再初始化</span></span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何简单的解决循环依赖（无AOP）"><a href="#如何简单的解决循环依赖（无AOP）" class="headerlink" title="如何简单的解决循环依赖（无AOP）"></a>如何简单的解决循环依赖（无AOP）</h3><blockquote><p><strong>Spring 解决循环依赖的核心就是提前暴露对象。</strong></p></blockquote><p>首先明确两个东西：</p><ul><li><strong><code>singletonObjects</code><strong>：</strong>单例池</strong>，其中存放的是经理了Spring完整生命周期的bean，这里面的bean的依赖都已经填充完毕了</li><li><strong><code>earlySingletonObjects</code><strong>：</strong>提前暴露出来的对象的map</strong>，其中存放的是刚刚创建出来的对象，没有经络Spring完整生命收起的bean，这里面的bean的依赖还没有填充完毕</li></ul><p><strong>循环依赖解决过程</strong>：</p><ol><li>当我们<strong>创建完beanA，就把beanA放到earlySingletonObjects</strong>，发现它需要beanB，然后就去创建beanB</li><li>当我们<strong>创建完beanB，就把beanB放到earlySingletonObjects</strong>，发现它需要beanA，然后就去创建beanA</li><li>创建beanA前，先去earlySingletonObjects看一下，发现自己已经被创建出来了，就发自己返回出去</li><li>beanB拿到beanA，beanB创建完毕，把自己放入SingletonObjects</li><li>beanA就可以去earlySingletonObjects拿到beanB了，beanA也就创建完毕，把自己放到singletonObjects中</li></ol><p>示例如下：</p><ul><li><p>首先自定义一个注解，字段上打上这个注解的，说明需要被Autowired：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAutowired &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建两个循环依赖的类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@MyAutowired</span></span><br><span class="line">    <span class="keyword">public</span> UserService userService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@MyAutowired</span></span><br><span class="line">    <span class="keyword">public</span> OrderService orderService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>模拟Spring创建对象、填充属性、解决Spring循环依赖的问题</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cycle</span> &#123;</span><br><span class="line">    <span class="comment">// 单例池，里面放的是完整的bean，已完成填充属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放的是提前暴露出来的bean，没有经历过spring完整的生命周期，没有填充属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Spring中，这个map存放的是beanNam和beanDefinition的映射关系</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Class&lt;?&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">&quot;orderService&quot;</span>, OrderService.class);</span><br><span class="line">        map.put(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果先调用init方法，就是预加载，如果直接调用getBean就是懒加载，两者的循环依赖问题都解决了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Class&lt;?&gt;&gt; stringClassEntry : map.entrySet()) &#123;</span><br><span class="line">            createBean(stringClassEntry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试从singletonObjects中取，</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> singletonObject;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试从earlySingletonObjects取</span></span><br><span class="line">        singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> singletonObject;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> createBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">createBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        Object singletonObject;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建对象</span></span><br><span class="line">            singletonObject = map.get(beanName).getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把没有完成填充属性的半成品 bean 放入earlySingletonObjects</span></span><br><span class="line">            earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 填充属性</span></span><br><span class="line">            populateBean(singletonObject);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// bean创建成功，放入singletonObjects</span></span><br><span class="line">            <span class="built_in">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> singletonObject;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        Field[] fields = object.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field.getAnnotation(MyAutowired.class) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getBean(field.getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    field.set(object, value); <span class="comment">// set注入bean对象</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用测试</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cycle</span> <span class="variable">cycle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cycle</span>();</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) cycle.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="type">OrderService</span> <span class="variable">orderService</span> <span class="operator">=</span> (OrderService) cycle.getBean(<span class="string">&quot;orderService&quot;</span>);</span><br><span class="line">        System.out.println(userService.orderService);</span><br><span class="line">        System.out.println(orderService.userService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cycle</span> <span class="variable">cycle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cycle</span>();</span><br><span class="line">        cycle.init(); <span class="comment">// 预加载调用</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) cycle.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="type">OrderService</span> <span class="variable">orderService</span> <span class="operator">=</span> (OrderService) cycle.getBean(<span class="string">&quot;orderService&quot;</span>);</span><br><span class="line">        System.out.println(userService.orderService);</span><br><span class="line">        System.out.println(orderService.userService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="为什么Spirng不能解决上述的循环依赖场景"><a href="#为什么Spirng不能解决上述的循环依赖场景" class="headerlink" title="为什么Spirng不能解决上述的循环依赖场景"></a>为什么Spirng不能解决上述的循环依赖场景</h3><p>根据我们手写的解决循环依赖的代码，我们可以看到，<strong>核心是利用一个map，来解决这个问题，而这个map就相当于是缓存</strong></p><p>为什么可以这么做，因为我们的<strong>bean是单例的</strong>（<strong>单例意味着只需要创建一次对象，后面就可以从缓存中取出来</strong>），而且是<strong>字段注入依赖</strong>（setter注入，<strong>意味着我们无需调用构造方法进行注入</strong>）。</p><ul><li>如果是<strong>原型bean</strong>，那么就意味着<strong>每次都需要去创建对象，无法利用缓存</strong>，导致提前创建的非完整的bean对象无法使用</li><li>如果是<strong>构造方法注入</strong>，那么就意味着需要调用构造方法注入（调用含参构造方法，bean一步成型，无须set），也无法利用缓存</li></ul><h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><p><strong>Spring 解决循环依赖的核心就是提前暴露对象</strong>，而提前暴露的对象就是放置于第二级缓存 earlySingletonObjects 中。</p><table><thead><tr><th>名称</th><th>描述</th><th>数据结构</th></tr></thead><tbody><tr><td>singletonObjects</td><td>一级缓存，存放完整的 Bean。</td><td>ConcurrentHashMap</td></tr><tr><td>earlySingletonObjects</td><td>二级缓存，存放提前暴露的Bean，Bean 是不完整的，未完成属性注入和执行 init 方法。</td><td>HashMap</td></tr><tr><td>singletonFactories</td><td>三级缓存，存放的是 Bean 工厂（和AOP有关），主要是生产 Bean，存放到二级缓存中。</td><td>HashMap</td></tr></tbody></table><p>上面的三级缓存为三个map，<strong>key为bean name，value是不同阶段的bean</strong>；而只有一级缓存是ConcurrentHashMap操作时不用显示加锁，其余都需要加锁</p><h3 id="为什么要使用三级缓存"><a href="#为什么要使用三级缓存" class="headerlink" title="为什么要使用三级缓存"></a>为什么要使用三级缓存</h3><blockquote><p>如果我们的 bean 创建出来，还要做一点加工，怎么办？（常见的是AOP，要生成 bean 的代理对象）</p><p>如：如果beanA和【beanB的代理对象】循环依赖，或者【beanA的代理对象】和beanB循环依赖，再或者【beanA的代理对象】和【beanB的代理对象】循环依赖，怎么办？</p><p>PS：<a href="http://yhy1031.cn/2024/07/31/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8605/">AOP见05</a></p></blockquote><p>同时为了满足Spring中在bean生命周期的最后几步才去AOP，我们不能和之前一样，直接把半成品的bean放进二级缓存，之后再填充；</p><p>因为，<strong>如果创建的 Bean 是有代理的，那么注入的就应该是代理 Bean，而不是原始的 Bean</strong>；但是 Spring 一开始并不知道 Bean 是否会有循环依赖，通<strong>常情况下（没有循环依赖的情况下），Spring 都会在完成填充属性，并且执行完初始化方法之后再为其创建代理</strong>。但是，<strong>如果出现了循环依赖的话，Spring 就不得不为其提前创建代理对象，此时注入的就是一个原始对象，而不是代理对象</strong>。</p><p>因此提出了三级缓存，存放该bean的beanfactory，在适当的时候生成就行。</p><h3 id="getSingleton方法中三级缓存的使用"><a href="#getSingleton方法中三级缓存的使用" class="headerlink" title="getSingleton方法中三级缓存的使用"></a>getSingleton方法中三级缓存的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">  <span class="comment">// Spring首先从singletonObjects（一级缓存）中尝试获取</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">  <span class="comment">// 若是获取不到而且对象在建立中，则尝试从earlySingletonObjects(二级缓存)中获取</span></span><br><span class="line">  <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123; <span class="comment">// 非ConcurrentHashMap，需要加锁</span></span><br><span class="line">        singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">          <span class="comment">//若是仍是获取不到而且允许从singletonFactories经过getObject获取，则经过singletonFactory.getObject()(三级缓存)获取</span></span><br><span class="line">          ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">          <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">              singletonObject = singletonFactory.getObject();</span><br><span class="line">              <span class="comment">//若是获取到了则将singletonObject放入到earlySingletonObjects,也就是将三级缓存提高到二级缓存中</span></span><br><span class="line">              <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">              <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isSingletonCurrentlyInCreation()</code> 方法用于判断当前单例 Bean 是否正在创建中，即「还没有执行初始化方法」。比如，A 的构造器依赖了 B 对象因此要先去创建 B 对象，或者在 A 的属性装配过程中依赖了 B 对象因此要先创建 B 对象，这时 A 就是处于创建中的状态。</p><p><code>allowEarlyReference</code> 变量表示是否允许从三级缓存 <code>singletonFactories</code> 中经过 <code>singletonFactory</code> 的 <code>getObject()</code> 方法获取 Bean 对象。</p><p><strong>具体流程如下</strong>：</p><ul><li>Spring 会先从一级缓存 <code>singletonObjects</code> 中尝试获取 Bean。</li><li>若是获取不到，而且对象正在建立中，就会尝试从二级缓存 <code>earlySingletonObjects</code> 中获取 Bean。</li><li>若还是获取不到，且允许从三级缓存 <code>singletonFactories</code> 中经过 <code>singletonFactory</code> 的 <code>getObject()</code> 方法获取 Bean 对象，就会尝试从三级缓存 <code>singletonFactories</code> 中获取 Bean。</li><li>若是在三级缓存中获取到了 Bean，会将该 Bean 存放到二级缓存中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring核心知识03：依赖注入</title>
      <link href="/2024/07/28/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8603/"/>
      <url>/2024/07/28/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8603/</url>
      
        <content type="html"><![CDATA[<blockquote><p>DI，是 Dependency Injection 的缩写，即依赖注入。依赖注入是 IoC 的最常见形式。依赖注入是手动或自动绑定的方式，无需依赖特定的容器或 API</p></blockquote><p>DI 是一个过程，其中对象仅通过构造函数参数、工厂方法的参数或对象实例在构造方法或工厂方法返回。然后容器在创建bean时注入这些依赖项。</p><p>如下，即为通过构造函数参数注入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>容器全权负责组件的装配，它会把符合依赖关系的对象通过 JavaBean 属性（成员变量）或者构造函数传递给需要的对象</strong>。</p><span id="more"></span><h3 id="依赖注入模式"><a href="#依赖注入模式" class="headerlink" title="依赖注入模式"></a>依赖注入模式</h3><h4 id="手动注入模式"><a href="#手动注入模式" class="headerlink" title="手动注入模式"></a>手动注入模式</h4><p>通过配置或者编程的方式，提前安排注入规则</p><h4 id="自动注入模式"><a href="#自动注入模式" class="headerlink" title="自动注入模式"></a>自动注入模式</h4><p>也就是自动装配——Spring容器可以自动装配Bean之间的关系。</p><p>Spring可以检查<code>ApplicationContext</code>的内容，自动解析其他Bean</p><p>自动装配可以显著减少属性 or 构造函数参数的配置；存在一下不足，不推荐使用（见下）</p><h4 id="自动装配策略"><a href="#自动装配策略" class="headerlink" title="自动装配策略"></a>自动装配策略</h4><p>当使用基于 XML 的配置元数据时，可以使用 <code>&lt;bean/&gt;</code> 元素的 <code>autowire</code> 属性为 Bean 指定自动装配模式。</p><p>autowire的模式包括：no、byName（根据注入属性的名称作为Bean名称进行查找）、byType（根据注入属性的类型作为依赖类型进行查找）、constructor</p><h4 id="Autowired注入过程"><a href="#Autowired注入过程" class="headerlink" title="@Autowired注入过程"></a>@Autowired注入过程</h4><ul><li><strong>元信息解析</strong></li><li><strong>依赖查找</strong></li><li><strong>依赖注入</strong></li></ul><h4 id="自动装配的限制和不足"><a href="#自动装配的限制和不足" class="headerlink" title="自动装配的限制和不足"></a><strong>自动装配的限制</strong>和不足</h4><ul><li><strong>属性和构造函数参数设置中的显式依赖项会覆盖自动装配</strong>。您不能自动装配简单属性，例如基础数据类型、字符串和类（以及此类简单属性的数组）。</li><li><strong>自动装配不如显式装配精准</strong>。Spring 会尽量避免猜测可能存在歧义的结果。</li><li>Spring 容器生成文档的工具可能无法解析自动装配信息。</li><li><strong>如果同一类型存在多个 Bean 时，自动装配时会存在歧义</strong>。容器内的多个 Bean 定义可能与要自动装配的 Setter 方法或构造函数参数指定的类型匹配。对于数组、集合或 Map 实例，这不一定是问题。但是，对于期望单值的依赖项，如果没有唯一的 Bean 定义可用，则会引发异常。</li></ul><h3 id="依赖注入方法"><a href="#依赖注入方法" class="headerlink" title="依赖注入方法"></a>依赖注入方法</h3><p>依赖注入有如下方式：</p><ul><li>Setter方法注入，<code>&lt;proeprty name=&quot;user&quot; ref=&quot;userBean&quot;/&gt;</code></li><li>构造器注入，<code>&lt;constructor-arg name=&quot;user&quot; ref=&quot;userBean&quot; /&gt;</code></li><li>字段注入，<code>@Autowired User user;</code></li><li>方法注入，<code>@Autowired public void user(User user) &#123; ... &#125;</code></li><li>接口回调注入，<code>class MyBean implements BeanFactoryAware &#123; ... &#125;</code></li></ul><h4 id="Setter方法注入——注入可选依赖项"><a href="#Setter方法注入——注入可选依赖项" class="headerlink" title="Setter方法注入——注入可选依赖项"></a>Setter方法注入——注入可选依赖项</h4><p><strong>Setter 方法注入是通过容器在调用无参数构造函数或无参数静态工厂方法来实例化 bean 后调用 bean 上的 setter 方法来完成的</strong>。——无参+Set函数（这就是为什么标准Bean需要有set函数）</p><h4 id="构造器注入——注入强制依赖项"><a href="#构造器注入——注入强制依赖项" class="headerlink" title="构造器注入——注入强制依赖项"></a>构造器注入——注入强制依赖项</h4><p><strong>构造器注入是通过容器调用具有含参数的构造函数来完成的</strong>，每个参数代表一个依赖项。调用带有特定参数的静态工厂方法来构造 bean 几乎是等价的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果 bean 定义的构造函数参数中不存在潜在的歧义，则在 bean 定义中定义构造函数参数的顺序是在实例化 bean 时将这些参数提供给适当构造函数的顺序。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThingOne</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThingOne</span><span class="params">(ThingTwo thingTwo, ThingThree thingThree)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设 <code>ThingTwo</code> 和 <code>ThingThree</code> 类没有继承关系，则<strong>不存在潜在的歧义</strong>。因此，以下配置工作正常，<strong>无需在 <code>&lt;constructor-arg/&gt;</code> 元素中显式指定构造函数参数索引或类型</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingOne&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;beanTwo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;beanThree&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanTwo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingTwo&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanThree&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingThree&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当引用另一个 bean 时，类型是已知的，并且可以发生匹配（就像前面的示例一样）。<strong>当使用简单类型时，例如 <code>&lt;value&gt;true&lt;/value&gt;</code> ，Spring 无法确定 value 的类型</strong>，<strong>因此需要在 <code>&lt;constructor-arg/&gt;</code> 元素中显式指定构造函数参数的类型</strong>。</p><h5 id="几种构造函数参数类型与xml元素的示例"><a href="#几种构造函数参数类型与xml元素的示例" class="headerlink" title="几种构造函数参数类型与xml元素的示例"></a>几种构造函数参数类型与xml元素的示例</h5><ol><li><p><strong>构造函数参数类型匹配</strong></p><p>如果使用 type 属性显式指定构造函数参数的类型，则容器可以使用简单类型的类型匹配</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>构造函数参数索引匹配</strong></p><p>可以使用 <code>index</code> 属性显式指定构造函数参数的索引</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>构造函数参数名称匹配</strong></p><p>可以使用Bean的name来指定具体的构造函数的索引</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;years&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ultimateAnswer&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还可以使用 <code>@ConstructorProperties</code> 显式命名构造函数参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fields omitted</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConstructorProperties(&#123;&quot;years&quot;, &quot;ultimateAnswer&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleBean</span><span class="params">(<span class="type">int</span> years, String ultimateAnswer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.years = years;</span><br><span class="line">        <span class="built_in">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="字段注入"><a href="#字段注入" class="headerlink" title="字段注入"></a>字段注入</h4><p>手动模式（Java 注解配置元信息）</p><ul><li><code>@Autowired</code></li><li><code>@Resource</code></li><li><code>@Inject</code>（可选）</li></ul><h4 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h4><p>手动模式（Java 注解配置元信息）</p><ul><li><code>@Autowired</code></li><li><code>@Resource</code></li><li><code>@Inject</code>（可选）</li><li><code>@Bean</code></li></ul><h4 id="接口回调注入——Aware"><a href="#接口回调注入——Aware" class="headerlink" title="接口回调注入——Aware"></a>接口回调注入——Aware</h4><p>主要是使用Aware系列接口回调</p><p><code>BeanFactoryAware</code>：获取IoC容器——BeanFactory</p><p><code>ApplicationContextAware</code>：获取Spring应用上下文——ApplicationContext对象</p><p><code>EnvironmentAware</code>：获取Environment对象</p><p><code>ResourceLoaderAware</code>：获取资源加载对象——ResourceLoader</p><p><code>BeanClassLoaderAware</code>：获取加载当前Bean Class的ClassLoader</p><p><code>BeanNameAware</code>：获取当前Bean的名称</p><p><code>MessageSourceAware</code>：获取MessageSource对象，用于Spring国际化</p><p><code>ApplicationEventPublisherAware</code>：获取ApplicationEventPublishAware对象，用于Spring事件</p><p><code>EmbeddedValueResolverAware</code>：获取StringValueResolver对象，用于占位符处理</p><h4 id="依赖注入选型"><a href="#依赖注入选型" class="headerlink" title="依赖注入选型"></a>依赖注入选型</h4><ul><li>低依赖：构造器注入</li><li>多依赖：Setter 方法注入</li><li>便利性：字段注入</li><li>声明类：方法注入</li></ul><h3 id="依赖注入的数据类型"><a href="#依赖注入的数据类型" class="headerlink" title="依赖注入的数据类型"></a>依赖注入的数据类型</h3><h4 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h4><ul><li>基础数据类型：boolean、byte、char、short、int、long、double、float</li><li>标量数据类型：Number、Character、Boolean、Enum、Locale、Charset、Currency、Properties、UUID</li><li>常规类型：Object、String、TimeZone、Calendar、Optional</li><li>Spring类型：Resource、InputSource、Formatter</li></ul><h4 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h4><ul><li>数组类型：基础类型的数组</li><li>集合类型：<ul><li>Collection：list、Set</li><li>Map：Properties</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射</title>
      <link href="/2024/07/26/Java%E5%8F%8D%E5%B0%84/"/>
      <url>/2024/07/26/Java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JAVA反射机制是在运行状态中，<strong>对于任意一个类，都能够知道这个类的所有属性和方法</strong>；<strong>对于任意一个对象，都能够调用它的任意一个方法和属性</strong>；这种<strong>动态获取信息</strong>以及<strong>动态调用对象方法的功能</strong>称为java语言的反射机制。</p></blockquote><p><strong>反射就是把 Java 类中的各种成分映射成一个个的 Java 对象</strong>。（例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。）</p><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>Class类是一个实实在在的类，存在于JDK的java.lang包中。</p><p><strong>Class类的实例</strong>表示 <strong>java 应用运行时的类 or 接口</strong>，每个 java 类运行时都可以在 <a href="http://yhy1031.cn/2024/07/19/JVM01/">JVM</a> 里表现为一个 class 对象，可以通过<code>类名.class</code>、<code>类型.getClass()</code>、<code>Class.forName(&quot;全限定类名&quot;)</code>等方法获取class对象。</p><p><strong>数组</strong>同样也被应成为 class 对象的一个类，所有具有相同元素类型和维数的数组都共享该Class对象。</p><p><strong>基本数据类型 boolean、short、int、long、double、float、char、byte</strong> 和 <strong>关键字 void</strong> 同样被映射为class对象。</p><p>总结出以下特点：</p><ul><li>Class 类也是一种类，和class关键词不同</li><li><strong>手动编写的类被编译后会生成一个 Class 对象</strong>，其表示的是创建的类的类型信息，而且这个 Class 对象保存在同名的 .class 文件中（字节码文件）</li><li>每个通过关键字 <strong>class 标识的类</strong>，在内存中<strong>有且只有一个与之对应的 Class 对象来描述其类型信息</strong>，无论这个类创建了多少实例对象，其依据的都是同一个Class对象</li><li><strong>Class 类只有私有构造函数</strong>，因此对应 Class 对象只能由 JVM 创建和加载（只有私有构造函数，意味着外部代码无法使用new关键字直接创建 Class 对象）</li><li><strong>Class 类的对象作用是运行时提供 or 获得某个对象的类型信息</strong></li></ul><span id="more"></span><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a><a href="http://yhy1031.cn/2024/07/23/JVM03/">类加载机制</a></h3><p>（见JVM03部分）</p><h2 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h2><blockquote><p>我们如何通过反射获取Class类对象以及类中的成员变量、方法、构造方法等</p></blockquote><p>Java中，<strong>Class类</strong>和<strong>java.lang.reflect</strong>库一起支持反射技术。其中，常用的类有：</p><ul><li><strong>Constructor类</strong>，表示 Class 对象所对应类的构造方法，利用它可以<strong>在运行时动态创建对象</strong>。</li><li><strong>Field类</strong>，表示 Class 对象所对应类的成员变量，通过它可以<strong>在运行时动态的修改成员变量的属性值（包括private）</strong></li><li><strong>Method类</strong>，表示 Class 对象所对应类的成员方法，通过它可以动态调用对象的方法（包括private）</li></ul><h3 id="Class对象的获取"><a href="#Class对象的获取" class="headerlink" title="Class对象的获取"></a>Class对象的获取</h3><p>根据类加载机制，在类加载的时候（加载阶段），<strong>jvm会创建一个class对象</strong>（class对象可以说是反射中最常用的），下面是三种获取 class 对象的方式：</p><ul><li>根据<strong>类名</strong>：<code>类名.class</code></li><li>根据<strong>对象</strong>：<code>对象.getClass()</code></li><li>根据<strong>类的全限定名</strong>：<code>Class.forName(&quot;全限定名&quot;)</code></li></ul><p><strong>Class 类常用的方法</strong>（获取到class类之后使用的方法）：</p><ul><li><strong><code>forName()</code>，获取Class 对象的一个引用</strong>，如果引用的类还没有加载（该类的第一个对象还没用生成，Class对象也没有生成）就加载这个类；同时为了产生Class引用，forName()时立即就进行了初始化</li><li><strong><code>Object.getClass()</code>，获取Class 对象的一个引用</strong>（这个Object对象实际类型的Class引用），</li><li><strong><code>getName()</code>，获取全限定的类名</strong></li><li><strong><code>getSimpleName()</code>，获取类名（不带包名）</strong></li><li><strong><code>getCanonicalName()</code>，获取全限定名</strong></li><li><strong><code>isInterface()</code>，判断Class对象是否为接口</strong></li><li><strong><code>getInterfaces()</code>，返回Class对象数组</strong>，表示Class对象所引用的类所实现的所有接口（也就是<strong>基本类型实现的接口</strong>）</li><li><strong><code>getSupercalss()</code>，返回Class对象</strong>，表示Class对象所引用的类所集成的直接基类（也就是<strong>获取父类的Class对象</strong>）</li><li><strong><code>newInstance()</code>，返回一个Object对象</strong>，实现动态创建对象的关键。前提是，待创建的类必须待遇无参的构造函数（过时了，现在推荐使用，<code>clazz.getDeclaredConstructor().newInstance()</code>）</li><li><strong><code>getFields()</code>，获取某个类的所有公共字段（包含父类的所有公共字段，父类的父类…..也算）</strong>，同时还有<code>getMethods</code>、<code>getConstructors</code></li><li><strong><code>getDeclaredFields</code>，获取某个类的自己声明的字段（包括public、private、protected；但是不包括父类的字段）</strong>，同时还有<code>getDeclaredMethods</code>、<code>getDeclaredConstructors</code>（每次执行这个方法得到的顺序是随机的）</li></ul><p><strong>应用示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">I1</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I2</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> mCellPublic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">extends</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mAnimalPrivate;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> mAnimalProtected;</span><br><span class="line">    <span class="type">int</span> mAnimalDefault;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> mAnimalPublic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> sAnimalPrivate;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">int</span> sAnimalProtected;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> sAnimalDefault;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> sAnimalPublic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">I1</span>, I2 &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mDogPrivate;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> mDogProtected;</span><br><span class="line">    <span class="type">int</span> mDogDefault;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> mDogPublic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> sDogPrivate;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">int</span> sDogProtected;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> sDogDefault;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> sDogPublic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        Class&lt;Dog&gt; dog = Dog.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类名打印</span></span><br><span class="line">        System.out.println(<span class="string">&quot;三种方式类名打印，两全，一类&quot;</span>);</span><br><span class="line">        System.out.println(dog.getName());</span><br><span class="line">        System.out.println(dog.getCanonicalName());</span><br><span class="line">        System.out.println(dog.getSimpleName());</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接口</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取接口Class对象&quot;</span>);</span><br><span class="line">        System.out.println(dog.isInterface()); <span class="comment">// 肯定不是</span></span><br><span class="line">        <span class="keyword">for</span> (Class iI : dog.getInterfaces()) &#123;</span><br><span class="line">            <span class="comment">// 这里体现了，接口也有Class对象</span></span><br><span class="line">            System.out.println(iI);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父类</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取父类Class对象&quot;</span>);</span><br><span class="line">        System.out.println(dog.getSuperclass());</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> dog.newInstance();</span><br><span class="line">        <span class="comment">// 新方法</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d1</span> <span class="operator">=</span> dog.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字段</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取所有public字段对象&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Field f : dog.getFields()) &#123;</span><br><span class="line">            <span class="comment">// 每个字段也是一个类</span></span><br><span class="line">            System.out.println(f.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取所有自己声明的字段对象&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Field f : dog.getDeclaredFields()) &#123;</span><br><span class="line">            System.out.println(f.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">三种方式类名打印，两全，一类</span><br><span class="line">org.example.classCode.Dog</span><br><span class="line">org.example.classCode.Dog</span><br><span class="line">Dog</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">获取接口Class对象</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">interface org.example.classCode.I1</span><br><span class="line">interface org.example.classCode.I2</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">获取父类Class对象</span><br><span class="line">class org.example.classCode.Animal</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">获取所有public字段对象</span><br><span class="line">mDogPublic</span><br><span class="line">sDogPublic</span><br><span class="line">mAnimalPublic</span><br><span class="line">sAnimalPublic</span><br><span class="line">mCellPublic</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">获取所有自己声明的字段对象</span><br><span class="line">mDogPrivate</span><br><span class="line">mDogProtected</span><br><span class="line">mDogDefault</span><br><span class="line">mDogPublic</span><br><span class="line">sDogPrivate</span><br><span class="line">sDogProtected</span><br><span class="line">sDogDefault</span><br><span class="line">sDogPublic</span><br></pre></td></tr></table></figure><h3 id="Constructor类及其用法"><a href="#Constructor类及其用法" class="headerlink" title="Constructor类及其用法"></a>Constructor类及其用法</h3><blockquote><p>Constructor类存在于反射包(java.lang.reflect)中，反映的是 Class 对象所表示的类的构造方法。</p></blockquote><p><strong>获取Constructor对象是通过Class类中的方法获取的</strong>，Class类与Constructor相关的主要方法如下：</p><ul><li><p><strong><code>getConstructor(Class&lt;?&gt;… parameterTypes)</code>，返回指定参数类型、具有public访问权限的构造函数Constructor对象</strong></p></li><li><p><strong><code>getConstructors()</code>，返回具有public访问权限的构造函数的Constructor对象数组</strong></p></li><li><p><strong><code>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</code>，返回指定参数类型、所有声明（public、private、protected）的构造函数Constructor对象</strong></p></li><li><p><strong><code>getDeclaredConstructors</code>，返回所有声明的构造函数对象数组</strong></p></li></ul><p>关于<strong>Constructor类本身一些常用方法</strong>如下</p><ul><li><strong><code>getDeclaringClass()</code>，返回Class对象，该对象表示声明此Constructor对象的类</strong></li><li><strong><code>getGenericParameterTypes()</code>，按照声明顺序返回一组Type对象，表示该Constructor对象构造函数的形参类型</strong></li><li><strong><code>getParameterTypes()</code>，按照声明顺序返回一组Class对象，表示该Constructor对象构造函数的形参类型</strong>（Tpye是Class的父接口）</li><li><strong><code>newInstance()</code>，调用构造函数创建此 Class 对象所表示的类的一个新实例</strong></li><li><strong><code>toGenericString()</code>，返回描述此Constructor的字符串</strong>，包括权限类型、所属类的全限定名、形参类型</li></ul><p><strong>应用示例</strong>：<br>注意其中的<code>.setAccessible(true)</code>，因为这个构造函数是private，所以需要setAccessible(true)，动态的修改其访问权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;根据类的全限定名，获取Class对象的引用&quot;</span>);</span><br><span class="line">    clazz = Class.forName(<span class="string">&quot;org.example.classCode.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;实例化方法一：默认构造函数&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;实例化方法二：带String参数的public构造函数&quot;</span>);</span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructorString</span> <span class="operator">=</span> clazz.getConstructor(String.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">userString</span> <span class="operator">=</span> (User) constructorString.newInstance(<span class="string">&quot;hiway&quot;</span>);</span><br><span class="line">    userString.setAge(<span class="number">22</span>);</span><br><span class="line">    System.out.println(userString);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;实例化方法三：带int和String参数的private构造函数&quot;</span>);</span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructorPrivate</span> <span class="operator">=</span> clazz.getDeclaredConstructor(<span class="type">int</span>.class, String.class);</span><br><span class="line">    <span class="comment">// 因为这个构造函数是private，所以需要setAccessible(true)</span></span><br><span class="line">    constructorPrivate.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">userPrivate</span> <span class="operator">=</span> (User) constructorPrivate.newInstance(<span class="number">25</span>, <span class="string">&quot;YHY&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(userPrivate);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;获取所有构造函数&quot;</span>);</span><br><span class="line">    Constructor&lt;?&gt; constructorArray[] = clazz.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; constructorArray.length; i++) &#123;</span><br><span class="line">        Class&lt;?&gt; clazzs[] = constructorArray[i].getParameterTypes();</span><br><span class="line">        System.out.println(<span class="string">&quot;构造函数[&quot;</span> + i + <span class="string">&quot;]：&quot;</span> + constructorArray[i].toString());</span><br><span class="line">        System.out.print(<span class="string">&quot;参数类型[&quot;</span> + i + <span class="string">&quot;]：（&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; clazzs.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == clazzs.length - <span class="number">1</span>)</span><br><span class="line">                System.out.print(clazzs[j].getName());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.print(clazzs[j].getName() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;借助带int和String参数的private构造函数，展示Constructor类的部分方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----getDeclaringClass-----&quot;</span>);</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazzNew</span> <span class="operator">=</span> constructorPrivate.getDeclaringClass();</span><br><span class="line">    System.out.println(<span class="string">&quot;声明该构造函数的类-getDeclaringClass：&quot;</span> + clazzNew.getName());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----getGenericParameterTypes-----&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Type[] tps = constructorPrivate.getGenericParameterTypes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tps.length; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;参数[&quot;</span> + i + <span class="string">&quot;]：&quot;</span> + tps[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----getParameterTypes-----&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clazzs[] = constructorPrivate.getParameterTypes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; clazzs.length; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;参数[&quot;</span> + i + <span class="string">&quot;]：&quot;</span> + clazzs[i].getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----getName-----&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;该构造函数的方法名称-getName：&quot;</span> + constructorPrivate.getName());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----getoGenericString-----&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;该构造函数的描述-toGenericString：&quot;</span> + constructorPrivate.toGenericString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">根据类的全限定名，获取Class对象的引用</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">实例化方法一：默认构造函数</span><br><span class="line">User&#123;age=20, name=<span class="string">&#x27;Jack&#x27;</span>&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">实例化方法二：带String参数的public构造函数</span><br><span class="line">User&#123;age=22, name=<span class="string">&#x27;hiway&#x27;</span>&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">实例化方法三：带int和String参数的private构造函数</span><br><span class="line">User&#123;age=25, name=<span class="string">&#x27;YHY&#x27;</span>&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">获取所有构造函数</span><br><span class="line">构造函数[0]：private org.example.classCode.User(int,java.lang.String)</span><br><span class="line">参数类型[0]：（int java.lang.String)</span><br><span class="line">构造函数[1]：public org.example.classCode.User(java.lang.String)</span><br><span class="line">参数类型[1]：（java.lang.String)</span><br><span class="line">构造函数[2]：public org.example.classCode.User()</span><br><span class="line">参数类型[2]：（)</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">借助带int和String参数的private构造函数，展示Constructor类的部分方法</span><br><span class="line">-----getDeclaringClass-----</span><br><span class="line">声明该构造函数的类-getDeclaringClass：org.example.classCode.User</span><br><span class="line">-----getGenericParameterTypes-----</span><br><span class="line">参数[0]：int</span><br><span class="line">参数[1]：class java.lang.String</span><br><span class="line">-----getParameterTypes-----</span><br><span class="line">参数[0]：int</span><br><span class="line">参数[1]：java.lang.String</span><br><span class="line">-----getName-----</span><br><span class="line">该构造函数的方法名称-getName：org.example.classCode.User</span><br><span class="line">-----getoGenericString-----</span><br><span class="line">该构造函数的描述-toGenericString：private org.example.classCode.User(int,java.lang.String)</span><br></pre></td></tr></table></figure><h3 id="Field类及其用法"><a href="#Field类及其用法" class="headerlink" title="Field类及其用法"></a>Field类及其用法</h3><blockquote><p>Field 提供有关类或接口的单个字段的信息，以及对它动态的修改访问权限</p></blockquote><p><code>getField(String name)</code> 和 <code>getDeclaredField(String name)</code>，获取指定字段名称为name的字段对象，</p><p>Field类的<code>toString()</code> 输出的是这个字段的详细信息（访问权限、类型、所属的包名+变量名） </p><p>Field类还存在<code>set(对象, 值)</code>方法，用于改变指定对象的、指定字段的值（但是只有这个对象的会改变）</p><p>PS：部分方法：</p><ul><li>getAnnotations(Class clazz)：获取该成员变量上的指定的注解，传参为注解对应的类</li></ul><h3 id="Method类及其用法"><a href="#Method类及其用法" class="headerlink" title="Method类及其用法"></a>Method类及其用法</h3><blockquote><p>Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）</p></blockquote><p><code>getMethod(String name, Class&lt;?&gt;... parameterTypes) 和 getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code>，返回指定方法名 name 和指定参数类型 parameterTypes 的Method对象。</p><h4 id="invoke-方法"><a href="#invoke-方法" class="headerlink" title="invoke( )方法"></a>invoke( )方法</h4><p><code>invoke(Object object，Object... args)</code>，object 代表调用的对象，args表示传递的参数们——invoke方法实现了类方法的动态调用。</p><p>整体的应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    <span class="comment">// 先构造Class对象</span></span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;org.example.classCode.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再构造User对象</span></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(<span class="type">int</span>.class, String.class);</span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) constructor.newInstance(<span class="number">21</span>, <span class="string">&quot;Yhy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取方法并调用</span></span><br><span class="line">    System.out.println(clazz.getMethod(<span class="string">&quot;Birthday&quot;</span>).invoke(user));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yhy过生日了，又长大了一岁；今年22岁</span><br></pre></td></tr></table></figure><h2 id="反射机制执行的流程"><a href="#反射机制执行的流程" class="headerlink" title="反射机制执行的流程"></a>反射机制执行的流程</h2><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-26-Reflection01.png" alt="2024-7-26-Reflection01"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM03：类加载机制</title>
      <link href="/2024/07/23/JVM03/"/>
      <url>/2024/07/23/JVM03/</url>
      
        <content type="html"><![CDATA[<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p><strong>类加载</strong>：将类的calss文件中的二进制数据读入内存中，并将其<strong>放在运行时数据区的方法区</strong>内，然后在<strong>堆区创建一个此类的对象</strong>，<strong>通过这个对象访问到方法区对应的类信息</strong>（方法区-&gt;堆区；比较合理，堆区存储的是对象，而对象的对象头中存在一个类型数据指针，可以访问方法区中该对象的基本信息）</p><p>类的加载过程包括：<strong>加载</strong>、<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong>、<strong>初始化</strong>五个阶段，除了解析不确定，其他几个阶段都会<strong>按照顺序开始</strong>（不是按顺序进行or结束，存在一个阶段执行的过程中调用或激活另一个阶段的情况，有点串行的感觉）</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-23-JVMP1.png" alt="2024-7-23-JVMP1"></p><h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h4><ol><li>通过一个<strong>类的全限定名</strong>（如com.example.project.MyClass 包名+类名）来获取定义此<strong>类的二进制字节流</strong></li><li>将这个字节流所代表的<strong>静态存储结构</strong>转化为<strong>方法区的运行时数据结构</strong></li><li>在内存中生成一个<strong>代表这个类的java.lang.Class对象</strong>（生成对象在堆中），作为方法区中这个类的各种数据的访问入口</li></ol><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-26-JVM01.png" alt="2024-7-26-JVM01"></p><span id="more"></span><h4 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h4><p><strong>连接阶段的第一步</strong></p><p> <strong>确保Class文件的字节流中包含的信息符合虚拟机规范</strong>，保证在运行后不会危害虚拟机自身的安全。主要包括四种验证：</p><ul><li><strong>文件格式验证</strong>：验证读进来的字节流符合Class标准格式（如：是否以魔数0xCAFEBABE开头，版本号等能否被虚拟机执行等）</li><li><strong>元数据验证</strong>：格式对了（文件格式验证通过）之后，验证数据是否合理（如这个类是否有父类，除了java.lang.Object都要有父类）</li><li><strong>字节码验证</strong>：分析类的方法体，保证在运行时不会危害虚拟机</li><li><strong>符号引用验证</strong>（发生在解析阶段）：检查常量池中引用的外部类是否存在，是否可以正常访问</li></ul><h4 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h4><p><strong>为类的静态变量分配内存并设置类变量初始化值的阶段</strong></p><p>如果是final修饰的，则在Class文件中该字段的属性表中存在ConstanstValue属性，按照代码中写的给初值</p><p>如果不是final，则先赋0，初始化再赋值</p><h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h4><p><strong>虚拟机将常量池内符号引用替换为直接引用的过程</strong>——换句话说，解析阶段是将其常量池信息（就是字节码中类的信息）放入运行时常量池，并把里面的符号引用（符号地址）变为直接引用（真实地址）</p><p>符号引用：用于描述目标</p><p>直接引用：直接指向目标地址</p><h4 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h4><p><strong>初始化是为类的静态变量赋予正确的初始值（非final，之前赋值为0）</strong></p><p>初始化步骤：</p><ol><li>如果这个类还没有被加载和连接，则程序先加载并连接该类</li><li>如果该类的直接父类还没有被初始化，则先初始化它的直接父类</li><li>如果类中有初始化语句（静态代码块），则系统一次执行这些初始化语句</li></ol><p>（<strong>只有当对类的主动使用的时候才会导致类的初始化</strong>，如调用静态方法、访问or赋值静态变量、new、反射，初始化子类也会初始化父类）Class.forName()也会进行初始化</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-23-JVMP2.png" alt="2024-7-23-JVMP2"></p><h3 id="类加载器和类加载机制"><a href="#类加载器和类加载机制" class="headerlink" title="类加载器和类加载机制"></a>类加载器和类加载机制</h3><p>在Java程序中，对于任意一个类，都必须由<strong>加载它的类加载器</strong>和<strong>这个类本身</strong>一起共同确立其在Java虚拟机中的<strong>唯一性</strong>——<strong>同一个类被不同的加载器加载，即使来源是同一个Class文件，也会被视为不同的类</strong>（每个类加载器都有自己的命名空间）</p><p>所以<strong>一个限定名的类只会被一个类加载器加载</strong>，以保证其唯一性，且无歧义</p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-23-JVM03.png" alt="" style="zoom:67%;" /><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>三层类加载器</p><ul><li><strong>启动类加载器</strong>：Java核心库</li><li><strong>扩展类加载器</strong>：Java拓展库</li><li><strong>应用程序类加载器</strong>：classpath下的内容</li></ul><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p><strong>双亲委派模型工作过程</strong>：一个类加载器收到一个类的加载请求时，它<strong>首先不会自己尝试去加载它，而是把这个请求委派给父类加载器去完成</strong>，这样层层委派，因此<strong>所有的加载请求最终都会传送到顶层的启动类加载器</strong>中，<strong>只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载</strong>。</p><p><strong>好处：</strong>避免系统中出现同名的类，保证类之间比较结果以及类的唯一性</p><p><strong>Java类的实例化顺序：</strong></p><ol><li>父类中的static代码块，当前类的static代码块</li><li>父类的普通代码模块</li><li>父类的构造函数</li><li>当前类的普通代码块</li><li>当前类的构造函数</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java容器知识点补充——优先级队列</title>
      <link href="/2024/07/23/Java%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
      <url>/2024/07/23/Java%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>优先级队列<strong>PriorityQueue是Queue接口的实现</strong>，可以对其中元素进行排序，可以放基本数据类型的包装类（如：Integer，Long等）或自定义的类；对于基本数据类型的包装器类，优先队列中元素<strong>默认排列顺序是升序排列</strong>，但<strong>对于自己定义的类来说，需要自己定义比较器</strong></p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>peek()</code> 返回队首元素</li><li><code>poll()</code> 返回队首元素，且队首元素出队</li><li><code>add()</code> 添加元素（要排序，所以不一定在哪）</li><li><code>size()</code> 返回队列元素的个数</li><li><code>isEmpty()</code> 判断队列是否为空</li></ul><span id="more"></span><h3 id="优先级队列使用示例"><a href="#优先级队列使用示例" class="headerlink" title="优先级队列使用示例"></a>优先级队列使用示例</h3><h4 id="一、队列保存-基本数据类型的包装类"><a href="#一、队列保存-基本数据类型的包装类" class="headerlink" title="一、队列保存 基本数据类型的包装类"></a>一、队列保存 基本数据类型的包装类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认为升序排列</span></span><br><span class="line">    Queue&lt;Integer&gt; qAsc = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    qAsc.add(<span class="number">3</span>);</span><br><span class="line">    qAsc.add(<span class="number">2</span>);</span><br><span class="line">    qAsc.add(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">while</span> (!qAsc.isEmpty()) &#123;</span><br><span class="line">        System.out.println(qAsc.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义比较器，降序排列</span></span><br><span class="line">    Queue&lt;Integer&gt; qDesc = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将比较器写进优先级队列中</span></span><br><span class="line">    Queue&lt;Integer&gt; qDesc1 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> b - a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    qDesc.add(<span class="number">3</span>);</span><br><span class="line">    qDesc.add(<span class="number">2</span>);</span><br><span class="line">    qDesc.add(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">while</span> (!qDesc.isEmpty()) &#123;</span><br><span class="line">        System.out.println(qDesc.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的比较器</span></span><br><span class="line"><span class="keyword">static</span> Comparator&lt;Integer&gt; cmp = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b - a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二、队列保存-自定义的类"><a href="#二、队列保存-自定义的类" class="headerlink" title="二、队列保存 自定义的类"></a>二、队列保存 自定义的类</h4><p>自定义的类，没有默认的比较器，所以<strong>一定要自己实现比较器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Queue&lt;Rectangle&gt; qAsc = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Rectangle&gt;(cmp);</span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rectangle_1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rectangle_2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rectangle_3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rectangle_4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">        qAsc.add(rectangle_1);</span><br><span class="line">        qAsc.add(rectangle_2);</span><br><span class="line">        qAsc.add(rectangle_3);</span><br><span class="line">        qAsc.add(rectangle_4);</span><br><span class="line">        Rectangle output;</span><br><span class="line">        <span class="keyword">while</span> (!qAsc.isEmpty()) &#123;</span><br><span class="line">            output = qAsc.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;长：&quot;</span> + output.x + <span class="string">&quot;宽：&quot;</span> + output.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的比较器，比较矩形的面积</span></span><br><span class="line">    <span class="keyword">static</span> Comparator&lt;Rectangle&gt; cmp = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Rectangle&gt;() &#123;</span><br><span class="line"><span class="comment">//        // 升序比较器</span></span><br><span class="line"><span class="comment">//        public int compare(Rectangle a, Rectangle b) &#123;</span></span><br><span class="line"><span class="comment">//            return a.x * a.y - b.x * b.y;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">// 降序比较器</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Rectangle a, Rectangle b)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> b.x * b.y-a.x * a.y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的类，矩形类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 表示矩形的长</span></span><br><span class="line">    <span class="type">int</span> y; <span class="comment">// 表示矩形的宽</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、优先队列遍历"><a href="#三、优先队列遍历" class="headerlink" title="三、优先队列遍历"></a>三、优先队列遍历</h4><p>PriorityQueue的<code>iterator()</code>不保证以任何特定顺序遍历队列元素，<strong>若想按特定顺序遍历，先将队列转成数组，然后排序遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器遍历</span></span><br><span class="line">Iterator&lt;Rectangle&gt; it = qAsc.iterator();</span><br><span class="line">Rectangle output;</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    output = it.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;长：&quot;</span> + output.x + <span class="string">&quot;宽：&quot;</span> + output.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为数组</span></span><br><span class="line">Object[] array = qAsc.toArray(); <span class="comment">// 注意是Object类型的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">output</span> <span class="operator">=</span> (Rectangle) array[i]; <span class="comment">// 因为是Object类型，需要强制转换一次</span></span><br><span class="line">    System.out.println(<span class="string">&quot;长：&quot;</span> + output.x + <span class="string">&quot;宽：&quot;</span> + output.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、升降序比较器定义"><a href="#四、升降序比较器定义" class="headerlink" title="四、升降序比较器定义"></a>四、升降序比较器定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Object&gt; cmp = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Object&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="comment">//升序</span></span><br><span class="line">        <span class="keyword">return</span> o1-o2; <span class="comment">// 此处升序 or 降序的原理，见下图</span></span><br><span class="line">        <span class="comment">//降序</span></span><br><span class="line">        <span class="keyword">return</span> o2-o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-26-Comparator01.jpg" alt="2024-7-26-Comparator01"></p><h3 id="用优先级队列实现大小顶堆"><a href="#用优先级队列实现大小顶堆" class="headerlink" title="用优先级队列实现大小顶堆"></a>用优先级队列实现大小顶堆</h3><p>PriorityQueue 默认是小根堆，大根堆需要重写比较器。对与大根堆，就要借助于comparator比较器，来实现大根堆。</p><h4 id="小顶堆（默认就是）"><a href="#小顶堆（默认就是）" class="headerlink" title="小顶堆（默认就是）"></a>小顶堆（默认就是）</h4><h4 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; bigHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2 - o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024-7-23-刷题日记（大小顶堆）</title>
      <link href="/2024/07/23/2024-7-23-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/07/23/2024-7-23-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="大小顶堆"><a href="#大小顶堆" class="headerlink" title="大小顶堆"></a>大小顶堆</h3><blockquote><p>源自于leetcode的一道题——<a href="https://leetcode.cn/problems/top-k-frequent-elements/">前 k个高频元素</a></p><p>题目描述：<strong>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 任意顺序返回答案</strong>。</p><p>示例：</p><p>​输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>​输出: [1,2]</p><p>附加条件：要求算法的时间复杂度 <strong>必须</strong> 优于 O(n log n)，其中 <code>n</code> 是数组大小。</p></blockquote><span id="more"></span><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>首先阅读题目，本题的解题流程如下：</p><ol><li>对数组进行统计——每个数字有多少个</li><li>对统计结果进行排序</li></ol><p>首先第一步统计比较简单，用map就OK——key对应数字的大小，value对应该数字的个数。</p><p>第二步就比较困难了，题目明确了算法的时间复杂度优于 O(n log n)，这就导致了常规的排序算法最多只能用快排（时间复杂度正好是nlogn），所以常规的排序算法是不能用的。</p><p>另外，也没必要对每个书都进行排序，题目只要出现频率最高的前k个元素。</p><p>于是就使用 <strong>堆</strong> or <strong>优先级队列</strong></p><h4 id="堆-优先级队列"><a href="#堆-优先级队列" class="headerlink" title="堆 &amp; 优先级队列"></a><a href="http://yhy1031.cn/2024/07/23/Java%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/">堆 &amp; 优先级队列</a></h4><p>什么是堆？</p><p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。——大顶堆，堆头是最大的元素；小顶堆，堆头是最小的元素</p><p>所以堆十分合适去解决TopK，之类的问题。</p><p>什么是优先级队列呢？</p><p>其实<strong>就是一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是<strong>从队头取元素，从队尾添加元素</strong>，再无其他取元素的方式，看起来就是一个队列。</p><p>而且优先级队列内部元素是自动依照元素的权值排列（在<strong>缺省比较器</strong>的情况下，默认使用小顶堆对元素进行排序）。</p><p>所以，<strong>如果不想自己实现一个大顶堆，就可以用优先级队列</strong></p><h4 id="本题应用"><a href="#本题应用" class="headerlink" title="本题应用"></a>本题应用</h4><p>本人比较懒，所以肯定是用优先级队列来作为堆来用。</p><p>但是，需要思考：用<strong>大顶堆还是小顶堆</strong>呢？</p><p>根据之前对于优先级队列&#x2F;小顶堆，的理解——小顶堆，每次<code>poll</code>时，出队的为最小的元素；大顶堆，每次<code>poll</code>时，出队的为最小的元素</p><p>而本题，<strong>想要留下最大的几个元素，所以需要让更小的值出队，留下大值——所以用小顶堆</strong></p><p><strong>代码如下</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> map.get(a) - map.get(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> it.next().getKey();</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &lt; k) &#123;</span><br><span class="line">                queue.add(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.add(key);</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ans[i] = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题总结 </tag>
            
            <tag> 算法题方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM02：GC与内存分配策略</title>
      <link href="/2024/07/21/JVM02/"/>
      <url>/2024/07/21/JVM02/</url>
      
        <content type="html"><![CDATA[<h3 id="Java中对象的引用"><a href="#Java中对象的引用" class="headerlink" title="Java中对象的引用"></a>Java中对象的引用</h3><p>上节了解到，Java中对象是放在Java堆中的，所以无论是对象访问的定位，还是对象是否可以被回收的判断，都需要引用（HotSpot中的就通过直接引用来访问java对象的）</p><p><strong>直接引用：指针直接指向对象实例的</strong>（如果要访问对象的类型信息——储存在方法区中，则调用由对象维护在对象头中的类型数据指针）</p><p>Java中，引用类型的强弱会决定对象是否能被垃圾回收，主要分成四种，强度递减分别是：<strong>强软弱虚</strong></p><p>（明确一个概念） <code>Object obj=new Object()</code> 中，obj是对象的引用，不是对象</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p><strong>最常见的引用类型</strong></p><p>如 <code>Object obj=new Object()</code> 这种<strong>new产生的引用就是强引用</strong>（String的也是强引用，字符串有一个字符串常量池）；<strong>如果一个对象还有强引用，那么GC就一定不会回收它</strong></p><p>用于表示对象的一般状态。</p><span id="more"></span><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p><strong>SoftReference</strong>&lt;软引用对象的类&gt; name &#x3D; new SoftReference&lt;软引用对象的类&gt;(软引用对象)</p><p><strong>软引用来表示对象是有用的，但不是必须的。</strong></p><p>如果一个对象<strong>只有软引用</strong>了，那么<strong>当内存不足</strong>，准备<strong>抛出内存溢出异常以前，会先把这些软引用的对象进行回收了</strong>，如果回收之后内存还是不够，这时才实际抛出内存溢出异常。</p><p>如下为软引用使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Obj</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Obj</span>();</span><br><span class="line">        SoftReference&lt;Obj&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Obj&gt;(obj);</span><br><span class="line">        System.out.println(softReference.get().getObjName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">    String objName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Obj</span><span class="params">()</span> &#123;</span><br><span class="line">        objName = <span class="string">&quot;软引用测试&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getObjName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> objName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p><strong>WeekReference</strong>&lt;弱引用对象的类&gt; name &#x3D; new WeekReference&lt;弱引用对象的类&gt;(弱引用对象)</p><p>仅有弱引用来引用这个对象时，<strong>垃圾回收时，不论内存是否充足，都会回收弱引用对象（活不过下一次gc）</strong></p><p><strong>可以配合引用队列来释放自身——对象缓存</strong></p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    WeakReference&lt;String&gt; test = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">    System.out.println(test.get());</span><br><span class="line">    System.gc();</span><br><span class="line">    System.out.println(test.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">test</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p><strong>PhantomReference</strong>&lt;虚引用对象的类&gt; name &#x3D; new PhantomReference&lt;虚引用对象的类&gt;(虚引用对象)</p><p>无法从虚引用获取一个对象实例。必须配合引用队列来使用，当这个虚引用对象被回收时可以收到一个系统通知</p><h3 id="可达性分析算法——回收谁"><a href="#可达性分析算法——回收谁" class="headerlink" title="可达性分析算法——回收谁"></a>可达性分析算法——回收谁</h3><p><strong>GC</strong> <strong>Roots：</strong>根对象，如虚拟机栈中引用的对象、方法区中类静态属性引用的对象、常量引用的对象等</p><p><strong>不可达定义：某个对象到</strong> <strong>GC</strong> <strong>Roots 间没有任何引用链相连</strong>，即 GC Roots 到这个对象不可达，则证明此对象是不可能再被使用的（软引用会被认为是不可达哦~）</p><p><strong>引用链</strong>：（<strong>根据引用关系构成的链条</strong>）从GC Roots（根对象）作为起始节点集，从这些节点开始根据引用关系向下搜索，搜索过程所走过的路径称为，引用链</p><p>可达性算法分析的这个过程——<strong>GC Roots Tracing</strong></p><h3 id="垃圾回收算法——怎么回收"><a href="#垃圾回收算法——怎么回收" class="headerlink" title="垃圾回收算法——怎么回收"></a>垃圾回收算法——怎么回收</h3><p><strong>这里的“存活”就是可达！</strong></p><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p><strong>先找出所有对象，将存活的对象进行标记，然后清理掉未标记的对象，结束</strong></p><p>问题：<strong>存在内存碎片</strong></p><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-21-JVM02P1.png" alt="2024-7-21-JVM02P1"></p><h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p><strong>将可用内存分成大小相等的两块，每次只使用其中的一块，当使用的这块空间用完了，就将存活对象复制到另一块，再把已使用过的内存空间一次清理掉</strong></p><p>优点：<strong>解决内存碎片问题</strong></p><p>问题：<strong>但是如果是老年代，则会有大量的存活对象，导致移动很多</strong>（所以一般是新生代使用这个算法）</p><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-21-JVM02P2.PNG" alt="2024-7-21-JVM02P2"></p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p><strong>先找出所有对象，将存活的对象进行标记，再将存活对象整理到一端，最后把其他内存区域直接清理掉</strong></p><p>优点：<strong>解决标记-复制中，对象存活率高时复制操作过多、效率低的问题</strong></p><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-21-JVM02P3.PNG" alt="2024-7-21-JVM02P3"></p><h4 id="分代收集算法（和之后的垃圾收集器关联较大）"><a href="#分代收集算法（和之后的垃圾收集器关联较大）" class="headerlink" title="分代收集算法（和之后的垃圾收集器关联较大）"></a>分代收集算法（和之后的垃圾收集器关联较大）</h4><p>分代收集算法，它<strong>根据对象存活周期将内存划分为几块，不同块采用适当的收集算法</strong>。</p><p>一般将堆分为<strong>新生代</strong>和<strong>老年代</strong>，<strong>新生代每次垃圾收集时都发现有大批对象死去</strong>，而每次<strong>回收后存活的少量对象，将会逐步晋升到老年代中存放</strong></p><ul><li><strong>新生代</strong>：<ul><li>绝大多数对象都是朝生夕灭的——<strong>新生代每次垃圾收集时都发现有大批对象死去</strong></li><li><strong>标记-复制</strong>（避免了标记-复制的缺点）</li></ul></li><li><strong>老年代</strong>：<ul><li>“大多数”是熬过越多次垃圾收集过程的对象。（在标记-复制中的Survivor中存活多代）</li><li><strong>标记-清除</strong> 或者 <strong>标记-整理</strong></li></ul></li></ul><h3 id="垃圾收集器——用什么回收"><a href="#垃圾收集器——用什么回收" class="headerlink" title="垃圾收集器——用什么回收"></a>垃圾收集器——用什么回收</h3><p>下图为常用的HotSpot的垃圾收集器，以及彼此使用的搭配（连线）<strong>CMS和G1是重点</strong></p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-21-JVM02P4.PNG" alt="2024-7-21-JVM02P4" style="zoom:80%;" /><h4 id="一些比较普通的"><a href="#一些比较普通的" class="headerlink" title="一些比较普通的"></a>一些比较普通的</h4><h5 id="新生代："><a href="#新生代：" class="headerlink" title="新生代："></a>新生代：</h5><ol><li><p><strong>Serial 收集器</strong></p><p><strong>串行</strong>，执行时会暂停其他线程——“<strong>Stop The World</strong>”</p><p>客户端模式下默认的新生代收集器</p></li><li><p><strong>ParNew 收集器</strong></p><p>Serial 的<strong>多线程并行版本</strong></p><p>是Server模式下的虚拟机首先新生代收集器</p><p>只有ParNew可以配合CMS收集器工作</p></li><li><p><strong>Parallel Scavenge 收集器</strong></p><p>吞吐量优先收集器</p></li></ol><h5 id="老年代："><a href="#老年代：" class="headerlink" title="老年代："></a>老年代：</h5><ol><li><p><strong>Serial Old收集器</strong></p><p>使用<strong>标记-整理</strong>算法</p><p>Serial的老年代版本</p></li><li><p><strong>Parallel Old收集器</strong></p><p>标记-整理算法</p><p>吞吐量优先收集器</p><p>Parallel Scavenge的老年代版本</p></li></ol><h4 id="CMS收集器——Concurrent-Mark-Sweep（老年代收集器）"><a href="#CMS收集器——Concurrent-Mark-Sweep（老年代收集器）" class="headerlink" title="CMS收集器——Concurrent Mark Sweep（老年代收集器）"></a>CMS收集器——Concurrent Mark Sweep（老年代收集器）</h4><p><strong>追求最短停顿时间</strong></p><p>CMS收集器执行流程如下：</p><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-21-JVM02P5.png" alt="2024-7-21-JVM02P5"></p><ul><li><strong>初始标记</strong>：仅仅只是标记一下 GC Roots 能直接关联到的对象（其实就是找到根对象本身），速度很快，但是需要“<strong>Stop The World</strong>”</li><li><strong>并发标记</strong>：进行 GC Roots Tracing（可达性分析） 的过程，<strong>整个回收过程中耗时最长</strong>，<strong>但并发执行</strong></li><li><strong>重新标记</strong>：修正并发标记期间，因为用户程序继续运作而导致产生变动的那一部分对象的标记记录，<strong>需要“Stop The World”</strong>，比1时间长，比2时间短</li><li><strong>并发清除</strong>：清除掉判定为死亡的对象，可以并发</li></ul><p>优点：<strong>并发收集，低停顿</strong></p><p><strong>缺点：</strong></p><ul><li><strong>吞吐量低</strong>：因为追求最短停顿时间，所以并发的时间会更长——整体运行时间会更长——吞吐量低</li><li><strong>“浮动垃圾”问题</strong>：<strong>并发清除阶段，因为是并发的，会产生新的垃圾</strong>；因此需要预留空间来存储这一部分垃圾——<strong>提前进行垃圾收集</strong>，不能等快满的时候；出现问题用Serial Old替代</li><li><strong>标记-清除算法</strong>的内存碎片问题（为了并发标记，所以使用了标记-清除算法——不用移动对象）</li></ul><h4 id="G1-收集器——Garbage-First（新生代和老年代通用）"><a href="#G1-收集器——Garbage-First（新生代和老年代通用）" class="headerlink" title="G1 收集器——Garbage First（新生代和老年代通用）"></a>G1 收集器——Garbage First（新生代和老年代通用）</h4><p><strong>垃圾优先</strong>，哪一块的垃圾最多就优先清理它——G1<strong>会对不同区块的内存进行回收价值和成本排序</strong>（G1 是JDK9 之后，服务端的默认垃圾收集器）</p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-21-JVM02P6.png" alt="2024-7-21-JVM02P6" style="zoom: 67%;" /><p><strong>G1 分配出了一个个大小固定的Region</strong>，每一个Region都可以是新生代or老年代，Region是垃圾收集的最小单元，每次回收都会是Region的整数倍，如上图所示（从此处也可以看出来，JVM堆内存的结构分配取决于使用了哪种垃圾处理器）</p><ul><li>所有的 Eden 区和 Survivor 区合起来就是新生代，所有的 Old 区拼在一起那就是老年代。</li><li><strong>G1每次收集时只会收集部分region</strong>，每次收集时，会先估算每个小块存活对象的总数，<strong>回收时垃圾最多的小块会被优先回收</strong>。</li></ul><p><strong>G1 收集器运作的四个步骤</strong>：</p><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-21-JVM02P7.png" alt="2024-7-21-JVM02P7"></p><ul><li><strong>初始标记</strong>：仅仅标记一下 GC Roots 能直接关联到的对象（其实就是找到根对象本身），需要<strong>STW</strong></li><li><strong>并发标记</strong>：从GC Roots开始进行可达性分析，完成对象图的扫描，判断存活对象和可回收对象。做后再处理下SATB记录的有引用变动的对象（无需停顿）</li><li><strong>最终标记</strong>：<strong>短暂的STW</strong>，用于处理并发阶段结束后仍遗留下来的最后的少量的SATB记录</li><li><strong>筛选回收</strong>：<strong>需要STW</strong>，统计各个Region的回收价值和成本并进行<strong>排序</strong>，再根据用户期望的停顿时间来指定回收计划，将筛选之后的决定清除的Region，<strong>存活对象放到空的Region中，再清除整个旧的Region</strong></li></ul><h3 id="内存分配与回收策略（部分了解）"><a href="#内存分配与回收策略（部分了解）" class="headerlink" title="内存分配与回收策略（部分了解）"></a>内存分配与回收策略（部分了解）</h3><ul><li><p><strong>对象优先在 Eden 区分配：</strong>   </p><p>大多数情况下对象在新生代 Eden 区分配，当 Eden 没有足够空间时将发起一次 Minor GC（新生代 GC）。</p></li><li><p><strong>大对象直接进入老年代：</strong>   </p><ol><li><strong>大对象指需要大量连续内存空间的对象</strong>，典型是很长的字符串或数量庞大的数组。大对象容易导致内存还有不少空间就提前触发垃圾收集以获得足够的连续空间。</li><li>HotSpot 提供了 -XX:PretenureSizeThreshold 参数，大于该值的对象直接在老年代分配，避免在 Eden 和 Survivor 间来回复制。</li></ol></li><li><p><strong>长期存活对象进入老年代：</strong></p><p>虚拟机给每个对象定义了一个对象年龄计数器，存储在对象头。如果经历过第一次 Minor GC 仍然存活且能被 Survivor 容纳，该对象就会被移动到 Survivor 中并将年龄设置为 1。对象在 Survivor 中每熬过一次 Minor GC 年龄就加 1 ，当增加到一定程度（默认15）就会被晋升到老年代。对象晋升老年代的阈值可通过 -XX:MaxTenuringThreshold 设置。       </p></li><li><p><strong>动态对象年龄判定：</strong></p><p>为了适应不同内存状况，虚拟机不要求对象年龄达到阈值才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 的一半，年龄不小于该年龄的对象就可以直接进入老年代。       </p></li><li><p><strong>空间分配担保：</strong></p><ol><li>MinorGC 前虚拟机必须检查老年代最大可用连续空间是否大于新生代对象总空间，如果满足则说明这次 Minor GC 确定安全。</li><li>如果不满足，虚拟机会查看 -XX:HandlePromotionFailure 参数是否允许担保失败，如果允许会继续检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小，如果满足将冒险尝试一次 Minor GC，否则改成一次 FullGC。</li><li>冒险是因为新生代使用复制算法，为了内存利用率只使用一个 Survivor，大量对象在 Minor GC 后仍然存活时，需要老年代进行分配担保，接收 Survivor 无法容纳的对象。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024-7-21-刷题日记（单调队列）</title>
      <link href="/2024/07/21/2024-7-21-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/07/21/2024-7-21-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>目前就在这一道题中见过：<a href="https://leetcode.cn/problems/sliding-window-maximum/"><strong>滑动窗口最大值</strong></a></p><blockquote><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p></blockquote><p>输入输出样例：</p><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-21-T1P1.png" alt="2024-7-21-T1P1"></p><span id="more"></span><h3 id="本人之前的思路："><a href="#本人之前的思路：" class="headerlink" title="本人之前的思路："></a>本人之前的思路：</h3><p>本来我想的是使用队列，但是整个流程中需要频繁的进队出队。。。。又太麻烦了，于是想到用<strong>双指针代替：只要窗口滑动，左右指针就向右移动一下</strong></p><p>每次判断最大的时候，如果进来的元素 ＜ 上一个窗口的最大，且出去的元素也不是上一个窗口最大，证明当前窗口和上一个窗口最大值一样。。。</p><p><strong>但是</strong>，整体的算法时间复杂度为O((n-k)n)我的代码在第47个用例时间超限</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ansLength</span> <span class="operator">=</span> nums.length - k + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[ansLength];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> k - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 所以第一个窗口就是0~k-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ansLength; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[left - <span class="number">1</span>] &lt; ans[i - <span class="number">1</span>] &amp;&amp; nums[right] &lt; ans[i - <span class="number">1</span>])</span><br><span class="line">                ans[i] = ans[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans[i] = findMax(nums, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findMax</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> newArray[] = Arrays.copyOfRange(nums, left, right + <span class="number">1</span>);</span><br><span class="line">        Arrays.sort(newArray);</span><br><span class="line">        <span class="keyword">return</span> newArray[right-left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列方法："><a href="#单调队列方法：" class="headerlink" title="单调队列方法："></a>单调队列方法：</h3><p><strong>单调队列：（本题是单调递减队列）保证队列整体是递减的，使得队头元素是当前队列最大的元素之一</strong>，因为要频繁的peek队头和队尾，所以使用双向队列更为合适</p><p><strong>单调队列入队规则</strong>：使用队列，每个元素入队的前，判断一下前一个元素是不是比自己大，</p><ul><li>如果比自己大，则直接入队（已经满足递减了）；</li><li><strong>如果比自己小，则可以把前一个元素移除了，再比较新的前一个元素，直到比自己大 或者 队空 再入队</strong>（很关键）</li></ul><h4 id="为什么要移除？"><a href="#为什么要移除？" class="headerlink" title="为什么要移除？"></a>为什么要移除？</h4><p>因为，前面的元素比自己大，它如果不走，就永远轮不到我（我是指前一个元素）；所以我在这个队列中，等前面比我大的元素都走了，一定会轮到我的；（这是正常单调的情况下）</p><p>但是，现在后面来了一个比我大的元素，<strong>它活的比我长（指的是后被窗口滑动走，在滑动窗口中待的时间更长）</strong>，<strong>还比我大（会先被当做最大的被选用）</strong>；那我一辈子也不可能被选中，还不如走了算了（所以直接移除前面的小元素）</p><h4 id="流程示意："><a href="#流程示意：" class="headerlink" title="流程示意："></a>流程示意：</h4><p>就拿 <code>nums = [1,3,-1,-3,5,3,6,7], k = 3</code> 这个举例</p><ul><li><p>形成单调队列时</p><ul><li>1 准备入队，队空，1入队</li><li>3 准备入队，但是<strong>1&lt;3，则1出队，3入队</strong>；</li><li>-1 准备入队，3&gt;-1，则-1入队</li></ul><p>此时单调队列形成包括 3 和 -1</p></li><li><p>之后的滑动过程如下：</p><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-21-T1P2.png" alt="2024-7-21-T1P2"></p></li></ul><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ansLength</span> <span class="operator">=</span> nums.length - k + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[ansLength];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 形成窗口前，构建单调队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i]) &#123;</span><br><span class="line">                <span class="comment">// 后面的比前面的大，证明永远用不到前面小的数，所以直接移除就行了</span></span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时形成窗口了</span></span><br><span class="line">        ans[<span class="number">0</span>] = deque.peekFirst();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始滑动了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 让队头元素该走的时候就走，nums[i - k]表示窗口左侧，马上要离开窗口</span></span><br><span class="line">            <span class="keyword">if</span> (deque.peekFirst() == nums[i - k]) &#123;</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i]) &#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(nums[i]);</span><br><span class="line">            ans[i - k + <span class="number">1</span>] = deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题总结 </tag>
            
            <tag> 算法题方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM01：Java内存区域</title>
      <link href="/2024/07/19/JVM01/"/>
      <url>/2024/07/19/JVM01/</url>
      
        <content type="html"><![CDATA[<p><strong>JVM管理的内存——运行时数据区</strong></p><p><strong>java程序的内存——运行时数据区（JVM内存）+本地内存</strong></p><p><strong>本地内存——元空间 + 直接内存</strong></p><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>运行时数据区包括：程序计数器、虚拟机栈、本地方法栈、Java堆、方法区</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>可以看作：当前线程所执行的字节码（class文件）的<strong>行号指示器</strong>，通过标示下一条需要执行的字节码指令（对应的地址）完成指令切换，以此来推动线程的运行</p><p><strong>特点：</strong></p><ul><li><strong>内存占用小</strong>，且是<strong>运行速度最快</strong>的存储区域</li><li><strong>每个线程都有自己的程序计数器</strong>，是<strong>线程私有</strong>的，生命周期和线程一致</li><li>是程序控制流的指示器，</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条要执行的字节码。</li><li>任何时间一个线程都只会有一个方法在执行，也就是<strong>当前方法</strong>。如果当前方法是<strong>Java方法</strong>，则程序计数器记录的是<strong>对应方法的JVM字节码指令地址</strong>；如果是<strong>native方法</strong>，则是<strong>未指定值（undefined）</strong></li><li>JVM中唯一没有规定任何<code>OutOfMemoryError</code>情况的区域</li></ul><span id="more"></span><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>每个线程在创建时都会创建一个虚拟机栈，用于记录线程所执行的方法，<strong>每一个Java方法对应的是一个栈帧</strong>，每当<strong>调用一个新方法</strong>时，就会<strong>构建一个栈帧并压栈</strong>；而一个<strong>方法执行结束</strong>时，就会有一个<strong>栈帧出栈</strong>（所以是LIFO，非常合理）。所以当前执行的方法，就对应着栈顶的栈帧，且只有这一个活动的栈帧。</p><p>栈帧中存储的内容：局部变量表、操作数栈、动态连接、方法出口等信息</p><p><strong>特点：</strong></p><ul><li>线程私有，生命周期和线程一致</li><li>当前正在执行的方法为<strong>当前栈帧</strong></li><li>异常情况：<ul><li>线程请求的栈深度大于虚拟机所允许的深度，则抛出<code>StackOverflowError</code></li><li>如果Java虚拟机栈容量可动态扩展，当栈扩展时无法申请到足够的内存，会抛出<code>OutOfMemoryError</code></li></ul></li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>为执行 Native Method方法服务（虚拟机栈为 Java方法&#x2F;字节码 服务），和虚拟机栈非常类似</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆是<strong>被所有线程共享的一块内存区域</strong>，<strong>“几乎”所有的对象实例都在这里分配内存</strong>（如基本数据类型、final static修饰的静态对象在方法区中）。</p><p>Java堆也是垃圾收集器GC管理的内存区域。</p><p>Java堆的大小和扩展范围主要通过 <code>-Xmx</code> 和 <code>-Xms</code>控制，而如果如果堆中没有内存完成实例分配，并且堆无法再扩展时，就会抛出 <code>OutOfMemoryError</code> 异常（同上）。且 Java 堆<strong>可以是处于物理上不连续的内存空间</strong>中，只要逻辑上是连续的即可</p><h3 id="方法区-元数据区"><a href="#方法区-元数据区" class="headerlink" title="方法区\元数据区"></a>方法区\元数据区</h3><p>方法区，和Java堆一样，是各个<strong>线程共享</strong>的内存区域，且，它<strong>用于存储已被虚拟机加载的类信息、常量、静态变量</strong>。JVM 关闭后方法区即被释放。</p><p>如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出<code>OutOfMemoryError</code> 错误。同样和Java堆一样，不需要连续的内存并且可以选择固定大小或者可扩展。</p><p><strong>针对方法区，Java8做了改进</strong></p><ul><li><strong>方法区的落地实现：Java7是永久代，Java8元空间</strong>（只存储类的元信息，如类型、字段、方法信息、运行时常量等；将静态变量、字符串常量池等并入到Java堆中）</li><li><strong>永久代中的class metadata</strong>（上面提到的类的元信息，如类型、字段、方法信息、运行时常量等）<strong>转移到native memory</strong>（本地内存中，也就是元空间在本地内存）</li><li><strong>永久代中的interned Strings 和 class static variables</strong> （字符串常量池，静态变量）<strong>转移到java堆中</strong></li><li><strong>参数设置</strong>由 PermSize &amp; MaxPermSize 改为 MetaspaceSize 和 MaxMetaspaceSize</li></ul><h4 id="运行时常量池——Runtime-Constant-Pool（方法区的一部分）"><a href="#运行时常量池——Runtime-Constant-Pool（方法区的一部分）" class="headerlink" title="运行时常量池——Runtime Constant Pool（方法区的一部分）"></a>运行时常量池——Runtime Constant Pool（方法区的一部分）</h4><p>用于存放class文件中的常量池表（其中有编译器生成的各种<strong>字面量和符号引用</strong>，字面量：编译时，对数据的一种表示）。</p><p>每个已经加载的类型（类or接口）都维护一个运行时常量池，当这些类型加载到虚拟机后创建。</p><p>超出大小范围：报错<code>OutOfMemoryError</code></p><h2 id="本地内存和直接内存"><a href="#本地内存和直接内存" class="headerlink" title="本地内存和直接内存"></a>本地内存和直接内存</h2><h3 id="本地内存"><a href="#本地内存" class="headerlink" title="本地内存"></a>本地内存</h3><p>不在JVM运行时数据区中，也不是JVM规范定义的内存区域，受本机物理内存限制。</p><p><strong>Java8将元数据区（之前的方法区）从JVM的运行时数据区，转移到了本地内存中。</strong></p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>和Native堆相关的内存，用于提高Java堆和Native堆交互的性能。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring核心知识02：Spring IoC</title>
      <link href="/2024/07/19/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8602/"/>
      <url>/2024/07/19/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8602/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>IoC 即控制反转</strong>（Inversion of Control）</p><p>IoC又称为依赖倒置原则：<strong>程序要依赖于抽象接口，不要依赖于具体实现——降低代码之间的耦合度</strong></p><p>IoC是一种思想，主要解决程序设计中的对象依赖关系管理问题。在IoC思想中，对象的创建权反转给第三方容器，由容器进行对象的创建及依赖关系的管理。</p></blockquote><p>IoC 容器，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合。</p><h3 id="IoC的实现方式"><a href="#IoC的实现方式" class="headerlink" title="IoC的实现方式"></a>IoC的实现方式</h3><ul><li><strong>依赖注入（DI）</strong>：<strong>不通过<code>new()</code>的方式在类的内部创建依赖类的对象</strong>，而是<strong>将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递&#x2F;注入给类内部使用</strong>。</li><li>依赖查找：容器中的受控对象通过容器的API来查找自己所依赖的资源和协作对象。</li></ul><blockquote><p>此处，如果问到 IoC和 DI 的区别——IoC是设计思想，DI是IoC思想的具体实现之一</p></blockquote><h3 id="如何理解IoC中的-I-和-C"><a href="#如何理解IoC中的-I-和-C" class="headerlink" title="如何理解IoC中的 I 和 C"></a>如何理解IoC中的 I 和 C</h3><ul><li><p>C-控制，<strong>谁控制谁？控制什么？</strong></p><p><strong>传统方式</strong>，我们是直接在对象内部通过new进行创建对象，<strong>是程序主动去创建依赖对象的</strong>；而IoC中有一个专门的容器来创建这些对象，即由<strong>IoC容器来控制对象的创建</strong>；</p><p>因此，控制就指的是<strong>IoC容器控制对象</strong>；<strong>控制了外部资源获取</strong></p></li><li><p>I-反转，<strong>为什么反转？哪方面反转了？</strong></p><p>传统应用程序中，是由我们自己在对象中主动控制去直接获取依赖对象，是正转；而<strong>反转则是由IoC容器来帮忙创建及注入依赖对象。（此时被注入的对象只是被动的接收依赖对象）</strong>，这就是反转，<strong>依赖对象的获取被反转了</strong>。</p></li></ul><span id="more"></span><h3 id="理解DI中的-D-和-I"><a href="#理解DI中的-D-和-I" class="headerlink" title="理解DI中的 D 和 I"></a><a href="http://yhy1031.cn/2024/07/28/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8603/">理解DI中的 D 和 I</a></h3><ul><li><p>D-依赖，<strong>谁依赖谁</strong>？</p><p>Spring项目中，将对象理解为Bean，也可以叫Bean对象，这个Bean和容器之间有个依赖关系，<strong>Bean对象的创建是依赖容器的</strong></p></li><li><p>I-注入，<strong>谁注入谁</strong>？</p><p><strong>通过容器注入Bean对象</strong>，<strong>容器会自动找到和Bean对象匹配的类型示例注入到对象中</strong></p></li></ul><h2 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h2><p>IoC容器就是具有依赖注入功能的容器。</p><p><strong>IoC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</strong>应用程序无需直接在代码中 new 相关的对象，应用程序由 IoC 容器进行组装。</p><p>在 Spring 中，有两种IoC容器： <strong>BeanFactory</strong> 和 <strong>ApplicationContext</strong></p><ul><li><strong>BeanFactory</strong>：是 Spring 基础的 IoC 容器。提供了 Spring 容器的配置框架和基本功能。</li><li><strong>ApplicationContext</strong>（<strong>推荐使用</strong>）：是具有应用特性的 <strong>BeanFactory</strong> 的子接口。它提供了更丰富的功能，如：国际化、访问资源、事件机制等等。</li></ul><p>PS：BeanFactory和FactoryBean的区别：</p><p><strong><code>BeanFactory</code><strong>：不是指根接口，而是bean对象创建的整体流程，Bean的生命周期是一个完整的标准化的流程，相对比很麻烦——</strong>属于是流水线式的工作</strong></p><p><strong><code>FactoryBean</code><strong>——用来创建Bean对象——</strong>私人定制</strong></p><p>包含三个方法：</p><ol><li><code>isSingleton</code>：判断是否为单例对象</li><li><code>getObjectType</code>：获取返回对象的类型（.class）</li><li><code>getObject</code>：创建独享</li></ol><p><code>org.springframework.context.ApplicationContext</code> 接口代表Spring IoC容器，负责实例化、配置和组装 bean。</p><h3 id="Spring-IoC的加载过程"><a href="#Spring-IoC的加载过程" class="headerlink" title="Spring IoC的加载过程"></a>Spring IoC的加载过程</h3><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-28-IOCP01New.png" alt="2024-7-28-IOCP01New"></p><p>XML、YML、properties为配置文件的几种格式</p><p><strong>BeanDefinitionReader 读取指定的配置文件生成bean的定义信息</strong>，得到完整的bean定义信息（<strong>BeanDefinition对象，只是存储bean的定义信息</strong>，还没有实例化bean对象）</p><p>得到完整的BeanDefinition对象之前（在 <code>BeanDefinition</code> 和 完整<code>BeanDefinition</code> 中间），通过一个后置增强器——PostProcessor（此处使用的是<strong>BeanFactoryPostProcessor</strong>），<strong>对bean的定义信息进行统一的修改</strong>（如替换填充符）</p><p>得到完整的BeanDefinition对象之后，就可以创建对象（通过反射的方法创建）了，这整个过程被称为 <strong>bean 的生命周期，也就是从实例化、到使用、到销毁的过程</strong></p><h2 id="Spring-Bean-的生命周期"><a href="#Spring-Bean-的生命周期" class="headerlink" title="Spring Bean 的生命周期"></a>Spring Bean 的生命周期</h2><p>根据上图，Bean的生命周期主要分为4个部分：对象实例化、对象初始化、完整对象使用、销毁</p><p>详细的流程图如下：</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-28-IOCP02.jpg" alt="2024-7-28-IOCP02"></p><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p><strong>在堆空间中申请空间</strong>，此时<strong>对象的属性值一般是默认值</strong>——也就是<strong>反射创建对象</strong>——需要调用<code>createBeanInstance</code>方法（其中有反射创建对象的过程）</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>经过实例化创建对象完成后，需要首先进行<strong>属性赋值</strong>（<strong>populateBean</strong>，填充bean对象）</p><p>之后：<strong>检查aware相关接口并设置相关依赖</strong>，</p><h4 id="Aware-接口"><a href="#Aware-接口" class="headerlink" title="Aware 接口"></a>Aware 接口</h4><p>Aware接口没有定义任何一种方法</p><p>其主要的目的——<strong>做标记</strong>，其实就是<strong>实现set方法</strong>，设置属性值——<code>invokeAwareMethods</code></p><p>实现了Aware接口，避免了挨个判断</p><h4 id="Spring中Bean对象按照使用者分为几类："><a href="#Spring中Bean对象按照使用者分为几类：" class="headerlink" title="Spring中Bean对象按照使用者分为几类："></a>Spring中Bean对象按照使用者分为几类：</h4><ol><li>自定义对象（用户使用）</li><li>容器对象（供容器使用，如BeanFactory等）</li></ol><p>Spring中这些对象，如果要新增某些字段，需要使用aware接口实现的类，用于标记这个bean对象。</p><h4 id="初始化扩展"><a href="#初始化扩展" class="headerlink" title="初始化扩展"></a>初始化扩展</h4><p>至此（<strong>属性复制之后）</strong>，其实已经生成了对象（普通对象）了，但是考虑到Spring的扩展性（代理、扩展等）</p><p><strong>执行初始化前置处理方法 &amp; 后置处理方法</strong>——<strong>BeanPostProvcessor</strong>——底层为AOP（原理为动态dialing），作为Bean对象的扩展实现（<strong>AOP是IOC整体流程中的一个扩展点</strong>）</p><p><strong>初始化前置处理方法</strong>：</p><p>基本啥也没干，方法直接返回了bean对象（主要是看实现方法）</p><p><strong>初始化后置处理方法</strong>：</p><p>此处创建了代理，此处就是Spring AOP的入口</p><h4 id="执行初始化方法"><a href="#执行初始化方法" class="headerlink" title="执行初始化方法"></a>执行初始化方法</h4><p>在初始化前置处理方法之后、初始化后置处理方法之后，进行初始化方法——incokeInitMethods</p><p>其中需要检测当前的Bean是否实现了InitializingBean接口</p><p>如果实现了，则调用afterPropertiesSet方法，用来设置属性、调用方法、添加任意的处理逻辑</p><h3 id="使用Bean对象"><a href="#使用Bean对象" class="headerlink" title="使用Bean对象"></a>使用Bean对象</h3><h3 id="销毁Bean对象"><a href="#销毁Bean对象" class="headerlink" title="销毁Bean对象"></a>销毁Bean对象</h3><p>没见过~~</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端初始化模板01——实体类</title>
      <link href="/2024/07/06/%E5%90%8E%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/07/06/%E5%90%8E%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本人的后端初始化模板记录</p></blockquote><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>Serializable接口，实现对象的序列化<br>没有定义任何方法，只是表明该类具有序列化的能力。</p><p><strong>序列化</strong>是将对象的状态转换为字节流的过程，从而可以将对象的状态保存到文件、数据库或通过网络传输。反序列化是将字节流转换回对象的过程。</p><h3 id="TableId注解"><a href="#TableId注解" class="headerlink" title="@TableId注解"></a>@TableId注解</h3><p>实体类中用于标识实体类的主键字段。并可以指定主键的生成策略（<code>IdType</code> 枚举中，定义了多种主键生成策略）：</p><ul><li><code>AUTO</code>：数据库ID自增。</li><li><code>NONE</code>：未设置主键生成策略。</li><li><code>INPUT</code>：手动输入ID。</li><li><code>ID_WORKER</code>：使用分布式全局唯一ID策略（已弃用，推荐使用 <code>ASSIGN_ID</code>）。</li><li><code>UUID</code>：使用UUID。</li><li><code>ASSIGN_ID</code>：使用分布式全局唯一ID策略，适用于主键为 <code>Long</code> 类型。</li><li><code>ASSIGN_UUID</code>：使用UUID，适用于主键为 <code>String</code> 类型。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableId(type = IdType.ASSIGN_ID)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="NotBlank-NotNull等注解"><a href="#NotBlank-NotNull等注解" class="headerlink" title="@NotBlank &amp; @NotNull等注解"></a>@NotBlank &amp; @NotNull等注解</h3><p>validation注解，判断入参是否符合业务要求，提前做判断，不需要在controller 或者 service层进行操作。</p><p>参数 message：在不满足注解要求是报错的内容</p><p>通常用在做为入参的类中使用</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotNull(message = &quot;id不能为空&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotBlank(message = &quot;用户账号不能为空&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String userAccount;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM模式——练习2（浮点数练习）</title>
      <link href="/2024/07/06/ACM%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%BB%83%E4%B9%A02/"/>
      <url>/2024/07/06/ACM%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%BB%83%E4%B9%A02/</url>
      
        <content type="html"><![CDATA[<h3 id="平均绩点"><a href="#平均绩点" class="headerlink" title="平均绩点"></a><a href="https://kamacoder.com/problempage.php?pid=1006">平均绩点</a></h3><p>主要的代码逻辑还是很简单的，但是有一个重点——结果保留两位小数；</p><p>有两种方法：</p><ol><li><p>使用<strong>String.format()方法</strong>，如：<code>String.format(&quot;%.2f&quot;, XXXX);</code>其中，%.2f表示保留两位小数，XXXX为一个浮点数(float or double)</p><p>如%.nf就是保留n位小数</p></li><li><p>使用<strong>DecimalFormat类</strong>，<code>DecimalFormat</code>类的构造参数<code>&quot;0.00&quot;</code>表示保留两位小数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DecimalFormat</span> <span class="variable">decimalFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.00&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">score1</span> <span class="operator">=</span> <span class="number">0.000000</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">formattedScore</span> <span class="operator">=</span> decimalFormat.format(score1);</span><br><span class="line">        System.out.println(formattedScore); <span class="comment">// 输出：0.00</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是要注意，<strong>导入的包为 java.text.DecimalFormat</strong></p></li></ol><p><strong>所以尽量还是用String.format，ju*就可以了</strong></p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// import java.text.DecimalFormat;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            String[] scores = in.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">float</span> <span class="variable">scoreCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isKnown</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (String score : scores) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">                        scoreCount += <span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">                        scoreCount += <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">                        scoreCount += <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;D&quot;</span>:</span><br><span class="line">                        scoreCount += <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;F&quot;</span>:</span><br><span class="line">                        scoreCount += <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        isKnown = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isKnown) &#123;</span><br><span class="line"><span class="comment">//                DecimalFormat decimalFormat = new DecimalFormat(&quot;0.00&quot;);</span></span><br><span class="line"><span class="comment">//                String formattedScore = decimalFormat.format(scoreCount / scores.length);</span></span><br><span class="line"><span class="comment">//                System.out.println(formattedScore);</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">formattedScore</span> <span class="operator">=</span> String.format(<span class="string">&quot;%.2f&quot;</span>, scoreCount / scores.length);</span><br><span class="line">                System.out.println(formattedScore);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring核心知识01：Bean</title>
      <link href="/2024/07/05/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8601/"/>
      <url>/2024/07/05/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8601/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Spring中，构建应用程序主体、由Spring IoC容器管理的对象成为Bean</p><p><strong>Bean是由Spring IoC容器示例化、装配和管理的对象。</strong></p></blockquote><h3 id="什么是Spring-Bean？"><a href="#什么是Spring-Bean？" class="headerlink" title="什么是Spring Bean？"></a>什么是Spring Bean？</h3><p><strong>Bean 代指的就是那些被 IoC 容器所管理的对象。</strong></p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><h3 id="如何用注解将一个类声明成Bean？"><a href="#如何用注解将一个类声明成Bean？" class="headerlink" title="如何用注解将一个类声明成Bean？"></a>如何用注解将一个类声明成Bean？</h3><ul><li><p><code>@Component</code>：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</p></li><li><p><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</p></li><li><p><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p></li><li><p><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 <code>Service</code> 层返回数据给前端页。</p></li></ul><span id="more"></span><h3 id="注入Bean的注解有哪些？（如何用注解注入Bean）"><a href="#注入Bean的注解有哪些？（如何用注解注入Bean）" class="headerlink" title="注入Bean的注解有哪些？（如何用注解注入Bean）"></a>注入Bean的注解有哪些？（如何用注解注入Bean）</h3><ul><li><code>@Autowired</code> Spring内置</li><li><code>@Resource</code> JDK内置</li><li>@<code>Inject</code> JDK内置</li></ul><h3 id="Autowired-和-Resource的区别"><a href="#Autowired-和-Resource的区别" class="headerlink" title="@Autowired  和 @Resource的区别"></a><code>@Autowired</code>  和 <code>@Resource</code>的区别</h3><ul><li><p><code>@Autowired</code> 的默认注入方式为<strong>byType</strong>（根据类型进行匹配）<br><code>@Resource</code> 的默认注入方式为<strong>byName</strong>（根据名称来查找）</p><p>但是两者在面对一个接口有多个实现类的时候，都是束手无策的，常规的方法（如下）是不可行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><p>两者都需要通过具体的名称来匹配对应的Bean：<code>@Autowired</code> 通过 <code>@Qualifier</code>注解显示指定名称；<code>@Resource</code> 可以通过name属性来显示指定名称。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;userServiceImpl&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource(name = &quot;userServiceImpl&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><p>当然更简单的可以：<code>private UserService userServiceImpl;</code></p></li><li><p><code>@Autowired</code> 支持在构造函数、方法、字段和参数上使用。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。（在构造函数 or 方法上使用：）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加@Qualifier注解</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(<span class="meta">@Qualifier(&quot;userDao&quot;)</span> UserDao userDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Bean的作用域有哪些"><a href="#Bean的作用域有哪些" class="headerlink" title="Bean的作用域有哪些"></a>Bean的作用域有哪些</h3><ul><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><p>使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span> <span class="comment">// 任意Bean注解</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON)</span><span class="comment">//配置Bean的作用域</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userServiceImpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发面试题01</title>
      <link href="/2024/07/05/Java%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%9801/"/>
      <url>/2024/07/05/Java%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%9801/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习 Java 并发时的知识点总结</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发笔记08：线程池</title>
      <link href="/2024/07/05/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B008/"/>
      <url>/2024/07/05/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B008/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习Java并发时的知识点总结</p></blockquote><p><strong>线程池</strong>—— 是一种开发框架，是一种基于池化思想管理线程的工具（池化：如数据库的连接池）</p><ul><li>降低资源消耗：重复利用已创建的线程，降低线程创建和销毁造成的消耗</li><li>提高响应速度：任务到达时，可以立即执行，不需要等待线程创建</li><li>提高线程可管理性</li></ul><p>归根结底，线程池的作用：<strong>复用线程</strong></p><h3 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h3> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-5-XCCP1.png" alt="2024-7-5-XCCP1" style="zoom:80%;" /><p>线程池分为<strong>核心线程池</strong>和<strong>非核心线程池</strong>（核心线程池只有核心线程池满了才会复用，否则会创建新线程）</p><span id="more"></span><h4 id="线程池工作流程"><a href="#线程池工作流程" class="headerlink" title="线程池工作流程"></a>线程池工作流程</h4><ol><li><strong>首先会判断核心线程池是否已满</strong>：如果没有满，则直接创建新线程来执行任务。如果已经满了，则进行下一步判断，<strong>尝试将任务放入队列</strong>。</li><li><strong>判断队列是否已经满了</strong>：如果没有满，则任务放入队列，结束。如果队列已经满了，则进行下一步判断。</li><li><strong>判断线程池（核心+非核心）是否已经满</strong>：如果没满，则创建新线程来执行任务。如果已经满了，则按照饱和策略来处理任务。</li></ol><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>Java中线程池的核心实现类是ThreadPoolExecutor类</p><h4 id="线程池参数（7个参数）"><a href="#线程池参数（7个参数）" class="headerlink" title="线程池参数（7个参数）"></a>线程池参数（7个参数）</h4><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-5-XCCP2.png" alt="2024-7-5-XCCP2"></p><ul><li><p><strong>corePoolSize</strong>：核心线程池大小</p></li><li><p><strong>maximumPoolSize</strong>：最大线程数——核心+非核心</p></li><li><p><strong>keepAliveTime</strong>：空闲线程存活时间（<strong>只作用于非核心线程</strong>，核心线程不会回收）</p></li><li><p><strong>unit</strong>：时间单位——keepAliveTime的时间单位</p></li><li><p><strong>workQueue</strong>：阻塞队列，用于保存任务</p><p>具体队列类型可以看之前的阻塞队列</p><ul><li><p>ArrayBlockingQueue</p></li><li><p>LinkedBlockingQueue</p></li><li><p>SynchronousQueue</p></li><li><p>PriorityBlockingQueue</p></li></ul></li><li><p><strong>threadFactory</strong>：创建线程的工厂类</p></li><li><p><strong>handler</strong>：饱和策略（拒绝策略）</p><p>线程和阻塞队列都满了，使用handler处理新来的任务</p><ul><li><p><strong>AbortPolicy</strong>：直接抛出异常（默认）</p></li><li><p>CallerRunPolicy：使用任务提交者的线程运行</p></li><li><p>DiscardOldestPolicy：抛弃最老（最早入队的）的线程，并重试提交当前任务</p></li><li><p>DiscardPolicy：不处理丢弃</p></li></ul></li></ul><h4 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h4><p>如下图所示：</p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-5-XCCP3.png" alt="2024-7-5-XCCP3" style="zoom:67%;" /><p>调用线程池主要是使用ThreadPoolExecutor中的execute方法，下面是几种情况：</p><ol><li><strong>如果当前运行的线程少于corePoolSize-核心线程池大小</strong>，也就是核心线程池未满，则创建新线程来执行任务（此时相当于线程池的预热阶段）</li><li><strong>如果运行的线程等于or多于corePoolSize</strong>，则将任务加入BlockingQueue-等待队列中（等待核心线程池中的有空闲线程）</li><li><strong>如果无法将任务加入到BlockingQueue中（队列满了）</strong>，则创建新线程来处理任务</li><li><strong>如果创建新线程将使得运行的线程超出maximumPoolSize-最大线程数</strong>，则任务将根据handler-饱和策略被拒绝，</li></ol><h4 id="常用的三种ThreadPoolExecutor"><a href="#常用的三种ThreadPoolExecutor" class="headerlink" title="常用的三种ThreadPoolExecutor"></a>常用的三种ThreadPoolExecutor</h4><ol><li><p><strong>FixedThreadPool</strong>——控制最大并发（定义的最大线程数）的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JUC中newFixedThreadPool的源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>corePoolSize和maximumPoolSize在线程池<strong>创建时就被指定</strong>（此处是nThreads），而且<strong>相等——核心线程就是总线程</strong>，也就是最大的并发数</p><p>阻塞队列为<strong>LinkedBlockingQueue</strong>（队列容量为Integer.MAX_VALUE，是无界阻塞队列），所以maximumPoolSize是一个无效参数，被设置成corePoolSize，表示非核心线程池大小为0</p><p><strong>keepAliveTime为0L</strong>，因为没有非核心线程。（更加保证了不会有非核心线程，一旦创建就kill）</p></li><li><p><strong>SingleThreadExecutor</strong>——单线程处理的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JUC中newSingleThreadExecutor的源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SingleThreadExecutor的<strong>corePoolSize和maximumPoolSize被设置为1</strong>。</p><p>其他参数与FixedThreadPool相同（如无界队列LinkedBlockingQueue，keepAliveTime为0L等）</p></li><li><p><strong>CachedThreadPool</strong>——可回收缓存的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JUC中newCachedThreadPool的源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CachedThreadPool的<strong>corePoolSize被设置为0</strong>，即corePool为空；<strong>maximumPoolSize被设置为Integer.MAX_VALUE</strong>，即maximumPool是无界的——并发数无限大，但是每个线程都可以回收</p><p><strong>keepAliveTime设置为60L</strong>，意味着CachedThreadPool中的空闲线程等待新任务的最长时间为60秒，空闲线程超过60秒后将会被终止。</p><p>阻塞队列为SynchronousQueue-不存元素的阻塞队列，相当于没有阻塞队列，因为maximumPool是无界的，所以每个任务都会直接创建or复用线程。（所以可能和消耗大量CPU &amp; 内存资源）</p></li></ol><h4 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h4><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-5-XCCP4.png" alt="2024-7-5-XCCP4"></p><ul><li>NEW </li><li>RUNNING</li><li>SHUTDOWN：不收但是还在执行</li><li>STOP：不受不执行，执行中的会中断</li><li>TIDYING：所有任务都销毁了，workerCount &#x3D; 0，会执行terminated方法</li><li>TERMINATED：</li></ul><p>可以对比一下<a href="http://yhy1031.cn/2024/06/05/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B001/">线程的状态</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM模式——练习1（A+B问题，输入shu&#39;chu）</title>
      <link href="/2024/07/05/ACM%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%BB%83%E4%B9%A01%EF%BC%88A-B%E9%97%AE%E9%A2%98%EF%BC%89/"/>
      <url>/2024/07/05/ACM%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%BB%83%E4%B9%A01%EF%BC%88A-B%E9%97%AE%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从基础入手，开始练习ACM模式算法题</p></blockquote><h3 id="A-B问题I"><a href="#A-B问题I" class="headerlink" title="A+B问题I"></a><a href="https://kamacoder.com/problempage.php?pid=1000">A+B问题I</a></h3><p>。。。就是每次笔试的时候给出的样例，有种马上如临大敌的感觉哈哈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小发现：</p><p>​nextInt()是不会受到“行”的制约的，所以不需要 <code>in.nextLine()</code>来换行</p></blockquote><span id="more"></span><h3 id="A-B问题II"><a href="#A-B问题II" class="headerlink" title="A+B问题II"></a><a href="https://kamacoder.com/problempage.php?pid=1001">A+B问题II</a></h3><p>结题时注意下面这句话，所以需要使用<code>while (in.hasNext())</code>循环处理多组输入的情况</p><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-5-T2P1.png" alt="2024-7-5-T2P1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            in.nextLine(); <span class="comment">//可有可无</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">                System.out.println(a + b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-B问题III"><a href="#A-B问题III" class="headerlink" title="A+B问题III"></a><a href="https://kamacoder.com/problempage.php?pid=1002">A+B问题III</a></h3><p>多了一步对输入进行检验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-B问题IV"><a href="#A-B问题IV" class="headerlink" title="A+B问题IV"></a><a href="https://kamacoder.com/problempage.php?pid=1003">A+B问题IV</a></h3><p>常规解法如下，也可以使用nextLine()+startsWith()等方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                result += in.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-B问题VII"><a href="#A-B问题VII" class="headerlink" title="A+B问题VII"></a><a href="https://kamacoder.com/problempage.php?pid=1004">A+B问题VII</a></h3><p>和T1相比，多输出一行空行。。。。不知道这个出题的是怎么想的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line"><span class="comment">//System.out.println(a + b + &quot;\n&quot;);</span></span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-B问题VIII"><a href="#A-B问题VIII" class="headerlink" title="A+B问题VIII"></a><a href="https://kamacoder.com/problempage.php?pid=1005">A+B问题VIII</a></h3><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-5-T6P1.png" alt="2024-7-5-T6P1"></p><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-5-T6P2.png" alt="2024-7-5-T6P2"></p><p>根据题目描述相当于把之前的题目合一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">                    result += in.nextInt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i != n - <span class="number">1</span>) System.out.println(result + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> System.out.println(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发笔记07：CAS &amp; 乐观锁与悲观锁 &amp; 原子操作类</title>
      <link href="/2024/07/04/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B007/"/>
      <url>/2024/07/04/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B007/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习Java并发时的知识点总结</p></blockquote><h3 id="CAS——Compare-And-Swap"><a href="#CAS——Compare-And-Swap" class="headerlink" title="CAS——Compare-And-Swap"></a>CAS——Compare-And-Swap</h3><p>对比交换，这是一条CPU的原子指令。</p><p><strong>CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。</strong></p><p><strong>CAS是乐观锁</strong>（在操作数据时非常乐观，认为别人不会同时修改数据。因此在执行更新的时候只会判断一下在此期间别人是否修改了数据，如果别人修改了数据则放弃操作，否则执行操作）<strong>，CAS是无锁的</strong>，所以如果线程之间<strong>存在竞争</strong>的时候，就只能通过<strong>自旋的方式来等待</strong></p><p><strong>CAS自旋</strong>：接上，CAS自旋相当于循环+CAS，如果本次CAS(100→50)不成功，则会认为有其他线程的CAS快我一步，我会进行CAS(50→0)，如果还不成功则进行CAS(0→-50)……</p><span id="more"></span><h4 id="CAS的三个主要问题"><a href="#CAS的三个主要问题" class="headerlink" title="CAS的三个主要问题"></a>CAS的三个主要问题</h4><ol><li><p><strong>ABA问题</strong>：如果一个值原来是A，变成了B，又变成了A（A→B→A），那么使用CAS进行检查时会发现它的值没有发生变化。</p><blockquote><p>如：</p><p>某人充值游戏需要花费50￥，此时银行卡中余额有100￥，则要执行CAS(100→50)，因为游戏界面比较卡，多点了几次充值按钮，触发了后台threadA和threadB工作要执行CAS(100→50)，此时threadA的CAS(100→50)执行成功，threadB的会被阻塞。</p><p>如果此时正好，wx零钱提现到账50￥，threadC执行CAS(50→100)且执行成功，银行卡余额又变成了100￥，threadB则会成功执行，使得银行卡余额变成50￥。</p></blockquote><p>解决方法：版本号！在变量前加上版本号，同时判断值与版本号是否相等。</p></li><li><p><strong>循环时间长，开销大</strong></p><p>自旋CAS如果长时间不成功，会给CPU带来很大的执行开销</p></li><li><p><strong>只能保证一个共享变量的原子操作</strong></p><p>多变量只能加锁</p></li></ol><h4 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&amp;悲观锁"></a>乐观锁&amp;悲观锁</h4><h3 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h3><p><strong>原子更新基本类型类</strong>：使用原子的方式<strong>更新基本类型</strong>，包括一下三类：</p><ol><li>AtomicBoolean：原子更新布尔类型</li><li>AtomicInteger：原子更新整型</li><li>AtomicLong：原子更新长整型</li></ol><p>对应的操作：</p><ul><li>public final int **get()**：获取当前的值</li><li>public final int **getAndSet(int newValue)**：获取当前的值，并设置新的值</li><li>public final int **getAndIncrement()**：获取当前的值，并自增1</li><li>public final int **getAndDecrement()**：获取当前的值，并自减1</li><li>public final int **getAndAdd(int delta)**：获取当前的值，并加上预期值delta</li></ul><p><strong>原子更新数组</strong>：通过原子的方式<strong>更新数组里的某个元素</strong>，包括一下三类：</p><ol><li>AtomicIntegerArray：原子更新整型数组</li><li>AtomicLongArray：原子更新长整型数组</li><li>AtomicReferenceArray：原子更新引用类型数组</li></ol><p>对应的操作：</p><ul><li>**get(int index)**：获取索引为index的元素值</li><li>**compareAndSet(int index, E expect, E update)**：如果索引index处的值等于expect，则更新为update</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicIntegerArray</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>先到这里，日后再更新</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列07：消息延迟队列</title>
      <link href="/2024/07/04/MQ07/"/>
      <url>/2024/07/04/MQ07/</url>
      
        <content type="html"><![CDATA[<blockquote><p>怎么实现订单超时自动取消？</p></blockquote><p>kafka不支持延迟消息！但是延迟消息却是经常使用的：</p><p>如在电商、支付等系统中，一般都是先创建订单A or 支付单A，再给用户一定时间进行支付，如果没有按时支付的话，就需要把之前的订单A or 支付单A取消掉。</p><h3 id="延迟队列和延迟消息"><a href="#延迟队列和延迟消息" class="headerlink" title="延迟队列和延迟消息"></a>延迟队列和延迟消息</h3><p>延迟队列是一种特殊的队列，队列中的<strong>每个元素都有一个过期时间</strong>；当元素还<strong>没到过期时间</strong>的时候，如果试图从队列中<strong>获取这个元素</strong>，就会<strong>被阻塞</strong>。而当有<strong>元素过期</strong>时，就会<strong>得到这个元素</strong>——得到的永远是最先过期的元素。</p><p>JDK就自带延迟队列（阻塞队列中的<strong>DelayQueue</strong>）</p><p><strong>延迟消息</strong>，是一种特殊的延迟队列，是<strong>基于消息队列的延迟队列</strong>。——延迟消息指<strong>消息不会立刻被消费，而是经过一段时间后才会被消费。在经过这段时间之前，这个消息一直被存储在消息队列的服务器上</strong>（Question：这个服务器是谁？Producer？Broker？Consumer？）。</p><span id="more"></span><h3 id="如何自己实现延迟消息？"><a href="#如何自己实现延迟消息？" class="headerlink" title="如何自己实现延迟消息？"></a>如何自己实现延迟消息？</h3><p>RabbitMQ中有TTL（Time To Live）即过期时间，可以给消息或者队列设置（若给队列设置则队列中的所有消息都有相同的过期时间），如果队列的生存时间超过设置的TTL则会变成“死信”（Dead Message），放入死信队列中（DLX，Dead-Letter-Exchange）。</p><p>所以，有如下操作：</p><ul><li>准备一个队列Queue，并为这个队列设置过期时间TTL（且这个队列没有消费者）</li><li>将真实的业务biz_Queue绑定到这个Queue，作为它的死信队列</li><li>生产者发送消息到Queue中，因为没有消费者，等TTL时间之后，消息过期，会将消息转发到死信队列biz_Queue中，此时消费者就可以拿到消息了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MessageQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM模式——树的构建</title>
      <link href="/2024/06/29/ACM%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/"/>
      <url>/2024/06/29/ACM%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 起因——近期遇到的一个笔试题需要使用ACM模式构建树来解题， 后面找到“<a href="https://kamacoder.com/">卡码网</a>”练习21-23题+51题（24 25不知道是不是做一下再说）</p></blockquote><p>逐渐理解了ACM模式和核心代码模式的区别与共通部分——<strong>Solution部分相同</strong></p><ul><li>ACM模式在Main类中的main方法中处理输入参数，之后再完成代码执行逻辑</li><li>核心代码模式不需要处理入参，只用完成代码的执行逻辑就OK了（相当于ACM的第二部分）</li></ul><p>二叉树的定义代码：（ACM模式中这些都是自己定义的，所以具体实现的方法比较多样化）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">     <span class="type">int</span> val;<span class="comment">//当前位置</span></span><br><span class="line">     <span class="type">int</span> letter;<span class="comment">//字母标识</span></span><br><span class="line">     TreeNode left;<span class="comment">//左右节点</span></span><br><span class="line">     TreeNode right;</span><br><span class="line">    </span><br><span class="line">     TreeNode() &#123;&#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val,<span class="type">int</span> letter) &#123;</span><br><span class="line">         <span class="built_in">this</span>.val = val; </span><br><span class="line">         <span class="built_in">this</span>.letter = letter; </span><br><span class="line">     &#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">         <span class="built_in">this</span>.val = val;</span><br><span class="line">         <span class="built_in">this</span>.left = left;</span><br><span class="line">         <span class="built_in">this</span>.right = right;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="21-构造二叉树"><a href="#21-构造二叉树" class="headerlink" title="21. 构造二叉树"></a><a href="https://kamacoder.com/problempage.php?pid=1020">21. 构造二叉树</a></h3><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-3-T21P1.png" alt="2024-7-3-T21P1"></p><p>这个题目和<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">leetcode中对应的题目</a>不是一样的问法：此题<strong>只要求返回后序遍历的结果</strong>，所以不需要真的构建二叉树进行操作。</p><p><strong>前序遍历</strong>的特点是：根节点总是在前序遍历的第一个位置。<br><strong>中序遍历</strong>的特点是：根节点总是在左子树和右子树的中间位置。</p><p>所以可以通过前序遍历找到根节点，然后在中序遍历中找到根节点的位置，将中序遍历分为左子树和右子树。然后对左子树和右子树分别进行同样的操作，直到子树为空。    </p><p><strong>后序遍历</strong>的特点是：根节点总是在最后一个位置。<br>所以可以通过<strong>递归</strong>的方式，<strong>先找到左子树和右子树的后序遍历，然后再加上根节点，就可以得到整棵树的后序遍历</strong>。</p><p><strong>详细的解题步骤：</strong></p><ol><li>通过<strong>前序遍历找到根节点的值</strong>。</li><li>在<strong>中序遍历中找到根节点的位置</strong>，将中序遍历分为左子树和右子树。</li><li>对左子树和右子树分别进行同样的操作，直到子树为空。（<strong>递归</strong>）</li><li>通过递归的方式，先找到左子树和右子树的后序遍历，然后再加上根节点，就可以得到整棵树的后序遍历。</li><li>返回后序遍历的结果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">            String[] str = in.nextLine().split(<span class="string">&quot; &quot;</span>); <span class="comment">// 根据示例，每一行是一个测试；多行输入时多个测试情况</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">pre</span> <span class="operator">=</span> str[<span class="number">0</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">mid</span> <span class="operator">=</span> str[<span class="number">1</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">post</span> <span class="operator">=</span> solution.change2Back(pre, mid);</span><br><span class="line">            System.out.println(post);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于核心代码模式要写的内容。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">change2Back</span><span class="params">(String pre, String mid)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre.isEmpty())&#123;<span class="comment">//终止条件 子树为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">root</span> <span class="operator">=</span> pre.charAt(<span class="number">0</span>);<span class="comment">//通过前序遍历找到第一个根</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> mid.indexOf(root);<span class="comment">//再通过中序遍历分为左右子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">leftPre</span> <span class="operator">=</span> pre.substring(<span class="number">1</span>, rootIndex+<span class="number">1</span>);<span class="comment">//对于前序遍历，第一个字符是根节点，所以从第二个字符开始，到根节点在中序遍历中的位置</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">leftMid</span> <span class="operator">=</span> mid.substring(<span class="number">0</span>, rootIndex);<span class="comment">//对于中序遍历，从开始到根节点在中序遍历中的位置，这部分就是左子树的中序遍历。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rightPre</span> <span class="operator">=</span> pre.substring(rootIndex+<span class="number">1</span>);<span class="comment">//当只有一个参数时，表示截取从该参数位置开始到字符串末尾的所有字符。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rightMid</span> <span class="operator">=</span> mid.substring(rootIndex+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//合并遵循 左右根序列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">leftPost</span> <span class="operator">=</span> change2Back(leftPre, leftMid);</span><br><span class="line">        <span class="type">String</span> <span class="variable">rightPost</span> <span class="operator">=</span> change2Back(rightPre, rightMid);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> leftPost + rightPost + root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-二叉树的遍历"><a href="#22-二叉树的遍历" class="headerlink" title="22. 二叉树的遍历"></a><a href="https://kamacoder.com/problempage.php?pid=1021">22. 二叉树的遍历</a></h3><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-4-T22P1.png" alt="2024-7-4-T22P1"></p><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-4-T22P2.png" alt="2024-7-4-T22P2"></p><p>这道题有种似曾相识的感觉，但是忘了在哪里见过了。</p><p>算是一道比较简单的题目：构建二叉树，前中后序遍历二叉树。</p><p>因为是ACM模式，所以需要<strong>自定义二叉树的结构</strong>、<strong>自己处理输入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line"></span><br><span class="line">        in.nextLine(); <span class="comment">//切换到下一行</span></span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer, TreeNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        String[][] str = <span class="keyword">new</span> <span class="title class_">String</span>[n + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//标识数组 用来判断根节点 逻辑：在树中当一个节点不是任何节点的子节点时为根节点</span></span><br><span class="line">        <span class="type">boolean</span>[] isRoot = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(isRoot, <span class="literal">true</span>);<span class="comment">//先全部填充</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建所有节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            str[i] = in.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i, (<span class="type">int</span>) str[i][<span class="number">0</span>].charAt(<span class="number">0</span>) - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            map.put(i, node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据str中的内容，构建节点之间的对应关系</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> map.get(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左子树</span></span><br><span class="line">            <span class="keyword">if</span> (str[i][<span class="number">1</span>].equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">                node.left = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Integer.parseInt(str[i][<span class="number">1</span>]);</span><br><span class="line">                node.left = map.get(left);</span><br><span class="line">                isRoot[left] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//右子树</span></span><br><span class="line">            <span class="keyword">if</span> (str[i][<span class="number">2</span>].equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">                node.right = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Integer.parseInt(str[i][<span class="number">2</span>]);</span><br><span class="line">                node.right = map.get(right);</span><br><span class="line">                isRoot[right] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据isRoot设置根节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRoot[i]) &#123;</span><br><span class="line">                root = map.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前序遍历：</span></span><br><span class="line">        preOrder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        inOrder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        postOrder(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print((<span class="type">char</span>) (root.signal + <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        System.out.print((<span class="type">char</span>) (root.signal + <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder(root.left);</span><br><span class="line">        postOrder(root.right);</span><br><span class="line">        System.out.print((<span class="type">char</span>) (root.signal + <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的二叉树节点数据结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> signal;</span><br><span class="line"></span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val, <span class="type">int</span> signal) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.signal = signal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-二叉树的高度"><a href="#23-二叉树的高度" class="headerlink" title="23. 二叉树的高度"></a><a href="https://kamacoder.com/problempage.php?pid=1022">23. 二叉树的高度</a></h3><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-4-T23P1.png" alt="2024-7-4-T23P1"></p><p>这道题之前遇到过，在<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">LeetCode</a>中，只需要构建出对应的二叉树即可，和这里的第一题（T21）也差不多。</p><p>其实就是，根据前序遍历中第一个字符为root，在中序遍历中找对应的位置分割出左右子树，循环遍历……详见T21中的描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            in.nextLine();</span><br><span class="line">            <span class="comment">// 前序遍历</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">preOrder</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">            <span class="comment">// 中序遍历</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">inOrder</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//构建二叉树</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> solution.createTree(preOrder, inOrder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 得到二叉树的高度</span></span><br><span class="line">            System.out.println(solution.getHeight(root, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">createTree</span><span class="params">(String preOrder, String inOrder, <span class="type">int</span> preLeft, <span class="type">int</span> preRight, <span class="type">int</span> inLeft, <span class="type">int</span> inRight)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preLeft &gt; preRight) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在前序遍历中找到root节点的值</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">rootVal</span> <span class="operator">=</span> preOrder.charAt(preLeft);</span><br><span class="line">        <span class="type">int</span> <span class="variable">inIndex</span> <span class="operator">=</span> inLeft;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到中序遍历中root的位置，区分左右子树；</span></span><br><span class="line">        <span class="keyword">for</span> (; inIndex &lt; inRight; inIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inOrder.charAt(inIndex) == rootVal) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//确定左子树的长度，用于确定左子树的范围</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> inIndex - inLeft;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        root.left = createTree(preOrder, inOrder, preLeft + <span class="number">1</span>, preLeft + leftLength, inLeft, inIndex - <span class="number">1</span>);</span><br><span class="line">        root.right = createTree(preOrder, inOrder, preLeft + leftLength + <span class="number">1</span>, preRight, inIndex + <span class="number">1</span>, inRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有下一层，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> height;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有下一层，则高度++</span></span><br><span class="line">        height++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> root.left == <span class="literal">null</span> ? height : getHeight(root.left, height);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> root.right == <span class="literal">null</span> ? height : getHeight(root.right, height);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">char</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">char</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="51-平移二叉树"><a href="#51-平移二叉树" class="headerlink" title="51. 平移二叉树"></a><a href="https://kamacoder.com/problempage.php?pid=1051">51. 平移二叉树</a></h3><blockquote><p>待完成</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列06：消息积压处理</title>
      <link href="/2024/06/28/MQ06/"/>
      <url>/2024/06/28/MQ06/</url>
      
        <content type="html"><![CDATA[<blockquote><p>线上消息积压了，怎么处理？</p></blockquote><p><strong>消息积压的原因</strong>：系统中某个部分出现了性能问题，来不及处理上游发送的消息，导致消息积压</p><p>消息积压主要引出两个问题——如何避免消息积压？如何处理消息积压？</p><h2 id="优化性能来避免消息积压"><a href="#优化性能来避免消息积压" class="headerlink" title="优化性能来避免消息积压"></a>优化性能来避免消息积压</h2><p>消息队列系统中的性能主要体现在，<strong>生产者发消息和消费者收消息</strong>的业务逻辑中。</p><p>对于大多数业务来说，<strong>消息队列本身的处理能力要远大于业务系统的处理能力</strong>。（消息队列执行的业务主要是收发、而业务系统执行的业务逻辑远比消息队列的复杂，所以处理能力较差）</p><p>于是对于“如何优化性能来避免消息积压？”这个问题，我们要关注的是：<strong>在消息收发的两端，业务代码要怎么和消息队列配合，达到一个最佳的性能。</strong></p><span id="more"></span><h3 id="发送端性能优化"><a href="#发送端性能优化" class="headerlink" title="发送端性能优化"></a>发送端性能优化</h3><p>发送端业务代码的处理性能，实际上和消息队列的关系不大，毕竟是发送端先执行自己的业务逻辑产生消息，然后再发送消息。</p><p>因此对于发送端（发送消息）的业务逻辑，只需要注意<strong>设置合适的并发和批量大小</strong>就行。若要提高性能可以提高并发和批量大小（但是两者有时要进行选择：如在线系统比较注重时延，提高批量大小必然会增大时延，所以选择提高并发量来提高性能；离线系统不关心时延，更注重吞吐量，所以增大批量大小就可以了）</p><h3 id="消费端性能优化"><a href="#消费端性能优化" class="headerlink" title="消费端性能优化"></a>消费端性能优化</h3><p><strong>消息队列的性能问题大部分都出现在消费端！</strong>（消费端的消费速度根本不上发送端发送消息速度，就会造成消息积压）——所以系统的<strong>消费端的消费性能要高于生产端的发送性能</strong></p><p>消费端的消费性能提高的方法：</p><ol><li>优化消费业务逻辑</li><li><strong>增加消费端的并发数</strong>（增加Consumer的实例数量），且要同步增加主题中分区的数量，保证Consumer的实例数的分区数量是相等的。（每个分区上只支持单线程消费）</li></ol><h2 id="处理消息积压"><a href="#处理消息积压" class="headerlink" title="处理消息积压"></a>处理消息积压</h2><p>对于系统发生消息积压的情况，需要先解决积压，再分析原因，毕竟保证系统的可用性是首先要解决的问题。快速解决积压的方法就是通过水平扩容增加 Consumer 的实例数量。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MessageQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发笔记06：其余并发安全容器</title>
      <link href="/2024/06/13/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B006/"/>
      <url>/2024/06/13/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B006/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习Java并发时的知识点总结</p></blockquote><p>JUC中除了ConcurrentHashMap之外还有其他的并发安全容器：</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>JUC中主要的<strong>线程安全List</strong></p><p><strong>CopyOnWrite</strong>——当容器需要被修改时，不直接修改当前容器，而是先将当前容器进行Copy，复制出一个新的容器，然后修改新的容器，<strong>修改完成后，再将原容器的引用指向新的容器</strong>（相当于MySQL中的写时复制技术）</p><p>CopyOnWrite的适用场景——<strong>读多写少</strong>；<strong>要求读操作快</strong>，而写操作慢一点也没关系</p><p>ArrayList的经典问题——迭代期间是否允许修改结合内容？</p><ul><li><strong>ArrayList</strong>在迭代期间如果修改结合内容，会<strong>抛出异常</strong>（ConcurrentModificationException）</li><li><strong>CopyOnWriteArrayList</strong>在迭代期间如果修改结合内容，<strong>不会抛出异常</strong>，因为就数据依旧存在，迭代器使用的还是旧数组，不过旧数据可能已经过时了。</li></ul><p>CopyOnWriteArrayList的缺点：</p><ul><li><strong>内存占用</strong>：正如MySQL中的写时复制技术一样，因为要复制，所以内容中会同时有两个对象的内容，会占用内存。</li><li><strong>数据一致性的问题</strong>：因为是CopyOnWrite的逻辑是先修改副本，导致修改的内容对于其他的线程来说不能实时看到，只能修改完成后才能可见。</li></ul><span id="more"></span><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>线程安全队列，且ConcurrentLinkedQueue是<strong>非阻塞队列</strong>，使用<strong>循环<a href="http://yhy1031.cn/2024/07/04/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B007/">CAS</a>实现</strong></p><p><strong>入队过程：（一个死循环）</strong></p><ul><li>定位尾节点</li><li>使用CAS算法将入队节点设置为尾节点的next节点，如果不成功则重试</li></ul><p><strong>适合用在不需要阻塞功能，且并发不是特别剧烈的场景</strong></p><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p><strong>阻塞队列</strong>是支持阻塞的插入和移除方法的队列</p><p><strong>阻塞的插入</strong>：当队列满时，队列会阻塞插入元素的线程，等待队不满（队列中有出队的情况）</p><p><strong>阻塞的移除</strong>：队列为空时，队列会阻塞获取元素的线程，等待队列变为非空</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-2-BQ01.png" alt="2024-7-2-BQ01"></p><p>和常规queue的操作比较类似（add remove<strong>抛异常</strong>、offer poll会<strong>返回值</strong>true or null）</p><h4 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h4><ul><li><strong>ArrayBlockingQueue</strong>：由数据结构组成的有界阻塞队列</li><li><strong>LinkedBlockingQueue</strong>：由链表结构组成的有界阻塞队列。队列的默认和最大长度为Integer.MAX_VALUE</li><li><strong>PriorityBlockingQueue</strong>：支持优先级排序的无界阻塞队列，默认为自然顺序升序排列，但是可以通过重写compareTo()方法实现指定顺序排序</li><li><strong>DelayQueue</strong>：使用优先级队列实现的无界阻塞队列。队列使用PriorityQueue来实现。且<strong>实现Delayed接口</strong>，可以在创建元素时指定多久才能从队列中获取当前元素（缓存有效期、定时任务调度）</li><li><strong>SynchronousQueue</strong>：不存元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。队列本身不存放任何元素（随放随拿）</li><li><strong>LinkedTransferQueue</strong>：链表结构组成的单向无界阻塞队列</li><li><strong>LinkedBlockingDeque</strong>：由链表组成的双向阻塞链表（如Deque）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列05：消息幂等性</title>
      <link href="/2024/06/13/MQ05/"/>
      <url>/2024/06/13/MQ05/</url>
      
        <content type="html"><![CDATA[<blockquote><p>怎么避免消息重复消费？（当时面试时的问题）</p></blockquote><p>消息重复消费场景——伴随着消息传递失败重新发送而发生</p><p>比如说，一个消费订单消息，统计下单金额的微服务，如果没有正确处理重复消息，那就会出现重复统计，导致统计结果错误。</p><h3 id="消息队列的现状"><a href="#消息队列的现状" class="headerlink" title="消息队列的现状"></a>消息队列的现状</h3><p>我们现在常用的大多数消息队列提供的服务质量都是<strong>At least once</strong>（至少一次。消息在传递时，至少会被送达一次；也就是说不会丢消息，<strong>保证了可见性但无法保证消息不会重复</strong>）</p><p>我们期待的是 Exactly once（恰好一次，不允许丢失和重复），但是目前没有厂商能做到这一点</p><h3 id="用幂等性解决重复消息问题"><a href="#用幂等性解决重复消息问题" class="headerlink" title="用幂等性解决重复消息问题"></a>用幂等性解决重复消息问题</h3><blockquote><p> 一般解决重复消息的办法是，在消费端，让我们消费消息的操作具备<strong>幂等性</strong>。<br><strong>At least once + 幂等操作  &#x3D; Exactly once</strong></p></blockquote><p>幂等性，想起了学HTTP的时候，Post和Get关于幂等性和安全性和讨论</p><p><strong>幂等</strong>：用于描述一个操作、方法or服务；幂等操作，<strong>其任意多次执行所产生的影响均与一次执行的影响相同</strong>——所以对于幂等操作，不用担心重复执行会对系统造成任何改变</p><span id="more"></span><h2 id="常用设计幂等操作的方法"><a href="#常用设计幂等操作的方法" class="headerlink" title="常用设计幂等操作的方法"></a>常用设计幂等操作的方法</h2><h3 id="利用数据库的唯一约束实现幂等"><a href="#利用数据库的唯一约束实现幂等" class="headerlink" title="利用数据库的唯一约束实现幂等"></a>利用数据库的唯一约束实现幂等</h3><p>数据库的唯一约束可限定对应字段的记录在数据库中不可能存在第二条！</p><p>根据这条特性，我们可以<strong>设计一个和待消费消息匹配的表</strong>，<strong>将特异性字段设置唯一约束</strong>，保证只存在一条这样的记录，从而保证了消息的幂等性</p><p>如针对转账消息（包括转账单ID、账户ID、变更金额），我们可以创建一张流水转账表（包括这些字段），将转账单ID 和 账户ID 两个字段联合创建唯一约束，保证了表中对于相同转账单ID 和 账户ID 的记录最多只能存在一条</p><p>同样的，Redis中SETNX也可以实现</p><h3 id="为更新的数据设置前置条件"><a href="#为更新的数据设置前置条件" class="headerlink" title="为更新的数据设置前置条件"></a>为更新的数据设置前置条件</h3><p><strong>给数据变更设置一个前置条件，如果满足条件就更新数据，否则拒绝更新数据</strong>。（但是这种操作对消息设计的要求比较高）</p><p>这样设置保证了第一次消费时满足条件可以执行，之后的消费会因为无法满足条件而不能执行（第一次执行后导致了判断条件不再满足）</p><p>另外，如果要更新的数据不是数值，我们可以<strong>将前置条件改为数据的版本号，和当前版本号一致则可更新</strong></p><h3 id="记录并检查操作——Token机制-or-GUID-全局唯一ID-机制"><a href="#记录并检查操作——Token机制-or-GUID-全局唯一ID-机制" class="headerlink" title="记录并检查操作——Token机制 or GUID(全局唯一ID)机制"></a>记录并检查操作——Token机制 or GUID(全局唯一ID)机制</h3><p>思路：<strong>在执行数据更新操作之前，先检查是否执行过这个更新操作</strong>（我当时面试的时候就是往这个方向回答的）</p><p>具体的实现方式：在发送消息时，<strong>给每条消息指定一个全局唯一的ID</strong>；消费时，<strong>先根据这个ID检查这条消息是否被消费过</strong>；如果没有消费过，才更新数据，然后<strong>将消费状态置为已消费</strong></p><p>但是这个方案很难实现，GUID就很难实现了；“检查消费状态”、“更新数据”、“设置消费状态”这三个操作很显然要保证原子性，用事务？锁？都可以，但是都不好解决</p><p>所以这种方法属于是迫不得已的方法了</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MessageQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列04：消息有序性</title>
      <link href="/2024/06/11/MQ04/"/>
      <url>/2024/06/11/MQ04/</url>
      
        <content type="html"><![CDATA[<blockquote><p>业务上需要顺序消费，怎么保证消息的有序性？</p></blockquote><h2 id="消息顺序消费的困难——时钟有序"><a href="#消息顺序消费的困难——时钟有序" class="headerlink" title="消息顺序消费的困难——时钟有序"></a>消息顺序消费的困难——时钟有序</h2><p>消息队列中，Producer、Broker、Consumer可能分布在不同的服务器上，不同机器的本地时钟会存在时钟偏斜等问题，<strong>本地时间会不一致</strong>，所以不能用消息发送和到达的时间戳作为时序判断的标准</p><p>分布式系统，<strong>缺乏全局时钟</strong>，使用绝对的时间顺序很困难</p><p>如果发生<strong>消息重传</strong>，也会出现消息乱序的情况</p><span id="more"></span><h2 id="不同消息队列对顺序消费的保证——时钟有序"><a href="#不同消息队列对顺序消费的保证——时钟有序" class="headerlink" title="不同消息队列对顺序消费的保证——时钟有序"></a>不同消息队列对顺序消费的保证——时钟有序</h2><p>当前大部分消息队列的应用场景都是集群部署，在全局有序的情况下，无法使用多分区进行性能的优化。在实际开发中，一般是应用<strong>局部有序</strong>，<strong>把业务消息分发到一个固定的分区，也就是单个队列内传输的方式，实现业务上对有序的要求。</strong></p><h3 id="Kafka-顺序消息"><a href="#Kafka-顺序消息" class="headerlink" title="Kafka 顺序消息"></a>Kafka 顺序消息</h3><p>Kafka 保证消息在 Partition 内的顺序，对于需要确保顺序的消息，<strong>发送到同一个 Partition 中</strong>就可以。（单分区天然满足，多分区就要保证上述内容了）</p><p>例如，电商系统中的订单流转信息，我们在写入 Kafka 时通过订单 ID 进行分发，<strong>保证同一个订单 ID 的消息都会被发送到同一个 Partition 中</strong>，这样消费端在消费的时候，可以保证取出数据时是有序的。</p><h3 id="RocketMQ-顺序消息"><a href="#RocketMQ-顺序消息" class="headerlink" title="RocketMQ 顺序消息"></a>RocketMQ 顺序消息</h3><p>RocketMQ 保证消息在同一个 Queue 中的顺序性，也就是可以满足队列的先进先出原则（和Kafka类似）</p><p>如果把对应一个业务主键的消息都路由到同一个 Queue 中就可以实现消息的有序传输，并且 RocketMQ 额外支持 Tag 的方式，可以对业务消息做进一步的拆分，在消费时相对更加灵活。</p><h2 id="消息顺序消费的困难——业务有序"><a href="#消息顺序消费的困难——业务有序" class="headerlink" title="消息顺序消费的困难——业务有序"></a>消息顺序消费的困难——业务有序</h2><p>业务有序就是指<strong>业务的执行流程是有序的</strong></p><p>比如在一个订单状态消息流转的业务场景中，订单会有创建成功、待付款、已支付、已发货的状态，这几个状态之间是单调流动的，也就是说，订单状态的更新需要保证有序性。</p><h3 id="业务有序的实现："><a href="#业务有序的实现：" class="headerlink" title="业务有序的实现："></a>业务有序的实现：</h3><p>除了消息队列自身的顺序消费机制，我们可以合理地对消息进行改造，从业务上实现有序的目的。具体的方式有以下几种。</p><ul><li><p><strong>根据不同的业务场景，以发送端或者消费端时间戳为准</strong></p><p>比如在电商大促的秒杀场景中，如果要对秒杀的请求进行排队，就可以使用秒杀提交时服务端的时间戳，虽然服务端不一定保证时钟一致，但是在这个场景下，我们不需要保证绝对的有序。</p></li><li><p><strong>每次消息发送时生成唯一递增的 ID</strong></p><p>在每次写入消息时，可以考虑添加一个单调递增的序列 ID，在消费端进行消费时，缓存最大的序列 ID，只消费超过当前最大的序列 ID 的消息。这个方案和分布式算法中的 Paxos 很像，虽然无法实现绝对的有序，但是可以保证每次只处理最新的数据，避免一些业务上的不一致问题。</p></li><li><p><strong>通过缓存时间戳的方式</strong></p><p>这种方式的机制和递增 ID 是一致的，即当生产者在发送消息时，添加一个时间戳，消费端在处理消息时，通过缓存时间戳的方式，判断消息产生的时间是否最新，如果不是则丢弃，否则执行下一步。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MessageQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发笔记05：ConcurrentHashMap</title>
      <link href="/2024/06/11/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B005/"/>
      <url>/2024/06/11/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B005/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习Java并发时的知识点总结</p></blockquote><p>之前学习HashMap时，知道HashMap是线程不安全的（Hashtable是线程安全的，但是用的是Synchronized加锁，效率低下），于是引出了JUC中的<strong>ConcurrentHashMap</strong></p><h3 id="锁分段技术——ConcurrentHashMap的并发思想"><a href="#锁分段技术——ConcurrentHashMap的并发思想" class="headerlink" title="锁分段技术——ConcurrentHashMap的并发思想"></a>锁分段技术——ConcurrentHashMap的并发思想</h3><p>将数据分成一段一段的存储，然后给每一段的数据配一把锁，<strong>当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</strong></p><p>解决了HashMap在并发环境中，因为单锁竞争导致效率低下的问题</p><span id="more"></span><h2 id="ConcurrentHashMap——JDK1-7"><a href="#ConcurrentHashMap——JDK1-7" class="headerlink" title="ConcurrentHashMap——JDK1.7"></a>ConcurrentHashMap——JDK1.7</h2><p><strong>Java使用了上面的分段锁机制实现了ConcurrentHashMap</strong></p><p>ConcurrentHashMap在对象中保存了一个<strong>Segment数组——将整个Hash表划分为为多个分段</strong>；每个Segment元素——划分出来的分段，类似一个Hashtable。</p><p>执行操作时，首先根据hash算法定位到元素属于哪个Segment，<strong>对具体的Segment加锁</strong>即可；同时其他的Segment可以被其他线程访问，整个HashMap是不受影响的。</p><p>下图为ConcurrentHashMap的结构，ConcurrentHashMap是由Segment数据结构和HashEntry数据结构组成；<strong>Segment是一种可重入锁</strong>，HashEntry就是存储K-V</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-11-CCHM1.png" alt="2024-6-11-CCHM1"></p><h3 id="初始化（JDK1-7）new-ConcurrentHashMap"><a href="#初始化（JDK1-7）new-ConcurrentHashMap" class="headerlink" title="初始化（JDK1.7）new ConcurrentHashMap( )"></a>初始化（JDK1.7）new ConcurrentHashMap( )</h3><p><strong>初始化参数：</strong></p><ul><li><strong>concurrencyLevel</strong>：并发数，CHM中<strong>Segment的数量</strong>（Segment[]的大小），初始化确定后就不能再变化了，默认为16</li><li><strong>initialCapacity</strong>：初始容量，CHM的初始<strong>HashEntry的总数量</strong>，之后要平均分给每个Segment</li><li><strong>loadFactor</strong>：负载因子，用于<strong>每个Segment内部的HashEntry[]扩容</strong>（Segment[]不能扩容）</li></ul><p><strong>new ConcurrentHashMap( )无参构造函数执行初始化后：</strong></p><ul><li>Segment[]长度为16，默认</li><li>每一个分段 Segment[i]的默认大小为2，且负载因子默认为0.75（这里很有说法，2*0.75&#x3D;1.5取整后为1，也就是初始阈值为1；插入第一个元素不会触发扩容；插入第二个元素会触发第一次扩容）</li><li>初始化了segment[0]，但其他位置还是null</li><li>定义了 segmentShift 移位数 和 segmentMask 掩码，用于之后定位Segment</li></ul><h3 id="定位Segment-——插入or获取元素的前提"><a href="#定位Segment-——插入or获取元素的前提" class="headerlink" title="定位Segment  ——插入or获取元素的前提"></a>定位Segment  ——插入or获取元素的前提</h3><p>segmentFor(hash)</p><p>ConcurrentHashMap会对元素的hashCode进行再散列，得到新的hash值，并使用这个hash值 结合之前的segmentShift 和 segmentMask 进行后续的定位（包括定位segment和entry），其实就是得到确定的Segment下标</p><h3 id="ConcurrentHashMap的操作"><a href="#ConcurrentHashMap的操作" class="headerlink" title="ConcurrentHashMap的操作"></a>ConcurrentHashMap的操作</h3><ol><li><p><strong>get操作</strong></p><p>先算hashcode再经过一次散列得到hash，最后用hash定位Segment，根据key得到value</p><p>这个过程是很<strong>高效</strong>的，因为<strong>不需要加锁！</strong>——将要使用的共享变量都定义为了volatile（弱一致性，不会像读写互斥锁一样保证强一致性，当前共享内存中是什么值，就读取什么值）</p></li><li><p><strong>put操作</strong></p><p>put要写入内容，肯定是<strong>要加锁</strong>的。</p><p>put方法首先要定位到segment（segmentFor方法），然后再Segment中插入（分为：判断是否要扩容、定位插入位置插入）</p><p><strong>扩容时机</strong>：<strong>插入前判断是否需要扩容</strong>（和hashmap不一样，hashmap是插入后判断是否要扩容），避免了扩容之后，没有后续插入操作的情况发生</p></li><li><p><strong>size操作</strong></p><p>要统计整个ConcurrentHashMap的大小，就要统计所有Segment中元素大小求和。</p><p>思路如下：</p><ol><li>Segment中是有全局变量count的，直接<strong>把所有count直接相加</strong>，但是这种方法过程中<strong>count可能会变化</strong></li><li>在上述过程中，<strong>将所有Segment的put、remove、clean方法全部锁住</strong>；保证count不会变化，但是<strong>效率很低</strong></li></ol><p><strong>最终流程：</strong>Segment中是有全局变量count的，直接把所有count直接相加，累计做3次；如果这个过程中，容器的count变化了，那就通过加锁的方式来统计count</p><p><strong>累计做3次的解释：</strong></p><ul><li>如果本次尝试末端Count没有发生变化，就直接返回，不用再尝试了</li><li>如果有变化就进行下一次的尝试，直到尝试3次之后，如果还不行，就加锁</li></ul></li></ol><h2 id="ConcurrentHashMap——JDK1-8"><a href="#ConcurrentHashMap——JDK1-8" class="headerlink" title="ConcurrentHashMap——JDK1.8"></a>ConcurrentHashMap——JDK1.8</h2><p>和JDK1.7的ConcurrentHashMap相比，<strong>移除了Segment</strong>！！</p><p><strong>实现方式</strong>和1.8的HashMap类似——<strong>数组+链表+红黑树</strong></p><p><strong>加锁方式</strong>——**<a href="http://yhy1031.cn/2024/07/04/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B007/">CAS</a>和Synchronized**</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>每个 Node 里面是 key-value 的形式，并且把 value 用 volatile 修饰，以便保证可见性</p><p><strong>执行put操作时：</strong></p><ul><li>如果hash值对应数组位置为<strong>null</strong>，则<strong>用CAS</strong>放入新值（CAS保证单个变量修改的原子性）</li><li>只有对应槽点<strong>有值</strong>的时候，需要<strong>Synchronized加锁</strong>（针对写操作；不会锁住）</li></ul><p></p><h2 id="ConcurrentHashMap并发不安全的情况——size"><a href="#ConcurrentHashMap并发不安全的情况——size" class="headerlink" title="ConcurrentHashMap并发不安全的情况——size( )"></a>ConcurrentHashMap并发不安全的情况——size( )</h2><p><strong>ConcurrentHashMap 的 size()方法是非线程安全的</strong>。也就是说，当有线程调用 put 方法在添加元素的时候，其他线程在调用 size()方法获取的元素个数和实际存储元素个数是不一致的。</p><p>原因：<strong>size()方法是一个非同步方法，put()方法和 size()方法并没有实现同步锁</strong></p><p>如果有A线程正在进行put操作，之后触发了扩容或者红黑树转置，<strong>那么立即就会synchronized锁定root节点</strong>。之后开始进行对应的操作，这个操作是需要时间的。但是这个时候，如果<strong>线程B来调用size方法，那么size方法由于没有任何锁机制，肯定是能够返回的，此时返回的size就是put之前的值</strong>。所以就会出现弱一致性</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发笔记04：AQS</title>
      <link href="/2024/06/06/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B004/"/>
      <url>/2024/06/06/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B004/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习Java并发时的知识点总结</p></blockquote><p><strong>AQS 即队列同步器</strong>，是用来构建锁 or 其他同步组件的基础框架，AQS<strong>使用一个volatile int成员变量表示同步状态 state</strong>，通过<strong>内置的FIFO队列完成要获取资源的线程的排队工作</strong></p><p><strong>Lock 和 AQS 的关系：</strong></p><p>Lock是面向锁的使用者的，他定义了使用者与锁的交互接口，隐藏了实现细节。</p><p>AQS是面向锁的实现者的，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待与唤醒等底层操作。</p><p>锁和同步器很好的隔离 了使用者和实现者所需关注的领域。</p><span id="more"></span><h3 id="AQS的实现原理分析"><a href="#AQS的实现原理分析" class="headerlink" title="AQS的实现原理分析"></a>AQS的实现原理分析</h3><p>如上所示，AQS中有两个主要的组成</p><ul><li>volatile类型的整数state来表示同步状态<ul><li>state &#x3D; 0 表示没有线程占用同步资源</li><li>state &gt; 0 表示有线程占用资源；&gt; 1 表示该同步资源被占用了很多次（如ReentrantLock，每重入一次就 state++ ）</li></ul></li><li>双向链表的同步队列，通过将等待线程加入同步队列中（只用到FIFO，所以是尾插法），然后再释放同步状态的时候，从同步队列中唤醒等待线程，从而实现了同步机制</li></ul><h3 id="AQS和Monitor的区别"><a href="#AQS和Monitor的区别" class="headerlink" title="AQS和Monitor的区别"></a>AQS和Monitor的区别</h3><p>乍一看两者特别相似——尤其是Monitor中计数器的概念和AQS的state几乎是一样的</p><p>就我目前的理解来看，AQS是Lock（JUC）同步机制的底层实现，Monitor是Synchronized同步机制的底层实现，两者的区别就是Lock和Synchronized的区别</p><h4 id="Lock（ReentrantLock）和Synchronized的异同"><a href="#Lock（ReentrantLock）和Synchronized的异同" class="headerlink" title="Lock（ReentrantLock）和Synchronized的异同"></a>Lock（ReentrantLock）和Synchronized的异同</h4><p><strong>同</strong>：锁的功能是可以实现的（如保护资源线程的安全、可见性、可重入）</p><p><strong>异</strong>：</p><ul><li>Synchronized的加锁和解锁是由内置的Jvm实现的、而Lock需要引入JUC，且加解锁需要lock和unlock手动控制</li><li>Synchronized不如Lock灵活，Lock有lockInterruptibly方法，可以直接退出 or tryLock方法，能获取就获取不能获取就干别的事情；而Synchronized只能等待，直接释放</li><li>Lock有读写锁，读锁可以有多个线程同时拥有，而Synchronized的锁只能被一个线程同时拥有</li><li>Lock可以设置公平 or 非公平</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发笔记03：Lock</title>
      <link href="/2024/06/06/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B003/"/>
      <url>/2024/06/06/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B003/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习Java并发时的知识点总结</p></blockquote><p><strong>锁Lock是显示的加锁解锁</strong>，而Synchronized是隐式的锁；Lock的实现在 java.util.concurrent包中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">//如果要多个线程操作同一个系统资源，需要定义全局锁，将锁对象定义为共享资源</span></span><br><span class="line">    lock.lock(); <span class="comment">// 这才是加锁，上面的只是声明了锁对象</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        count += n;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意：</p><ul><li><strong>解锁一定要放在finally中</strong>，确保无论如何都可以解锁</li><li><strong>加锁一定要放在try-catch外</strong>，因为加锁过程如果发生异常，也会进入finally块导致锁无故释放（当然，如果程序本身就不会抛出异常，那么没必要try-catch）</li></ul><p>Lock接口基本是由AQS实现的（下篇文章主要介绍）</p><span id="more"></span><h3 id="重入锁-ReentrantLock"><a href="#重入锁-ReentrantLock" class="headerlink" title="重入锁 ReentrantLock"></a>重入锁 ReentrantLock</h3><p><strong>什么是重入？</strong>：指任意线程在获取到锁之后，能再次获取该锁而不会被锁阻塞</p><p>主要是两个问题：线程再次获取锁、锁的最终释放（对AQS的状态累加实现）</p><h4 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁 &amp; 非公平锁"></a>公平锁 &amp; 非公平锁</h4><blockquote><p>公平 &amp; 非公平只是锁的获取方式！！！</p></blockquote><p>ReentrantLock类内部有三个类</p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/90ac22daf22e0537cb9264567f7ee5c.png" alt="90ac22daf22e0537cb9264567f7ee5c" style="zoom:80%;" /><p><strong>公平锁：</strong>每个线程获取锁的顺序是按照线程访问锁的先后顺序获取的，最前面的线程总是最先获取到锁。 （<strong>保证了时间上的绝对顺序，但是性能差、上下文切换更频繁</strong>）</p><p><strong>非公平锁：</strong>每个线程获取锁的顺序是随机的，并不会遵循先来先得的规则，所有线程会竞争获取锁。（<strong>性能好、但是可能会“饿死”某些线程</strong>）</p><p>和公平锁相比，非公平锁实现tryAcquire() 方法时多了一个hasQueuedPredecessor()方法，用于判断同步队列中是否有前驱节点，用于实现公平</p><p>ReentrantLock默认为非公平锁（且默认实现就是非公平锁）</p><p>PS：非公平锁只有在第一次尝试获取同步状态时会体现不公平，当获取失败进入到同步队列之后，公平锁和非公平锁就完全一样了</p><h4 id="公平锁-非公平锁对比"><a href="#公平锁-非公平锁对比" class="headerlink" title="公平锁 &amp; 非公平锁对比"></a>公平锁 &amp; 非公平锁对比</h4><p><strong>公平锁执行流程：</strong></p><p>获取锁时，线程A先将自己添加到同步队列的队尾并休眠；当前持有锁的线程执行完毕释放锁后，会唤醒同步队列中队头线程去获取锁；直到线程A成为队头时，才会被唤醒获取锁（先后顺序）</p><p><strong>非公平锁执行流程：</strong></p><p>线程获取锁时，会<strong>先通过<a href="http://yhy1031.cn/2024/07/04/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B007/">CAS</a>尝试获取锁</strong>，如果获取成功则持有锁，如果获取失败则添加到同步队列的队尾并休眠……后续和公平锁相同（不遵循先后顺序）</p><p><strong>非公平锁比公平锁性能好：</strong></p><p>因为获取公平锁时，一定会<strong>使线程进入同步队列并休眠，在之后轮到这个线程后又唤醒并获取锁</strong>；这个过程中线程会<strong>经过运行状态——休眠状态——运行状态的转变</strong>，这个状态的转变<strong>需要从用户态转换成内核态</strong>（线程切换的调度器在内核中），这个状态转换很慢。</p><p>而获取非公平锁时，每个线程都会先通过 CAS 尝试获取锁，可能直接获取锁继续执行了；<strong>避免了部分线程休眠和恢复的操作，减少状态转换的次数</strong>，所以性能好</p><h3 id="读写锁-ReentrantReadWriteLock"><a href="#读写锁-ReentrantReadWriteLock" class="headerlink" title="读写锁 ReentrantReadWriteLock"></a>读写锁 ReentrantReadWriteLock</h3><p>是一种共享锁（之前的ReentrantLock是独占锁，Mutex互斥锁也是独占的）</p><p>读写锁中在同一时间可以允许多个读线程访问（多个线程持有读锁），但是在写线程访问时，所有的读线程和写线程均被阻塞</p><p>分为readLock() 和 writeLock() 可以获取</p><h4 id="读写锁特性"><a href="#读写锁特性" class="headerlink" title="读写锁特性"></a>读写锁特性</h4><p><strong>公平性</strong>：支持公平和非公平（默认）两种锁的获取方式</p><p><strong>重入</strong>：支持重入、同一线程获取读锁后还能再次获取、同一线程获取写锁后还能再次获取写锁 or 读锁</p><p><strong>锁降级：</strong>按照获取写锁，再获取读锁，再释放写锁的顺序，写锁能够降级为读锁</p><p>但是不支持锁升级，因为从读锁升级为写锁，需要等待所有读锁的释放（如果两个线程都想升级，那就都会等待对方的读锁释放，会死锁）</p><h4 id="读写锁特性——锁降级"><a href="#读写锁特性——锁降级" class="headerlink" title="读写锁特性——锁降级"></a>读写锁特性——锁降级</h4><p>如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。<strong>锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程，最后释放读锁的过程。</strong></p><p>假设一个线程已经持有写锁，<strong>锁降级的步骤</strong>通常如下： 获取写锁——获取读锁——释放写锁——释放读锁</p><ul><li><strong>获取写锁：</strong>首先，线程获取写锁以确保对共享数据的独占访问。 </li><li>写入数据：然后，线程进行数据写入操作。</li><li><strong>获取读锁：</strong>在释放写锁之前，线程获取读锁。 </li><li><strong>释放写锁：</strong>接着，线程释放写锁。此时，由于读锁已经被获取，即使其他线程可以开始获取读锁，但写锁仍然不可用。 </li><li>执行读操作：线程可以安全地执行基于最新数据的读操作。 </li><li><strong>释放读锁：</strong>最后，完成读操作后释放读锁。</li></ul><p><strong>为什么要实现锁降级呢？</strong></p><p>如果当前线程不获取读锁而是直接释放写锁， 假设此刻<strong>另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新</strong>。</p><p>如果当前线程获取读锁，即<strong>遵循锁降级的步骤，则线程T将会被阻塞</strong>，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。（保证了本线程后续操作的可见性，一定是最新的数据）</p><h3 id="Lock-和-Synchronized对比"><a href="#Lock-和-Synchronized对比" class="headerlink" title="Lock 和 Synchronized对比"></a>Lock 和 Synchronized对比</h3><p><strong>相同点</strong></p><ol><li>都是用来保护资源线程安全的（作用相同）</li><li>都可以保证可见性</li><li>Synchronized 和 ReentrantLock 都拥有可重入的特点</li></ol><p><strong>不同点：</strong></p><ol><li><strong>加解锁控制差别：</strong>synchronized的加解锁是由Jvm实现的（属于内置锁），Lock的加解锁需要手动控制，通过lock() 和 unlock() 实现</li><li><strong>Synchronized不够灵活：</strong> <strong>synchronized</strong>一个线程获取锁之后，其他线程想要获取锁<strong>只能等待，只能进入阻塞状态，直到持有锁的线程释放这个锁</strong>，可能这个等待过程会持续很久。 <strong>Lock</strong>可以<strong>使用lockInterruptibly方法</strong>，不想等了可以中断退出，也可以<strong>使用tryLock</strong>获取锁，能获取就获取，不能获取线程也可以去干别的事情，更加灵活。</li><li>Synchronized锁只能同时被一个线程拥有，但是Lock锁没有这个限制：如读锁可以被多个线程同时拥有</li><li>ReentrantLock可以根据自己的需求设置公平锁or非公平锁，但是Synchronized 则不能</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();  <span class="comment">// 创建一个静态锁，所有实例共享</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">testThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(test);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">testThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(test);</span><br><span class="line">        testThread1.start();</span><br><span class="line">        testThread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();  <span class="comment">// 确保锁会被释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发笔记02：Synchronized &amp; Volatile</title>
      <link href="/2024/06/05/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B002/"/>
      <url>/2024/06/05/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B002/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习Java并发时的知识点总结</p></blockquote><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>Java中对悲观锁的实现，是synchronized同步块</p><p>众所周知，Synchronized有三种使用场景：</p><ul><li>同步块——只锁synchronized(this)，this对应的对象</li><li>同步方法——会锁住对应的实例对象</li><li>静态同步方法——会锁住整个类的Class对象</li></ul><p>PS：两个线程分别执行<strong>同一个对象synchronized修饰的实例方法和静态方法</strong>时，<strong>不会发生互斥</strong>，因为锁的资源不同，一个是实例对象，一个是类对象。</p><h3 id="Synchronized-之-锁的竞争与升级"><a href="#Synchronized-之-锁的竞争与升级" class="headerlink" title="Synchronized 之 锁的竞争与升级"></a>Synchronized 之 锁的竞争与升级</h3><p>一般来说，锁是不能降级的</p><p>Synchronized的锁有4种状态——无锁、偏向锁、轻量级锁、重量级锁</p><h4 id="底层如何区分呢？"><a href="#底层如何区分呢？" class="headerlink" title="底层如何区分呢？"></a>底层如何区分呢？</h4><p>Synchronized用的锁存储在Java对象头的<strong>Mark word</strong>中</p><p>其中包括指向当前获取锁的对象的指针（轻、重是指针，偏向锁是线程ID）</p><ol><li>锁标志位（2 bit）：轻量级锁为 00，重量级锁为 10，无锁和偏向锁都是 01，11 为GC的标记</li><li>偏向锁标志（1 bit）：未启用偏向锁为0，启用为1——锁标志位无法区分无锁和偏向锁，所以使用偏向锁标志（在锁标志位前 1 bit）</li></ol><p>另外，是否启用偏向锁是提前定义好的，并且有偏向锁启动延迟（延迟之内自动认为没有偏向锁）</p><span id="more"></span><h4 id="偏向锁的竞争与升级"><a href="#偏向锁的竞争与升级" class="headerlink" title="偏向锁的竞争与升级"></a>偏向锁的竞争与升级</h4><p>对象头Mark word中记录的有线程ID，当前线程要访问同步块就需要<strong>竞争偏向锁</strong>：</p><ol><li>当前线程的ID和Mark word中的相同，则放行</li><li>如果不同，则执行CAS操作（<a href="http://yhy1031.cn/2024/07/04/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B007/">CAS介绍</a>），尝试替换Mark word中的线程ID<ol><li>替换成功，则当前线程获得了偏向锁，放行（前一个线程执行完毕 or 当前线程是第一个线程）</li><li>CAS不成功，则要升级为轻量级锁</li></ol></li></ol><p><strong>升级</strong>：将偏向锁撤销（标志位改为0），升级为轻量级锁&#x2F;重量级锁（看后续）</p><h4 id="轻量级锁的竞争与升级"><a href="#轻量级锁的竞争与升级" class="headerlink" title="轻量级锁的竞争与升级"></a>轻量级锁的竞争与升级</h4><p><strong>竞争</strong>：</p><p>（如果没有偏向锁，就自动到这个阶段）</p><p>线程通过 <strong>自旋 + CAS 的方式来竞争轻量级锁</strong>（自旋：占用CPU来反复尝试获取锁，直到获取成功；CAS：compare and swap，详见后续）</p><p>同时竞争的线程，<strong>竞争成功就获得了锁；失败的就自旋等待</strong>（默认认为很快就能释放锁，就在门口等一会）</p><p><strong>升级</strong>：线程<strong>自旋等待了一段时间后</strong>，还是没有获得锁，就将锁升级为重量级锁，自己进入阻塞状态。</p><h4 id="重量级锁的竞争"><a href="#重量级锁的竞争" class="headerlink" title="重量级锁的竞争"></a>重量级锁的竞争</h4><p>重量级锁，线程加锁失败会进入阻塞状态，等待前驱获得线程的锁执行完之后唤醒。</p><h4 id="锁的对比"><a href="#锁的对比" class="headerlink" title="锁的对比"></a>锁的对比</h4><table><thead><tr><th align="left">锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td align="left">偏向锁</td><td>加锁和解锁不需要额外的消耗，执行很快</td><td>如果线程之间存在锁竞争，则锁撤销会有额外的消耗</td><td>适用于只有一个线程访问同步块的场景</td></tr><tr><td align="left">轻量级锁</td><td>竞争锁的线程不会阻塞，提高程序的响应速度</td><td>始终得不到锁的线程，会一直占用CPU自旋</td><td>追求响应时间，同步块执行速度很快</td></tr><tr><td align="left">重量级锁</td><td>线程竞争不会自旋，不消耗CPU</td><td>线程竞争会阻塞，响应时间缓慢</td><td>追求吞吐量，同步块执行速度较慢</td></tr></tbody></table><h3 id="Synchronized-之-Monitor机制"><a href="#Synchronized-之-Monitor机制" class="headerlink" title="Synchronized 之 Monitor机制"></a>Synchronized 之 Monitor机制</h3><p>Monitor机制是synchronized同步块锁机制升级为重量级锁之后的工作机制：</p><p>每个对象都有一个监视器锁。每个Synchronized修饰过的代码当它的monitor被占用时就会处于锁定状态，执行完毕后释放monitor，由其他线程重新获取monitor的所有权</p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>volatile主要作用是保证可见性、而volatile修饰的long 和 double可以保证其原子性</p><p>如果一个字段被声明称volatile，java线程模型（JMM）确保所有线程看到这个变量的值是一样的</p><ul><li><strong>volatile字段修改时</strong>：JMM会<strong>立刻</strong>把该线程对应的本地内存中共享变量值<strong>刷新到主内存中</strong></li><li><strong>当读到一个volatile变量时</strong>：JMM会把该线程<strong>对应的本地内存</strong>置为无效，<strong>线程会从主线程读取共享变量</strong>（保证是新的）</li></ul><p>但是很多时候是不太好用的，如对volatile修饰的int型变量count，count++，会提示Non-atomic operation on volatile field ‘count’，表示不能保证操作的原子性（看之后的原子类 or 加锁）</p><h3 id="Volatile-读写顺序重排规则："><a href="#Volatile-读写顺序重排规则：" class="headerlink" title="Volatile 读写顺序重排规则："></a>Volatile 读写顺序重排规则：</h3><table><thead><tr><th><strong>是否能重排序</strong></th><th><strong>操作二</strong></th><th></th><th></th></tr></thead><tbody><tr><td><strong>操作一</strong></td><td><strong>普通读&#x2F;写</strong></td><td><strong>volatile读</strong></td><td><strong>volatile写</strong></td></tr><tr><td><strong>普通读&#x2F;写</strong></td><td></td><td></td><td><strong>NO</strong></td></tr><tr><td><strong>volatile读</strong></td><td><strong>NO</strong></td><td><strong>NO</strong></td><td><strong>NO</strong></td></tr><tr><td><strong>volatile写</strong></td><td></td><td><strong>NO</strong></td><td><strong>NO</strong></td></tr></tbody></table><p>​<strong>总结：</strong></p><ol><li><strong>volatile读之后的读写操作不能重排到volatile读之前。 （volatile读之后的操作都是最新的数据）</strong></li><li><strong>volatile 写之前的读写操作不能重排到 volatile 写之后。（volatile写之前的操作，经过volatile写之后会更新到共享内存中）</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发笔记01：基础</title>
      <link href="/2024/06/05/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B001/"/>
      <url>/2024/06/05/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习Java并发时的知识点总结</p></blockquote><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p><strong>优点</strong>：（Why）</p><ul><li>提高多核CPU的利用率、充分利用多核CPU的计算能力</li><li>方便进行业务拆分、提高业务性能</li></ul><p><strong>缺点</strong>：</p><ul><li>内存泄漏（看下面的线程变量-ThreadLocal）</li><li>线程安全</li><li>死锁</li></ul><p><strong>三个必要因素</strong>：（满足这三个性质，来保证多线程的线程安全）</p><ul><li>可见性（Volatile、Synchronized、Lock）</li><li>原子性（锁、Synchronized）</li><li>有序性（Happens-Before）</li></ul><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>老生常谈的一个概念——<strong>进程是操作系统资源分配的基本单位</strong>、<strong>线程是操作系统调度资源的基本单位</strong></p><p>同一个类的线程共享代码和数据空间</p><span id="more"></span><p>面试被问过</p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/image-20240605153703397.png" alt="image-20240605153703397" style="zoom: 80%;" /><ul><li><strong>NEW</strong>：<strong>初始状态</strong>，线程被创建，但是还没有调用start()方法</li><li><strong>RUNNABLE</strong>：<ul><li><strong>READY</strong>：当线程对象调用了<code>start()</code>方法之后，线程处于<strong>就绪状态</strong>，就绪意味着该线程<strong>可以执行</strong></li><li><strong>RUNNING</strong>：处于就绪状态的线程获得了CPU之后，<strong>真正开始执行run()方法的线程执行体时</strong>，意味着该线程就已经处于<strong>运行状态</strong></li></ul></li><li><strong>BLOCKED</strong>：<strong>阻塞状态</strong>，表示线程阻塞于锁。</li><li><strong>WAITING</strong>：<strong>等待状态</strong>，表示线程进入等待状态（如执行wait join等方法），进入该状态表示当前线程需要等待其他线程做出一些等待动作（通知或中断）</li><li><strong>TIMED_WAITING</strong>：<strong>超时等待状态</strong>，（wait join等方法中设定等待时长）该状态不同于WAITING状态，它可以在指定的时间自行返回。</li><li><strong>TERMINATED</strong>：<strong>终止状态</strong>，表示当前线程已经执行完毕。</li></ul><p>RUNNABLE中READY与RUNNING状态的一次切换，就是一次<strong>上下文切换</strong>：<br>    因为多线程编程中线程个数一般大于CPU核心个数，所以CPU使用时间片轮转的方法实现大量线程有效执行（宏观并行，微观串行）；CPU为每个线程分批时间片，当时间片执行完后，线程会保存自己的状态，并切换到READY状态，让出CPU给其他xian’cheng</p><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>只掌握两种方式：继承Thread &amp; 实现Runnable接口</p><h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><p>要重写run方法（public）</p><p>因为是继承Thread类，所以直接<strong>new一个该类的实例就可以当作一个线程操作</strong>了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;继承Thread类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        instance.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h4><p>实现 Runnable 的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的</p><p>所以<strong>需要new一个Thread对象</strong>（应该是在Runnable中集成的）来实现</p><p>并且<strong>将类的实例传到 Thread 类中</strong>实现线程操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PS：实现Runnable接口比继承Thread类合适</strong></p><ol><li><strong>Java不支持多继承</strong>，如果用extends的话，就不能再继承其他父类，但是可以实现多个接口</li><li>类的线程有可能只要求可执行，如果继承整个Thread类，开销过大</li></ol><p><strong>补充</strong>：线程类的构造方法、静态块是被哪个线程所调用的？run方法呢？</p><p>​<strong>线程类的构造方法、静态块是被 new这个线程类所在的线程所调用的</strong>，而<strong>run 方法里面的代码才是被线程自身所调用的</strong>。</p><p>​假设 main 函数中 new 了 Thread2，而Thread2 中又 new 了Thread1，那么:</p><ol><li><strong>Thread2 的构造方法、静态块是 main 线程调用的</strong>，<strong>Thread2 的 run()方法是Thread2 自己调用的</strong></li><li><strong>Thread1 的构造方法、静态块是 Thread2 调用的</strong>，<strong>Thread1 的 run()方法是Thread1 自己调用的</strong></li></ol><h3 id="线程中断——Interrupted"><a href="#线程中断——Interrupted" class="headerlink" title="线程中断——Interrupted"></a>线程中断——Interrupted</h3><p>线程中断不同于阻塞等待这些，它是一个线程的标识（可以用isInterrupted()方法判断），线程可以选择如何去处理这个标识（识别到中断后，不停止，而是去执行后续的操作）</p><p><strong>主要是对处于休眠or阻塞状态的线程进行 Interrupt</strong>：如sleep、wait等方法使线程休眠，而处于休眠状态的线程被中断，则线程可以感受到中短信号——<strong>抛出InterruptedException异常</strong>，在这之前需要把中断标志位消除（即<code>isInterrupted()</code> 判断为falue）再抛出InterruptedException异常</p><p>因为还需要执行后续的内容（try-catch以外的部分），如下图所示</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-6-Interrupted.png" alt="2024-6-6-Interrupted"></p><p>这部分也就意味着不能让线程强行停止，让被中断的线程自行判断下一步怎么进行（如何响应中断，不能贸然停止）</p><h3 id="线程变量——ThreadLocal"><a href="#线程变量——ThreadLocal" class="headerlink" title="线程变量——ThreadLocal"></a>线程变量——ThreadLocal</h3><p>以ThreadLocal对象为key、任意对象为value的存储结构（k-v对，ThreadLocalMap）</p><p><strong>当一个Key-Value对被存储之后，会一直附带在该线程上</strong>（只有这个线程可见）；可以在线程执行的任何位置通过这个ThreadLocal对象取到存入的值（set、get）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrintTimeUtil</span> &#123;</span><br><span class="line">        <span class="comment">// 创建的ThreadLocal对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; OBJECT = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">timeBegin</span><span class="params">()</span>&#123;</span><br><span class="line">            OBJECT.set(System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">timeEnd</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis() - OBJECT.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        PrintTimeUtil.timeBegin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> PrintTimeUtil.timeEnd();</span><br><span class="line">        System.out.println(time + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：5006毫秒</p><h4 id="ThreadLocal的常见用法：在一个线程中传递一些上下文参数"><a href="#ThreadLocal的常见用法：在一个线程中传递一些上下文参数" class="headerlink" title="ThreadLocal的常见用法：在一个线程中传递一些上下文参数"></a>ThreadLocal的常见用法：在一个线程中传递一些上下文参数</h4><p>如：<strong>传递一些请求参数</strong><br>    例如有这样的一个调用：方法的请求入口 → 方法1 → 方法2  → …… → 方法n；<br>    如果<strong>在请求入口处，将请求信息和用户信息放入ThreadLocal中</strong>，那么你可以在这个线程执行的任何地方调用Threadlocal对这些数据进行存取；<br>    否则你需要从请求入口处，通过方法参数的方式，一层一层的传递下来~</p><h4 id="ThreadLocal在不同线程中的应用"><a href="#ThreadLocal在不同线程中的应用" class="headerlink" title="ThreadLocal在不同线程中的应用"></a>ThreadLocal在不同线程中的应用</h4><p><strong>不同线程可以实现访问的是同一个ThreadLocal对象，但是他们针对这个对象的存取结果，也是分开的，线程隔离的。</strong></p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-6-TLP1.png" alt="2024-7-6-TLP1"></p><h4 id="Threadlocal可能会导致内存泄漏"><a href="#Threadlocal可能会导致内存泄漏" class="headerlink" title="Threadlocal可能会导致内存泄漏"></a>Threadlocal可能会导致内存泄漏</h4><p>ThreadLocalMap中key为弱引用、Value为强引用；如果ThreadLocal对象没有被外界强引用，GC时会清理掉key，但是value不会；导致key &#x3D; null而value!&#x3D;null；可能内存泄漏</p><p>（详细原因看之后JVM相关的内容，GC）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列03：消息可靠性</title>
      <link href="/2024/06/01/MQ03/"/>
      <url>/2024/06/01/MQ03/</url>
      
        <content type="html"><![CDATA[<blockquote><p>怎么保证消息不会丢失？</p></blockquote><p>目前主流的消息队列产品都提供了完善的消息可靠性保证机制，完全可以做到在消息传递过程中，即使发生网络中断或者硬件故障，也能确保消息的可靠传递，不丢消息。</p><p>不同的消息队列提供的API不同、配置不同，但是<strong>保证消息可靠传递的实现原理是相同的</strong></p><h2 id="检测消息丢失的方法"><a href="#检测消息丢失的方法" class="headerlink" title="检测消息丢失的方法"></a>检测消息丢失的方法</h2><p><strong>利用消息队列的有序性来验证是否有消息丢失</strong>，在 Producer 给每个发出的消息附加一个连续递增的序号，在 Consumer 端检查这个序号的连续性；和TCP的sqlNum比较相似，如果不连续那就是丢消息了；甚至可以用缺失的序号确定丢失的是哪条消息</p><span id="more"></span><h2 id="确保消息可靠传递"><a href="#确保消息可靠传递" class="headerlink" title="确保消息可靠传递"></a>确保消息可靠传递</h2><p>MQ01中，我们知道消息队列分为三个存成部分：Producer——Broker——Consumer</p><p>同样的，一条消息从生产到消费完成这个过程，可以划分三个阶段：</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-9-MQP1V2.png" alt="2024-6-9-MQP1V2"></p><ul><li>生产阶段：消息从Producer中创建出来，经网络传输发送到Broker端</li><li>存储阶段：消息在Broker中存储</li><li>消费阶段：Consumer从Broker上拉取消息，经网络传输发送给Consumer</li></ul><h3 id="生产阶段"><a href="#生产阶段" class="headerlink" title="生产阶段"></a>生产阶段</h3><p>如图所示，在生产阶段，<strong>MQ通过</strong>最常用的<strong>请求确认机制</strong>（ACK，又是类似TCP），来<strong>保证消息的可靠传输</strong></p><p>当发送消息的方法被调用时，消息队列会把消息发送到Broker，Broker收到消息后会给客户端（此处是Producer）返回一个确认响应（ACK），表明消息已经收到了，客户端收到响应后，就是完成了一次正常的消息发送</p><p>Producer长时间没收到确认响应时，会自动重试；如果重试再失败会告知用户</p><h3 id="存储阶段"><a href="#存储阶段" class="headerlink" title="存储阶段"></a>存储阶段</h3><p>正常情况下，只要Broker正常运行就不会有丢失消息的问题，但是如果Broker出现了故障，如服务器宕机，可能会丢失消息的</p><p><strong>可以通过配置 Broker 参数来避免因为宕机丢消息。</strong></p><p>如配置Broker参数，在收到消息后，<strong>将消息写入磁盘后，再给Producer返回确认响应</strong></p><h3 id="消费阶段"><a href="#消费阶段" class="headerlink" title="消费阶段"></a>消费阶段</h3><p>如图所示，同样为<strong>请求确认机制</strong>保证消息的可靠传输，过程同生产阶段</p><p>但是，<strong>不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。</strong></p><blockquote><p>附：检查 和 添加序号的操作放在拦截器中执行</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MessageQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2024/06/01/KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2024/06/01/KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>前言：之前上算法课 + 自己刷题都遇到过，每次都感叹KMP的巧妙，但是每次都是看过就过了，下次遇到还是感叹“woc nb”，特记录完整的思路</p><h3 id="什么是KMP"><a href="#什么是KMP" class="headerlink" title="什么是KMP"></a>什么是KMP</h3><p>KMP主要应用在字符串匹配上。主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong>、</p><p><strong>前缀</strong>：对于字符串 abcdxxxxxxyz，abcd就是该字符串的一个前缀</p><p><strong>后缀</strong>：对于字符串 abcdxxxxxxyz，xyz就是该字符串的一个后缀</p><h3 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h3><p>也就是KMP中常说的next数组，<strong>用来回退的</strong>，<strong>它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p><span id="more"></span><h3 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h3><p>假设原串为abcababeabf，匹配串为abeabf</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-KMPP1.png" alt="2024-6-1-KMPP1"></p><h4 id="先看不用KMP，会怎么匹配：（暴力，且不用substring）"><a href="#先看不用KMP，会怎么匹配：（暴力，且不用substring）" class="headerlink" title="先看不用KMP，会怎么匹配：（暴力，且不用substring）"></a>先看不用KMP，会怎么匹配：（暴力，且不用substring）</h4><p>首先在 原串和匹配串分割各自有一个指针执行当前匹配的位置（如图的箭头）：</p><p>第一次匹配的出发点是第一个字符 ‘a’，显然后面的字符是相等的，于是向右移动——直到出现第一个不同的位置（红色箭头）</p><p><img src="C:/Users/14505/Desktop/2024-6-1-KMPP2.png" alt="2024-6-1-KMPP2"></p><p>后面的逻辑就是 暴力匹配 和 <strong>KMP</strong> 不同的地方：</p><p><strong>暴力匹配：</strong></p><ol><li>先将原串的指针移动到本次出发点（’a’）的下一个位置 ‘b’，并且匹配串移动到起始位置</li><li>重复之前的步骤，直到能够匹配成功</li></ol><p>也就是说，对于暴力匹配，一旦匹配失败，<strong>之前遍历的内容就作废</strong>了，换一个出发点重新匹配</p><p><strong>时间复杂度</strong>：O(m * n)</p><h4 id="KMP匹配过程"><a href="#KMP匹配过程" class="headerlink" title="KMP匹配过程"></a>KMP匹配过程</h4><p><strong>首先匹配串会检查之前已经匹配成功的部分中里是否存在相同的「前缀」和「后缀」。如果存在，则跳转到「前缀」的下一个位置继续往下匹配：</strong></p><p>如下图，当前（原串和匹配串）匹配成功的部分为 abcab，其中前缀ab和后缀ab相同，所以可以跳转</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-KMPP3.png" alt="2024-6-1-KMPP3"></p><p>跳转到下一匹配位置后，尝试匹配，发现两个指针的字符对不上，并且此时匹配串指针前面 ab 不存在相同的「前缀」和「后缀」，这时候只能回到匹配串的起始位置重新开始。。。（依次进行循环）</p><p><strong>KMP比暴力快的原因：</strong></p><ul><li>KMP利用已匹配的部分中相同的「前缀」和「后缀」来加速下一次的匹配</li><li>KMP的原串不会进行回溯（没有暴力中回到下一个出发点的过程）</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>和常规的暴力相比，KMP增加了检查「前缀」和「后缀」的过程，其目的是「为了确定匹配串中的下一段开始匹配的位置」，所以要考虑如何实现这个检查</p><p>有这么一个结论——<strong>对于匹配串的任意一个位置而言，由该位置发起的下一个匹配点位置其实与原串无关。</strong></p><p>怎么理解呢？</p><p>就拿本文的例子来说，对于匹配串 abeabf 中的字符 f 来说，由它发起的下一个匹配点跳转必然是字符 e 的位置，因为 f 位置的相同「前缀」和「后缀」字符 ab 的下一个位置就是字符 c</p><p>所以要预处理出前缀表——next数组（用于跳转，当前字符i不匹配了，则next[i]就是同前缀的点，是可以跳转的位置）</p><h4 id="next数组的构建"><a href="#next数组的构建" class="headerlink" title="next数组的构建"></a>next数组的构建</h4><p>对于本题的匹配串 aaabbab</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-nextP1.png" alt="2024-6-1-nextP1"></p><p>起始时next[0] &#x3D; 0，j指针从0位置开始，i指针从1位置开始；</p><ul><li><p>如果p[j] &#x3D;&#x3D; p[i]，则next[i] &#x3D; j+1，且 i 和 j 同时向后移动</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-nextP2.png" alt="2024-6-1-nextP2"></p></li><li><p>如果p[j] !&#x3D; p[i]：将j指针指向迁移位置的next数字多对应的位置——j &#x3D; next[j - 1]，并重新判断p[j] !和 p[i]，直到p[j] &#x3D;&#x3D; p[i] 或者 j &#x3D;&#x3D; 0；且j &#x3D;&#x3D; 0时，next[i] &#x3D; 0，之后 j 不动，i 向后移动</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-nextP3.png" alt="2024-6-1-nextP3"></p></li></ul><p>之后就是循环两种情况</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-nextP4.png" alt="2024-6-1-nextP4"></p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-nextP5.png" alt="2024-6-1-nextP5"></p><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KMP 算法实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ss 原串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pp 匹配串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 匹配串在原串中第一次出现的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String ss, String pp)</span> &#123;</span><br><span class="line">    <span class="comment">// 字符串转为char数组方便操作</span></span><br><span class="line">    <span class="type">char</span>[] s = ss.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] p = pp.toCharArray();</span><br><span class="line">    <span class="type">int</span>[] next = getNext(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匹配过程，用i指针指向原串遍历的位置，j指针是匹配串遍历的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != p[j])</span><br><span class="line">            j = next[j - <span class="number">1</span>]; <span class="comment">// 如果不等，则利用next数组进行跳转</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j == p.length) <span class="keyword">return</span> i - p.length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * next数组构建</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] getNext(<span class="type">char</span>[] p) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> p.length;</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完全按照next构建描述中实现</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">// 定义出对应的i j 指针</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j]) j++;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列02：消息队列选型</title>
      <link href="/2024/06/01/MQ02/"/>
      <url>/2024/06/01/MQ02/</url>
      
        <content type="html"><![CDATA[<blockquote><p>你的项目为什么选择用 rocketmq &#x2F; kafka &#x2F; rabbitmq作为消息队列组件？而不是其他的呢？</p></blockquote><p>选择消息队列的前提：开源、不冷门、消息的可靠传递、Cluster、性能好</p><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ul><li><strong>主题（Topic）</strong> ：消息的种类称为主题，可以说一个主题代表了一类消息，相当于是对消息进行分类，主题就像是数据库中的表。</li><li><strong>分区（partition）</strong> ：主题可以被分为若干个分区，同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的伸缩性。</li><li><strong>批次</strong>：为了提高效率， 消息会分批次写入 Kafka，批次就代指的是一组消息</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>Kafka 与周边生态系统的兼容性是最好的没有之</strong>一，尤其在大数据和流计算领域，几乎所有的相关开源软件系统都会优先支持 Kafka。</p><p>Kafka的<strong>性能很高</strong>（不过和RocketMQ没有量级上的差距），几十万条&#x2F;s</p><p>但是是异步批量的设计，导致同步收发消息的响应时延较高（kafka会把消息攒一批发送）——<strong>不适合在线业务场景</strong></p><p>如果你需要处理海量的消息，像收集日志、监控信息或是前端的埋点这类数据，或是你的应用场景大量使用了大数据、流计算相关的开源产品，那 Kafka 是最适合你的消息队列。</p><span id="more"></span><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><ul><li><strong>Name 服务器（NameServer）</strong> ：充当注册中心，类似 Kafka 中的 Zookeeper。</li><li><strong>Broker</strong>: 一个独立的 RocketMQ 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量。</li><li><strong>主题（Topic）</strong> ：消息的第一级类型，一条消息必须有一个 Topic。</li><li><strong>子主题（Tag）</strong> ：消息的第二级类型，同一业务模块不同目的的消息就可以用相同 Topic 和不同的 Tag 来标识。</li><li><strong>分组（Group）</strong> ：一个组可以订阅多个 Topic，包括生产者组（Producer Group）和消费者组（Consumer Group）。</li><li><strong>队列（Queue）</strong> ：可以类比 Kafka 的分区 Partition。</li></ul><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>阿里巴巴使用Java开发的；<strong>没什么突出的优点，也没什么明显的缺点</strong></p><p>优点：<strong>响应时延要求很高的场景，应该选择使用 RocketMQ。</strong></p><p>缺点：与周边生态系统的集成和兼容程度要略逊一筹。</p><p>如果你的系统使用消息队列主要场景是处理在线业务，比如在交易系统中用消息队列传递订单，那 RocketMQ 的低延迟和金融级的稳定性是你需要的。</p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><strong>优点：</strong></p><ol><li>相当轻量级、容易部署和使用（是大多个人项目选择RabbitMQ的主要原因了吧）</li><li>路由配置很灵活</li><li>支持的编程语言很多</li><li>有插件支持延迟消息</li></ol><p><strong>缺点：</strong></p><ol><li>RabbitMQ对消息堆积的支持不好、消息堆积会导致其性能下降</li><li>RabbitMQ的性能是这几个中最差的（但是也够用了）</li><li>RabbitMQ用Erlang写的，小众；不方便扩展</li></ol><p>消息队列并不是你将要构建系统的主角之一，你对消息队列功能和性能都没有很高的要求，只需要一个开箱即用易于维护的产品，建议使用 RabbitMQ</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MessageQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024-6-1-刷题日记</title>
      <link href="/2024/06/01/2024-6-1-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/06/01/2024-6-1-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="Question-1-反转字符串II"><a href="#Question-1-反转字符串II" class="headerlink" title="Question.1 反转字符串II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/description/">Question.1 反转字符串II</a></h4><blockquote><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul></blockquote><p>整体流程如下：</p><ul><li>剩余字符数目 &gt;2*k，则反转前k个，剩余的k个不变</li><li>k &lt;&#x3D; 剩余字符数目 &lt;2*k，则反转前k个，剩余的不变</li><li>剩余字符数目&lt;k，则全部反转</li></ul><p>总结就是：前k个一定要反转，不满k也要反转；反转完成就向后走2*k格</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">char</span>[] ansArray = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无论后面是多少，总要反转前k个，如果不满k就都反转</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(length - <span class="number">1</span>, start + k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> ansArray[start];</span><br><span class="line">            ansArray[start] = ansArray[end];</span><br><span class="line">            ansArray[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ansArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-2-找出字符串中第一个匹配项的下标"><a href="#Question-2-找出字符串中第一个匹配项的下标" class="headerlink" title="Question.2 找出字符串中第一个匹配项的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">Question.2 找出字符串中第一个匹配项的下标</a></h4><blockquote><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p></blockquote><p>很容易想到，一个个匹配的暴力解法。</p><p>但是可以用字符串匹配算法——<a href="http://yhy1031.cn/2024/06/01/KMP%E7%AE%97%E6%B3%95/">KMP</a></p><h4 id="Question-3-重复的子字符串"><a href="#Question-3-重复的子字符串" class="headerlink" title="Question.3 重复的子字符串"></a><a href="https://leetcode.cn/problems/repeated-substring-pattern/">Question.3 重复的子字符串</a></h4><blockquote><p>给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p></blockquote><p>（自己不会KMP时，用的substring）</p><p>同理，使用KMP算法，但是要明白这个题目的转换</p><p>题目问该字符串是否可以通过由它的一个子串重复多次构成，如果直接用kmp，那么就要不停的分割来用，不合适</p><p>所以就有s+s（去除第一个元素和最后一个元素），来匹配s，</p><p>去除首尾之后，就不会匹配到第一个s和第二个s了</p><p>（代码去看KMP，唯一不一样的为<code>for (int i = 1, j = 0; i &lt; s.length - 1; i++)</code>）</p>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024-5-30-刷题日记</title>
      <link href="/2024/05/30/2024-5-30-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/05/30/2024-5-30-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="Question-1-快乐数"><a href="#Question-1-快乐数" class="headerlink" title="Question.1 快乐数"></a><a href="https://leetcode.cn/problems/happy-number/description/">Question.1 快乐数</a></h4><blockquote><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p></blockquote><p>这道题还是挺意思的</p><p><strong>解析如下：</strong></p><p>对于一个数字来说，每个数的平方和显然不会不会一直增大，如9999-&gt;324，表明四位数的平方和最大值为324，所以一个比较大的数是必定会往下掉的</p><p><strong>所以n只有两种情况：</strong>要分析为什么会返回false</p><ol><li>最后变为1</li><li>在一个不大的数字243（999的平方和）以下循环，返回false</li></ol><p>所以，本题就转变成一个链表判断是否有环的题目了</p><span id="more"></span><ol><li><p><strong>常规的HashSet解法</strong>（每次结果塞进去，直到出现1 or 重复）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !seen.contains(n))&#123;</span><br><span class="line">        seen.add(n);</span><br><span class="line">        n = getNext(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">        totalSum += d * d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>快慢指针</strong></p><p>如之前链表的题目，一块一满两个指针，一定会相遇（如<a href="http://yhy1031.cn/2024/05/28/leetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/">环形链表II</a>）</p><p>对于判断条件<code>fastRunner != 1</code>，因为fastrunner跑得快，且如果为1，则下次的 getNext(n) 还是为1，所以用fastrunner是很合适的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slowRunner</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fastRunner</span> <span class="operator">=</span> getNext(n);</span><br><span class="line">    <span class="keyword">while</span> (fastRunner != <span class="number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;</span><br><span class="line">        slowRunner = getNext(slowRunner);</span><br><span class="line">        fastRunner = getNext(getNext(fastRunner));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fastRunner == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">        totalSum += d * d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Question-2-两数之和"><a href="#Question-2-两数之和" class="headerlink" title="Question.2 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/description/">Question.2 两数之和</a></h4><p>map的应用，（关于map的内容可以看，<a href="http://yhy1031.cn/2024/05/27/Java%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">我的文章</a>）</p><p>主要是用到了containsKey方法，判断是否能组成目标和，不能就把当前的数组值放进map中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">complement</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; map.get(complement), i &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-3-四数相加II"><a href="#Question-3-四数相加II" class="headerlink" title="Question.3 四数相加II"></a><a href="https://leetcode.cn/problems/4sum-ii/description/">Question.3 四数相加II</a></h4><p>上面这题的plus版本</p><p>思路也是一样的，定义一个map去存就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">            map.put(i + j, map.getOrDefault(i + j, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> -i - j;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum))</span><br><span class="line">                res += map.get(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-4-赎金信"><a href="#Question-4-赎金信" class="headerlink" title="Question.4 赎金信"></a><a href="https://leetcode.cn/problems/ransom-note/description/">Question.4 赎金信</a></h4><p>和之前的有效的<a href="https://leetcode.cn/problems/valid-anagram/description/">字母异位词</a>比较像，都是定义一个字母表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lengthRansomNote</span> <span class="operator">=</span> ransomNote.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">lengthMagazine</span> <span class="operator">=</span> magazine.length();</span><br><span class="line">    <span class="keyword">if</span> (lengthRansomNote &gt; lengthMagazine)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lengthMagazine; i++) &#123;</span><br><span class="line">        array[magazine.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lengthRansomNote; i++) &#123;</span><br><span class="line">        array[ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span> (array[ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-5-三数之和"><a href="#Question-5-三数之和" class="headerlink" title="Question.5 三数之和"></a><a href="https://leetcode.cn/problems/3sum/description/">Question.5 三数之和</a></h4><blockquote><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p></blockquote><p>乍一看挺吓人的，不让重复，还要和为0，还要拿到结果组成的List</p><p>但是仔细一看，要返回的是值组成的List，而不是下标，所以可以放心的对数组进行操作了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; length - <span class="number">2</span>; k++) &#123;</span><br><span class="line">        <span class="comment">// 第一个一定要是负数</span></span><br><span class="line">        <span class="keyword">if</span> (nums[k] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>, j = length - <span class="number">1</span>;<span class="comment">// 从左右向中间遍历（i只能向右，nums[i]只能变大，j只能向左，nums[j]只能变小）</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[k] + nums[i] + nums[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 整体小了，需要让i向左移</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i])</span><br><span class="line">                    ;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 整体大了，需要j向右移</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j])</span><br><span class="line">                    ;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(nums[k], nums[i], nums[j])));</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j])</span><br><span class="line">                    ;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i])</span><br><span class="line">                    ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-6-四数之和"><a href="#Question-6-四数之和" class="headerlink" title="Question.6 四数之和"></a><a href="https://leetcode.cn/problems/4sum/description/">Question.6 四数之和</a></h4><blockquote><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul></blockquote><p>这个一看，岂不是和上面的题一样嘛，不要下标，不相同，目标和固定，思路相同嘛</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; length - <span class="number">3</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[k + <span class="number">1</span>] + nums[k + <span class="number">2</span>] + nums[k + <span class="number">3</span>] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 后面只会更大</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再嵌套一个三数之和 哈哈哈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> k + <span class="number">1</span>; j &lt; length - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; k + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>, right = length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[k] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[k], nums[j], nums[left], nums[right]));</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[++left])</span><br><span class="line">                        ;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[--right])</span><br><span class="line">                        ;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[++left])</span><br><span class="line">                        ;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[--right])</span><br><span class="line">                        ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM模式——Scanner方法</title>
      <link href="/2024/05/28/ACM%E6%A8%A1%E5%BC%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Scanner%E6%96%B9%E6%B3%95/"/>
      <url>/2024/05/28/ACM%E6%A8%A1%E5%BC%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Scanner%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Scanner类是Java标准库提供的一个用于读取输入的类。它可以通过不同的方法从标准输入、文件和字符串等来源读取数据。</p><p>要使用Scanner类，需要先导入java.util包。然后，可以创建一个Scanner对象，并将输入源传递给它进行读取。</p><p>Scanner对象创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="next-与-nextLine"><a href="#next-与-nextLine" class="headerlink" title="next() 与 nextLine()"></a>next() 与 nextLine()</h3><p>两者都是用来读取字符串的</p><p> <strong>next():</strong></p><ul><li>1、一定要读取到有效字符后才可以结束输入。</li><li>2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。</li><li>3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li><li>4、next() 不能得到带有空格的字符串</li></ul><p><strong>nextLine()：</strong></p><ul><li>1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li><li>2、可以获得空白。</li><li>可以用nextLine()方法，只实现换行而不赋值</li></ul><h3 id="常见场景："><a href="#常见场景：" class="headerlink" title="常见场景："></a>常见场景：</h3><p>单行，多行，数值，字符串</p><h4 id="1-单行输入多个参数"><a href="#1-单行输入多个参数" class="headerlink" title="1. 单行输入多个参数"></a>1. 单行输入多个参数</h4><p>以空格等符号进行分割</p><p><strong>输入如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABB CCC DDD  EEE <span class="number">123</span> <span class="number">435</span></span><br></pre></td></tr></table></figure><p><strong>程序如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myScanner</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;输入：&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine();  <span class="comment">// 读取一行</span></span><br><span class="line">System.out.println(<span class="string">&quot;输出：&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">String[] strIn = str.trim().split(<span class="string">&quot; &quot;</span>);  <span class="comment">// 以空格分割</span></span><br><span class="line">System.out.println(Arrays.toString(strIn));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-多行输入多个参数，每行参数个数不定"><a href="#2-多行输入多个参数，每行参数个数不定" class="headerlink" title="2. 多行输入多个参数，每行参数个数不定"></a>2. 多行输入多个参数，每行参数个数不定</h4><p>多行输入元素，其中第一行几个数字表示下面几行的个数，每行可能输入不等数量的参数</p><p>以三行输入为例，第一行输入两个数字m，n，分别表示数组num1和num2的长度，第二行和第三行输入num1和num2的元素，以空格分隔。</p><p><strong>输入如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">10</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">11</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>程序如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Scanner2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;输入：&quot;</span>);</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">// 换成其他数据类型也一样，其他数值类型就修改int跟nextInt就可以了，</span></span><br><span class="line">        <span class="comment">//String就把nextInt()换成next()</span></span><br><span class="line">        </span><br><span class="line">System.out.println(m);</span><br><span class="line">System.out.println(n);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] num1 = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"><span class="type">int</span>[] num2 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">num1[i] = sc.nextInt();  <span class="comment">// 一个一个读取</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(num1));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">num2[i] = sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(num2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：句子缩写"><a href="#例题：句子缩写" class="headerlink" title="例题：句子缩写"></a>例题：<a href="https://kamacoder.com/problempage.php?pid=1013">句子缩写</a></h3><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-8-T14P1.png" alt="2024-7-8-T14P1"></p><p>整个代码以及代码逻辑是很简单的，不过其中“单词之间可能有多个空格”，需要使用正则表达式来分割<code>String[] inputStr = input.split(&quot;\\s+&quot;);</code></p><p>根据本题的输入模式：n + n行，肯定需要有一个<code>int n = in.nextInt(); </code>，之后需要输入题目的词组，而<strong>两者之间一定要换行</strong>，执行<code>in.nextLine();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt(); </span><br><span class="line">        in.nextLine(); <span class="comment">// 重要！！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">            String[] inputStr = input.split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; inputStr.length; j++) &#123;</span><br><span class="line">                System.out.print(Character.toUpperCase(inputStr[j].charAt(<span class="number">0</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次笔试之后的碎碎念</title>
      <link href="/2024/05/28/%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AF%95%E4%B9%8B%E5%90%8E%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2024/05/28/%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AF%95%E4%B9%8B%E5%90%8E%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>嗐</p><p>时至今日，多次笔试之后，面对ACM模式的代码题还是不大行</p><p>就拿今天的笔试举例，如果不是ACM模式，第一道题30min就AC了，但是因为对Scanner不熟悉，不懂各种读取数据方式的区别。</p><p>本想着最近算法题练的很多了，可以多A几道题，但是不会Scanner。。。。。。折戟沉沙了</p><p>做完第一道题之后心态就不对了。。（真被别人说对了，不练就是不行！！）</p><p>之后还是好好练吧，特别是ACM模式，最近的三次笔试都是ACM模式，但是没练过（自己的问题）</p><p>明天好好看一下相关的内容</p><p>Good Night guys~~</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列01：消息队列基础 &amp; 应用场景</title>
      <link href="/2024/05/28/MQ01/"/>
      <url>/2024/05/28/MQ01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>你的项目为什么用到消息队列？起到什么作用？</p></blockquote><h2 id="消息队列基础"><a href="#消息队列基础" class="headerlink" title="消息队列基础"></a>消息队列基础</h2><p><strong>消息队列是在消息的传输过程中保存消息的容器</strong>，用于接收消息并以文件的方式存储，<strong>一个消息队列可以被一个也可以被多个消费者消费</strong>，包含以下 3 元素：</p><ul><li><strong>Producer：消息生产者</strong>，负责产生和发送消息到 Broker；</li><li><strong>Broker：消息处理中心</strong>，负责消息存储、确认、重试等，一般其中会包含多个 Queue；</li><li><strong>Consumer：消息消费者</strong>，负责从 Broker 中获取消息，并进行相应处理。</li></ul><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/image-20240601180428745.png" alt="image-20240601180428745"></p><p>消息队列包括两种模式——点对点、发布&#x2F;订阅</p><ul><li><p><strong>点对点模式</strong>：多个生产者可以向同一个消息队列发送消息，一个具体的消息只能由一个消费者消费。（不可重复消费）</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-MQP1.png" alt="2024-6-1-MQP1"></p></li><li><p><strong>发布&#x2F;订阅模式</strong>：单个消息可以被多个订阅者并发的获取和处理。</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-MQP2.png" alt="2024-6-1-MQP2"></p></li></ul><span id="more"></span><h2 id="消息队列的应用场景"><a href="#消息队列的应用场景" class="headerlink" title="消息队列的应用场景"></a>消息队列的应用场景</h2><p>消息队列最常被使用的三种场景：<strong>异步处理</strong>、<strong>服务解耦</strong>和<strong>流量控制</strong>（削峰）</p><p><strong>基本上一切消息队列的应用场景，都是围绕异步、解耦和削峰三个特性来设计的</strong>。反过来也可以说，如果你有一些需要异步、解耦和削峰的需求，那么消息队列就是最合适的工具。</p><p>用秒杀系统深入理解消息队列的作用</p><h3 id="流量控制、削峰——削去秒杀场景下的峰值写流量"><a href="#流量控制、削峰——削去秒杀场景下的峰值写流量" class="headerlink" title="流量控制、削峰——削去秒杀场景下的峰值写流量"></a>流量控制、削峰——削去秒杀场景下的峰值写流量</h3><p>如果没有消息队列，在秒杀场景下，短时间之内数据库的写流量会很高，如果仅对数据做分库分表、数据迁移、活动结束后的缩表则过于麻烦了！！</p><p>所以引入消息队列，来抗住海量的流量——<strong>将秒杀请求暂存在消息队列中，然后业务服务器会响应用户“秒杀结果正在计算中”，释放了系统资源之后再处理其它用户的请求</strong></p><p>我们可以在后台启动多个队列处理程序，执行后续的消费等程序（但是处理程序有限，如果请求过多队列会满，则超出的请求就会被丢弃）</p><p>这就是消息队列在秒杀系统中最主要的作用：<strong>削峰填谷，</strong>也就是说它可以削平短暂的流量高峰，虽说堆积会造成请求被短暂延迟处理，但是只要我们时刻监控消息队列中的堆积长度，在堆积量超过一定量时，增加队列处理机数量，来提升消息的处理能力就好了。（这种设计的优点是：能根据下游的处理能力自动调节流量）</p><h3 id="异步处理——通过异步处理简化秒杀请求中的业务流程"><a href="#异步处理——通过异步处理简化秒杀请求中的业务流程" class="headerlink" title="异步处理——通过异步处理简化秒杀请求中的业务流程"></a>异步处理——通过异步处理简化秒杀请求中的业务流程</h3><p>秒杀场景下，<strong>会有主要的业务逻辑，也会有次要的业务逻辑：</strong>比如说，主要的流程是生成订单、扣减库存；次要的流程可能是我们在下单购买成功之后会给用户发放优惠券，会增加用户的积分等。</p><p>所以当服务端完成前面 2 个步骤，确定本次请求的秒杀结果后，就可以马上给用户返回响应，然后把请求的数据放入消息队列中，由消息队列异步地进行后续的操作。</p><p><strong>消息队列被用于实现服务的异步处理。</strong>这样做的好处是：</p><ul><li>可以更快地返回结果；</li><li>减少等待，自然实现了步骤之间的并发，提升系统总体的性能。</li></ul><h3 id="服务解耦——解耦实现秒杀系统模块之间松耦合"><a href="#服务解耦——解耦实现秒杀系统模块之间松耦合" class="headerlink" title="服务解耦——解耦实现秒杀系统模块之间松耦合"></a>服务解耦——解耦实现秒杀系统模块之间松耦合</h3><p>使用消息队列降低业务系统和数据系统的直接耦合度。</p><p>订单服务在订单变化时发送一条消息到消息队列的一个主题 Order 中，所有下游系统都订阅主题 Order，这样每个下游系统都可以获得一份实时完整的订单数据。</p><h3 id="面试题：为什么一定要用消息队列呢？同步调用不行吗"><a href="#面试题：为什么一定要用消息队列呢？同步调用不行吗" class="headerlink" title="面试题：为什么一定要用消息队列呢？同步调用不行吗"></a>面试题：为什么一定要用消息队列呢？同步调用不行吗</h3><p>其实就是在问：<strong>在这个业务场景下，不异步、不解耦或者不削峰会有什么问题</strong>？</p><ol><li><p><strong>不异步</strong>——<strong>性能差</strong></p><p>因为需要停下来等全部调用完成才可以返回响应。</p><ul><li><p>追问：但是我可以并发调用啊~</p><p>在并发调用的情况下，性能取决于最坏的那个同步调用什么时候返回结果。而正常我们丢一个消息到消息中间件上是很快的。</p><p>但是即便性能损耗可以接收，但是扩展性和可用性就不行了</p></li></ul></li><li><p><strong>不解耦</strong>——扩展性</p><p>在使用消息队列的方案中，新增的下游只需要订阅对应的消息队列就行了；但是同步调用需要新增的下游提供一堆东西很麻烦</p><ul><li>在使用消息队列的情况下，消息发送者完全不关心谁会去消费这些消息。同样地，如果有一个新的业务方要订阅这个消息，它可以自主完成。</li><li>同步调用的时候，上游必须知道下游的接口，然后要知道如何构造请求、如何解析响应，还要联调、测试、上线，整个过程都得和下游密切合作，因此效率特别低，可扩展性很差。</li></ul></li><li><p><strong>不削峰</strong>——可用性</p><p>在使用消息队列的方案中，只需要确保自己把消息发送到了消息队列上，就认为操作已经成功了。（容错高）</p><p>但是，在同步调用方案中，你必须要确保调用所有的下游都成功了才算是成功了。所以你还需要额外考虑部分成功部分失败的问题。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MessageQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetCode_142_环形链表II</title>
      <link href="/2024/05/28/leetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/"/>
      <url>/2024/05/28/leetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/</url>
      
        <content type="html"><![CDATA[<p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</br><br>如下为修改示例：</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/LeetCode142P1.png" alt="LeetCode142P1"></p><span id="more"></span><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>假设入环前长度为 lengthPre，环的长度为lengthCycle，满指针遍历的节点数为 s，快指针遍历的节点数为 f</p><p>想要找到入环的节点，也就是遍历 lengthPre + k * lengthCycle个节点可以到达，</p><p><strong>相遇情况分析：</strong></p><ol><li><p>fast指针和slow指针不会相遇——fast指针遍历到null，则无环</p></li><li><p><strong>fast &#x3D;&#x3D; slow也即首次相遇</strong>，则 <strong>f &#x3D; 2s</strong> 且 快指针在环中一直在套圈，所以 <strong>f &#x3D; s + n * lengthCycle</strong>——可以得到 f &#x3D; 2n * lengthCycle，s &#x3D; n * lengthCycle</p><p>也就是说，如果<strong>让慢指针（快指针也OK）再走lengthPre长度</strong>，就能凑成lengthPre + k * lengthCycle，到入环节点了</p><p>那么怎么找到这个lengthPre长度呢？那还得是双指针啊！</p></li><li><p><strong>第二次相遇流程</strong></p><ul><li>第一次相遇之后，让快指针重新指向链表头</li><li>每轮快慢指针都只走一个节点</li><li>当走了lengthPre步之后，两者同时到入环节点——再次相遇，且此处为入环节点</li></ul></li></ol><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            <span class="comment">// 第一次相遇</span></span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第二次相遇</span></span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or 下面的可能逻辑更清晰一点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024-5-28-刷题日记</title>
      <link href="/2024/05/28/2024-5-28-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/05/28/2024-5-28-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>（捅了链表的老巢了。。。。）</p><h4 id="Question-1-反转链表"><a href="#Question-1-反转链表" class="headerlink" title="Question.1 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">Question.1 反转链表</a></h4><p>常规思路迭代还是挺简单的，选节点+头插法阿巴阿巴~~但是借助了外部空间</p><p>下面是一种<strong>原地反转</strong>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义pre、cur、tmp节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 当前遍历节点的前节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head; </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 临时存储后序的节点</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        tmp = cur.next;</span><br><span class="line">        cur.next = pre; <span class="comment">// 改变了链表的箭头方向</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是题目说可以尝试<strong>递归</strong>，感谢大佬的题解：<a href="https://leetcode.cn/problems/reverse-linked-list/solutions/36710/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">https://leetcode.cn/problems/reverse-linked-list/solutions/36710/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/</a></p><span id="more"></span><p><strong>主要思路：</strong></p><ul><li>也是将指针改为指向前一个node，但是具体实现为：<code>head.next.next = head;</code>（对应的node是head.next，将其指针改为指向head）</li><li>因为是递归，肯定是进入最底层再回溯；所以是从尾部向前反转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) &#123; <span class="comment">// head==null专门为head为空设计的</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的cur就是最后一个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    <span class="comment">//防止链表循环，需要将head.next设置为空</span></span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-2-两两交换链表中的节点"><a href="#Question-2-两两交换链表中的节点" class="headerlink" title="Question.2 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">Question.2 两两交换链表中的节点</a></h4><p>正好用到了递归的思想，和Q1中的思想挺符合的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 这道题好像递归好一点</span></span><br><span class="line">    <span class="keyword">while</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> swapPairs(head.next.next);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    head.next = tail;</span><br><span class="line">    temp.next = head;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-3-删除链表的倒数第-N-个结点"><a href="#Question-3-删除链表的倒数第-N-个结点" class="headerlink" title="Question.3 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">Question.3 删除链表的倒数第 N 个结点</a></h4><p>这个题是我第一次面试出的算法题，印象很深——双指针嘛</p><p>很经典的双指针题目，用双指针实现对倒数第n个元素这个条件进行替换，n + length &#x3D; length + n，所以最后剩下的正好是n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        right = right.next; <span class="comment">// 到了第n-1个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right.next != <span class="literal">null</span>) &#123; <span class="comment">//</span></span><br><span class="line">        right = right.next;</span><br><span class="line">        left = left.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 期望找到倒数第n+1个元素，进行删除操作</span></span><br><span class="line">    left.next = left.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-4-链表相交"><a href="#Question-4-链表相交" class="headerlink" title="Question.4 链表相交"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">Question.4 链表相交</a></h4><p>同为双指针，找相同关系：lengthA + length同 + lengthB &#x3D; lengthB + length同 + lengthA，如果有相交则，一定会有相等的点</p><p>特别厉害的思路和实现逻辑：</p><ul><li>如果不相交，则 <code>lengthA+lengthB = lengthB + lengthA</code> or <code>lengthA = lengthB</code> 两者长度一样，肯定会同时为null，也即相等，跳出循环</li><li>如果相交，则同理，<code>lengthA + length同 + lengthB = lengthB + length同 + lengthA</code>，之后一定是相同的，或者<code>lengthA = lengthB</code>则会提前相交</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> headA;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> headB;</span><br><span class="line">    <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">        left = left == <span class="literal">null</span> ? headB : left.next;</span><br><span class="line">        right = right == <span class="literal">null</span> ? headA : right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-5-环形链表-II"><a href="#Question-5-环形链表-II" class="headerlink" title="Question.5 环形链表 II"></a><a href="http://yhy1031.cn/2024/05/28/leetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/">Question.5 环形链表 II</a></h4><p>同为双指针，快慢指针（点击标题看详解~）</p><h4 id="Question-6-有效的字母异位词"><a href="#Question-6-有效的字母异位词" class="headerlink" title="Question.6 有效的字母异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/description/">Question.6 有效的字母异位词</a></h4><p>平平无奇 字母表</p><h4 id="Question-7-两个数组的交集"><a href="#Question-7-两个数组的交集" class="headerlink" title="Question.7 两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">Question.7 两个数组的交集</a></h4><p>同理，平平无奇，用Set就行，但是有一点：</p><p>如果是Set转为数组的话是不能直接转为基本数据类型的，如int等，只能是String、Integer等包装类</p><p>只能一个个取出对应的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ansArray = <span class="keyword">new</span> <span class="title class_">int</span>[ans.size()]; <span class="comment">//ans是hashSet</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : ans) &#123;</span><br><span class="line">    ansArray[index++] = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列起始</title>
      <link href="/2024/05/27/introduceOfMQ/"/>
      <url>/2024/05/27/introduceOfMQ/</url>
      
        <content type="html"><![CDATA[<p>吸取之前面试美团金融的经验，开始学习消息队列的内容</p><blockquote><p>还记得当时面试官给我出了一道场景题：消息队列中如何避免一个消息被重复消费？</p></blockquote><p>带着这个问题去学习MQ</p><p>老生常谈的两个问题：消息队列是什么？为什么要用消息队列（解决了什么问题）？</p><p><strong>消息队列可以看作暂时存储数据的一个容器，消息队列是一个平衡低速系统和高速系统处理任务时间差的工具</strong></p><p>基本上一切消息队列的应用场景，都是围绕异步、解耦和削峰三个特性来设计的。反过来也可以说，如果你有一些需要异步、解耦和削峰的需求，那么消息队列就是最合适的工具。</p><blockquote><p>PS：博主目前还没有具体用过消息队列，之后用了会具体补充某些部分</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java容器部分知识点总结（未完待续）</title>
      <link href="/2024/05/27/Java%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2024/05/27/Java%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="一、通用"><a href="#一、通用" class="headerlink" title="一、通用"></a>一、通用</h3><p>分为Collection（存对象） 和 Map（存两个对象之间映射表），两种接口</p><p>如List、Set等都是接口，ArrayList、HashSet、HashMap等才是实现类，所以初始化对象，如<code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code>可以体现出Java中的多态</p><p>java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。</p><span id="more"></span><h3 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h3><p>以键值对的形式存储和操作数据的容器类型</p><p>主要包括四种实现类：TreeMap、HashMap、LinkedHashMap、HashTable</p><p><strong>TreeMap</strong>——基于<strong>红黑树</strong>实现的一种提供顺序访问的Map（中序遍历）</p><h4 id="HashMap："><a href="#HashMap：" class="headerlink" title="HashMap："></a>HashMap：</h4><ul><li>基于散列表，访问速度快。进行 put 或者 get 操作，可以达到常数时间的性能。</li><li>HashMap最多只允许一条记录的键Key为null；但允许多条记录的值Value为null。</li><li>HashMap中节点数据（Java7中为Entry，Java8中是Node），包含key、value、hash、next四个值</li></ul><ol><li><p><strong>Java7 &amp; HashMap——数组+链表</strong></p><p><strong>数据结构</strong>：数组buckets表示hash值数组，链表用于解决元素的hash冲突</p><p><strong>初始化</strong>：指定buckets的初始容量（默认为16）、负载因子（默认为0.75），若entry数量超过 容量*负载因子则需要扩容并重新hash，扩容为原来二倍</p><p><strong>get()方法</strong>：用于找到指定key的value。该方法调用getEntry(key)获取entry，再由entry.getValue()得到value，所以getEntry是核心（hash算buckets下标，在遍历冲突链条即可）</p><p><strong>put()方法</strong>：将指定的key-value对添加到map中。该方法首先会在map中查询该键值对，如果没有则addEntry头插到对应位置（插入之后要判断是否需要扩容）</p><p><strong>remove()方法</strong>：删除。。</p></li><li><p><strong>Java8 &amp; HashMap——数组+链表+红黑树</strong></p><p>降冲突链查询过程中的开销，引入红黑树——当<strong>容量达到64</strong>，且<strong>链表中的元素达到8个</strong>时，则链表转为红黑树，时间复杂度为O(logN)</p><p>但是只有小于6个时才会转回来</p></li></ol><p><strong>LinkedHashMap</strong>——HashMap的子类，但链表为双向链表维护元素的顺序（插入 or LRU）</p><p><strong>HashTable</strong>——并发安全但不如ConcurrentHashMap效率高，正常又不如HashMap，尽量不用</p><h3 id="三、List"><a href="#三、List" class="headerlink" title="三、List"></a>三、List</h3><p>顺序储存，允许重复</p><p>主要包括三种实现类：ArrayList、LinkedList、Vector（线程安全，但不推荐使用）</p><ul><li><p><strong>ArrayList</strong>：数组（动态数组）——查询效率高但插入效率低</p><p>有两个参数：</p><ul><li>size 当前实际存储的元素个数；</li><li>capacity 表示数组能容纳的元素个数（初始为0，第一次插入后为10）</li></ul><p><strong>扩容</strong>，每次插入前先看当前数组是否能容纳所有元素，如果不能则扩容——创建一个capacity是原来1.5倍的新数组，将现有数组的数据拷贝到新数组中（要尽量避免扩容的操作！！）</p></li><li><p><strong>LinkedList</strong>：双向链表（正常的双向链表）</p><p>但是要明确一点，如Queue也有LinkedList的实现类，但是两者是不一样的！！</p></li></ul><h3 id="四、Set"><a href="#四、Set" class="headerlink" title="四、Set"></a>四、Set</h3><p>不允许重复</p><p>主要包括三种实现类：TreeSet、HashSet、LinkedHashSet（仔细观察会发现和Map的很像）</p><p><strong>TreeSet</strong>——红黑树，自然顺序访问（自然顺序：调用对象的compareTo方法进行比较，升序排列）</p><p><strong>HashSet</strong>——套壳HashMap（Value统一为常量PRESENT）</p><p>LinkedHashSet——套壳LinkedHashMap（同理）</p><h3 id="五、Queue"><a href="#五、Queue" class="headerlink" title="五、Queue"></a>五、Queue</h3><p>主要是PriorityQueue——优先级队列（详见本人的其他Blog：<a href="http://yhy1031.cn/2024/07/23/Java%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"><strong>用法介绍</strong></a>、<a href="http://yhy1031.cn/2024/07/23/2024-7-23-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"><strong>习题示例</strong></a>）</p><p>Deque（双端队列，Queue的子接口）其实现类：LinkedList、ArrayDeque</p><h3 id="六、其他总结"><a href="#六、其他总结" class="headerlink" title="六、其他总结"></a>六、其他总结</h3><h4 id="Tip0：List、Set、Map之间的区别"><a href="#Tip0：List、Set、Map之间的区别" class="headerlink" title="Tip0：List、Set、Map之间的区别"></a>Tip0：List、Set、Map之间的区别</h4><table><thead><tr><th>比较项目</th><th>List</th><th>Set</th><th>Map</th></tr></thead><tbody><tr><td>继承接口</td><td>Collection</td><td>Collection</td><td>就是自己（没有继承）</td></tr><tr><td>常见实现类</td><td>ArrayList、LinkedList、Vector（继承自AbstractList）</td><td>HashSet、LinkedHashSet、TreeSet（继承自AbstractSet）</td><td>HashMap、HashTable</td></tr><tr><td>常见方法</td><td>add()、remove()、clear()、get()、contains()、size()</td><td>add()、remove()、clear()、contains()、size()</td><td>put()、get()、remove()、clear()、containsKey()、containsValue()、keySet()、values()、size()、</td></tr><tr><td>元素特性</td><td>可重复</td><td>不可重复（使用equals判断）</td><td>不可重复</td></tr><tr><td>顺序</td><td>有序</td><td>无序（实际上用HashCode决定）</td><td></td></tr></tbody></table><h4 id="Tip1：List-和-Queue的区别"><a href="#Tip1：List-和-Queue的区别" class="headerlink" title="Tip1：List 和 Queue的区别"></a>Tip1：List 和 Queue的区别</h4><p><strong>List</strong>：更适合在需要频繁索引访问和控制元素精确位置的场景中使用。</p><p><strong>Queue</strong>：更适合在需要管理按特定顺序处理元素的场景中使用，如在多线程环境中管理任务的分发。</p><h4 id="Tip2：容器中的排序问题"><a href="#Tip2：容器中的排序问题" class="headerlink" title="Tip2：容器中的排序问题"></a>Tip2：容器中的排序问题</h4><p>容器中的排序可以分为3类：无序、插入顺序、大小顺序</p><ul><li>HashMap是无序的</li><li>ArrayList是插入顺序，但是可以通过sort方法对已有元素进行排序（改为了大小排序）</li><li>TreeMap可以根据key进行自定义的大小排序（指定Comparator）</li><li>LinkedHashMap默认是插入顺序，也可以初始化时指定为LRU顺序</li></ul><h4 id="Tip3：其他常用方法：-待补充，记录自己想用但不知道的方法"><a href="#Tip3：其他常用方法：-待补充，记录自己想用但不知道的方法" class="headerlink" title="Tip3：其他常用方法：(待补充，记录自己想用但不知道的方法)"></a>Tip3：其他常用方法：(待补充，记录自己想用但不知道的方法)</h4><ul><li><p><strong>数组和List转换</strong></p><ul><li><p><strong>数组转list</strong>：<code>Arrays.asList(array)</code>不推荐，如果硬要用的话需要数组为包装类数组（基本数据类型不能放进容器中，见文章开头），而且不能对新List进行修改；</p><p>如果硬要用就<code>List&lt;XXX&gt; list = new ArrayList&lt;&gt;(Arrays.asList(array))</code></p><p>详见 <a href="https://www.jianshu.com/p/2b113f487e5e">https://www.jianshu.com/p/2b113f487e5e</a></p></li><li><p><strong>List转数组</strong>：使用List中的toArray方法，<code>list.toArray()</code>，同样如果是ArrayList&lt;Integer&gt;的数组转int数组，也会因为是包装类而不能直接转换，尝试使用<code>inputList.stream().mapToInt(i -&gt; i).toArray()</code></p></li></ul></li><li><p><strong>在map中匹配，有则+1，无则新建</strong>：<code>map.getOrDefault(key, defaultValue;</code>，即<code>map.put(key, map.getOrDefault(key, 0) + 1);</code></p></li></ul><h4 id="Tip4：Iterator遍历"><a href="#Tip4：Iterator遍历" class="headerlink" title="Tip4：Iterator遍历"></a>Tip4：Iterator遍历</h4><p>注意，如果是某些自定义类，需要操作其中的多个元素，则需要单独获取，而不能直接用<code>it.next()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Rectangle&gt; it = qAsc.iterator();</span><br><span class="line">Rectangle output;</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    output = it.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;长：&quot;</span> + output.x + <span class="string">&quot;宽：&quot;</span> + output.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024.5.27 刷题日记</title>
      <link href="/2024/05/27/2024-5-27-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/05/27/2024-5-27-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="Question-1-二分查找"><a href="#Question-1-二分查找" class="headerlink" title="Question.1 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/description/">Question.1 二分查找</a></h4><p>一道比较简单的题目，但是看到一个比较有趣的评论：</p><blockquote><p>有一天小明到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把小明拦下，要检查一下哪本书没有登记出借。小明正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是小明背着剩下的书走了。 从此，图书馆丢了 N - 1本书。</p></blockquote><p>二分的本质是由mid分出的两部分分别整体满足不同的性质，对于有序数组就是与目标值的大小关系，对于图书测试就是是否会引起警报</p><p>同时也提了一个醒——二分法的应用场景：有序且唯一</p><span id="more"></span><h4 id="Question-2-移除元素"><a href="#Question-2-移除元素" class="headerlink" title="Question.2 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">Question.2 移除元素</a></h4><p><strong>经典双指针问题</strong>，分为两种：</p><ol><li>快慢指针：一个指针快速向前遍历，另一个指针指向要替换的位置</li><li>左右指针：右侧指针来替换左侧指针可以替换的位置</li></ol><h4 id="Question-3-有序数组的平方-Question-4-长度最小的子数组"><a href="#Question-3-有序数组的平方-Question-4-长度最小的子数组" class="headerlink" title="Question.3 有序数组的平方 &amp;&amp; Question.4 长度最小的子数组"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">Question.3 有序数组的平方</a> &amp;&amp; <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">Question.4 长度最小的子数组</a></h4><p>均为双指针问题</p><h4 id="Question-5-螺旋矩阵II"><a href="#Question-5-螺旋矩阵II" class="headerlink" title="Question.5 螺旋矩阵II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">Question.5 螺旋矩阵II</a></h4><p>定义出对应的边界，一层一层的遍历就行了，不用想的那么复杂（找规律什么的）</p><h4 id="Question-6-移除链表元素"><a href="#Question-6-移除链表元素" class="headerlink" title="Question.6 移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">Question.6 移除链表元素</a></h4><p>链表题目经验：<strong>能不对head操作就不对head操作</strong></p><ul><li>应对方法 1：定义一个dummyHead作为头节点，如<code>ListNode dummyHead = new ListNode(0, head);</code></li><li>应对方案 2：直接新建一个临时头，如<code>ListNode temp = head;</code></li></ul><h4 id="Question-7-设计链表"><a href="#Question-7-设计链表" class="headerlink" title="Question.7 设计链表"></a><a href="https://leetcode.cn/problems/design-linked-list/description/">Question.7 设计链表</a></h4><p>可以直接用ListNode类。。。。 平平无奇的一道题</p>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo&amp;next部署流程</title>
      <link href="/2024/05/26/hexo-next-deploy/"/>
      <url>/2024/05/26/hexo-next-deploy/</url>
      
        <content type="html"><![CDATA[<h2 id="1-服务端"><a href="#1-服务端" class="headerlink" title="1. 服务端"></a>1. 服务端</h2><p>首先看git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br><span class="line">git version</span><br></pre></td></tr></table></figure><p>添加新用户——<code>useradd [username]</code></p><p>添加密码——<code>passwd [username]</code></p><p>切换用户——<code>su [username]</code></p><p>进入用户目录——<code>cd  /home/[username]</code></p><p>创建项目目录</p><p><code>mkdir -p projects/blog</code></p><p><code>mkdir repos &amp;&amp; cd repos</code></p><span id="more"></span><p>创建仓库，并初始化</p><p><code>git init  --bare blog.git</code></p><p><code>cd blog.git/hooks</code></p><p>创建钩子：<code>vim  post-receive </code></p><p>post-receive内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">git --work-tree=/home/[username]/projects/blog --git-dir=/home/[username]/repos/blog.git checkout -f</span><br></pre></td></tr></table></figure><p>之后退出vim，继续进行用户相关的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x post-receive # 添加可执行权限</span><br><span class="line">exit # 返回到root用户</span><br><span class="line">chown -R git:git /home/[username]/repos/blog.git # 给用户添加权限</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone [username]@server_ip:/home/[username]/repos/blog.git</span><br></pre></td></tr></table></figure><p>本地建立ssh信任关系(本地执行)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub [username]@server_ip # 建立信任关系</span><br><span class="line">ssh [username]@server_ip # 试一下能不能免密登录</span><br></pre></td></tr></table></figure><p>但是需要先有ssh key，再.ssh中，使用你电脑的账户获取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;email&quot;</span><br></pre></td></tr></table></figure><p>为了安全起见，这个部署用的用户最好只能用git clone等操作，所以需要更改它默认的shell：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells # 查看 git-shell 是否在登录方式里面</span><br><span class="line">which git-shell # 找到git-shell的路径，记下来</span><br><span class="line">vim /etc/shells # 添加到这个里面</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/passwd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">对[username]的部分将</span></span><br><span class="line">/bin/bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">改为</span></span><br><span class="line">/usr/bin/git-shell</span><br></pre></td></tr></table></figure><h2 id="2-部署上线"><a href="#2-部署上线" class="headerlink" title="2.部署上线"></a>2.部署上线</h2><p>记得安装<code>sudo npm install --save hexo-deployer-git</code>否则没法使用git部署</p><p>修改本地hexo配置_config.yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span> <span class="comment"># github地址</span></span><br><span class="line">    <span class="attr">server_ip:</span> [<span class="string">username</span>]<span class="string">@server_ip:/home/[username]/repos/blog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>编辑<code>package.json</code>文件，修改部署脚本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo generate&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clean&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean &quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;deploy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean&amp;&amp; hexo g -d&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo server&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>然后执行<code>npm run deploy</code>就可以把文件部署上去</p><h2 id="3-宝塔-nignx-域名绑定"><a href="#3-宝塔-nignx-域名绑定" class="headerlink" title="3. 宝塔 nignx 域名绑定"></a>3. 宝塔 nignx 域名绑定</h2><ul><li>dns域名解析到服务器ip</li><li>用宝塔创建一个静态网站</li><li>网站目录选择服务器上的仓库</li></ul><h2 id="4-其他问题"><a href="#4-其他问题" class="headerlink" title="4. 其他问题"></a>4. 其他问题</h2><p><strong>npm install hexo-cli -g一直运行不起来</strong></p><p>node版本问题，教程都是14.17.6</p><p>但是我改成16.20.2就OK了</p><p>ln -s &#x2F;www&#x2F;server&#x2F;nodejs&#x2F;v16.20.2&#x2F;bin&#x2F;hexo &#x2F;usr&#x2F;local&#x2F;bin&#x2F;hexo</p><p>参考连接：<a href="https://developer.aliyun.com/article/775005">https://developer.aliyun.com/article/775005</a></p><p><strong>图床</strong> 和Typora一样，使用github做图床了</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo&amp;next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本栏目介绍</title>
      <link href="/2024/05/26/introduce/"/>
      <url>/2024/05/26/introduce/</url>
      
        <content type="html"><![CDATA[<p>博主的算法题刷题日记</p><p>核心代码模式题目来自leetcode，由代码随想录整理</p><ul><li><p>题目目录：<a href="https://programmercarl.com/">https://programmercarl.com/</a></p></li><li><p>题目讲解视频：<a href="https://space.bilibili.com/525438321/channel/collectiondetail?sid=180037">https://space.bilibili.com/525438321/channel/collectiondetail?sid=180037</a></p></li></ul><hr><p>ACM模式题目 来自kamaCoder——<a href="https://kamacoder.com/">https://kamacoder.com/</a></p><p>本栏目的内容为博主二刷过程中对题目的思考、解题思路、总结的方法</p><p>包括如下内容：</p><ol><li>每天刷题的思考与问题（每道题都记录，但是不详细）</li><li>刷题时一时半会做不出来的题目 or  一道题目的多种解法</li><li>各种笔试题的题解</li></ol><p>联系博主：<a href="mailto:&#121;&#x69;&#x6e;&#104;&#x6f;&#x6e;&#x67;&#121;&#97;&#x6e;&#x67;&#53;&#x34;&#54;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;">&#121;&#x69;&#x6e;&#104;&#x6f;&#x6e;&#x67;&#121;&#97;&#x6e;&#x67;&#53;&#x34;&#54;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;</a></p>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于博主</title>
      <link href="/2024/04/09/introduceMyself/"/>
      <url>/2024/04/09/introduceMyself/</url>
      
        <content type="html"><![CDATA[<p>昵称：4nge1<br>主要方向：Java后端（找工作ing）<br>邮箱：<a href="mailto:&#121;&#105;&#x6e;&#x68;&#x6f;&#110;&#x67;&#121;&#x61;&#x6e;&#103;&#53;&#x34;&#54;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;">&#121;&#105;&#x6e;&#x68;&#x6f;&#110;&#x67;&#121;&#x61;&#x6e;&#103;&#53;&#x34;&#54;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
