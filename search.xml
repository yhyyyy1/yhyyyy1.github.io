<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetCode_142_环形链表II</title>
      <link href="/2024/05/28/leetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/"/>
      <url>/2024/05/28/leetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/</url>
      
        <content type="html"><![CDATA[<p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</br><br>如下为修改示例：</p><p><img src="/images/LeetCode142P1.png" alt="LeetCode142P1.png" title="图片"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>假设入环前长度为 lengthPre，环的长度为lengthCycle，满指针遍历的节点数为 s，快指针遍历的节点数为 f</p><p>想要找到入环的节点，也就是遍历 lengthPre + k * lengthCycle个节点可以到达，</p><p><strong>相遇情况分析：</strong></p><ol><li><p>fast指针和slow指针不会相遇——fast指针遍历到null，则无环</p></li><li><p><strong>fast &#x3D;&#x3D; slow也即首次相遇</strong>，则 <strong>f &#x3D; 2s</strong> 且 快指针在环中一直在套圈，所以 <strong>f &#x3D; s + n * lengthCycle</strong>——可以得到 f &#x3D; 2n * lengthCycle，s &#x3D; n * lengthCycle</p><p>也就是说，如果<strong>让慢指针（快指针也OK）再走lengthPre长度</strong>，就能凑成lengthPre + k * lengthCycle，到入环节点了</p><p>那么怎么找到这个lengthPre长度呢？那还得是双指针啊！</p></li><li><p><strong>第二次相遇流程</strong></p><ul><li>第一次相遇之后，让快指针重新指向链表头</li><li>每轮快慢指针都只走一个节点</li><li>当走了lengthPre步之后，两者同时到入环节点——再次相遇，且此处为入环节点</li></ul></li></ol><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            <span class="comment">// 第一次相遇</span></span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第二次相遇</span></span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or 下面的可能逻辑更清晰一点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-5-28-刷题日记</title>
      <link href="/2024/05/28/2024-5-28-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/05/28/2024-5-28-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>（捅了链表的老巢了。。。。）</p><h4 id="Question-1-反转链表"><a href="#Question-1-反转链表" class="headerlink" title="Question.1 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">Question.1 反转链表</a></h4><p>常规思路迭代还是挺简单的，选节点+头插法阿巴阿巴~~但是借助了外部空间</p><p>下面是一种<strong>原地反转</strong>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义pre、cur、tmp节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 当前遍历节点的前节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head; </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 临时存储后序的节点</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        tmp = cur.next;</span><br><span class="line">        cur.next = pre; <span class="comment">// 改变了链表的箭头方向</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是题目说可以尝试<strong>递归</strong>，感谢大佬的题解：<a href="https://leetcode.cn/problems/reverse-linked-list/solutions/36710/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">https://leetcode.cn/problems/reverse-linked-list/solutions/36710/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/</a></p><span id="more"></span><p><strong>主要思路：</strong></p><ul><li>也是将指针改为指向前一个node，但是具体实现为：<code>head.next.next = head;</code>（对应的node是head.next，将其指针改为指向head）</li><li>因为是递归，肯定是进入最底层再回溯；所以是从尾部向前反转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) &#123; <span class="comment">// head==null专门为head为空设计的</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的cur就是最后一个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    <span class="comment">//防止链表循环，需要将head.next设置为空</span></span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-2-两两交换链表中的节点"><a href="#Question-2-两两交换链表中的节点" class="headerlink" title="Question.2 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">Question.2 两两交换链表中的节点</a></h4><p>正好用到了递归的思想，和Q1中的思想挺符合的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 这道题好像递归好一点</span></span><br><span class="line">    <span class="keyword">while</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> swapPairs(head.next.next);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    head.next = tail;</span><br><span class="line">    temp.next = head;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-3-删除链表的倒数第-N-个结点"><a href="#Question-3-删除链表的倒数第-N-个结点" class="headerlink" title="Question.3 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">Question.3 删除链表的倒数第 N 个结点</a></h4><p>这个题是我第一次面试出的算法题，印象很深——双指针嘛</p><p>很经典的双指针题目，用双指针实现对倒数第n个元素这个条件进行替换，n + length &#x3D; length + n，所以最后剩下的正好是n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        right = right.next; <span class="comment">// 到了第n-1个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right.next != <span class="literal">null</span>) &#123; <span class="comment">//</span></span><br><span class="line">        right = right.next;</span><br><span class="line">        left = left.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 期望找到倒数第n+1个元素，进行删除操作</span></span><br><span class="line">    left.next = left.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-4-链表相交"><a href="#Question-4-链表相交" class="headerlink" title="Question.4 链表相交"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">Question.4 链表相交</a></h4><p>同为双指针，找相同关系：lengthA + length同 + lengthB &#x3D; lengthB + length同 + lengthA，如果有相交则，一定会有相等的点</p><p>特别厉害的思路和实现逻辑：</p><ul><li>如果不相交，则 <code>lengthA+lengthB = lengthB + lengthA</code> or <code>lengthA = lengthB</code> 两者长度一样，肯定会同时为null，也即相等，跳出循环</li><li>如果相交，则同理，<code>lengthA + length同 + lengthB = lengthB + length同 + lengthA</code>，之后一定是相同的，或者<code>lengthA = lengthB</code>则会提前相交</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> headA;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> headB;</span><br><span class="line">    <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">        left = left == <span class="literal">null</span> ? headB : left.next;</span><br><span class="line">        right = right == <span class="literal">null</span> ? headA : right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-5-环形链表-II"><a href="#Question-5-环形链表-II" class="headerlink" title="Question.5 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">Question.5 环形链表 II</a></h4><p>同为双指针，快慢指针（点击标题看详解~）</p><h4 id="Question-6-有效的字母异位词"><a href="#Question-6-有效的字母异位词" class="headerlink" title="Question.6 有效的字母异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/description/">Question.6 有效的字母异位词</a></h4><p>平平无奇 字母表</p><h4 id="Question-7-两个数组的交集"><a href="#Question-7-两个数组的交集" class="headerlink" title="Question.7 两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">Question.7 两个数组的交集</a></h4><p>同理，平平无奇，用Set就行，但是有一点：</p><p>如果是Set转为数组的话是不能直接转为基本数据类型的，如int等，只能是String、Integer等包装类</p><p>只能一个个取出对应的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ansArray = <span class="keyword">new</span> <span class="title class_">int</span>[ans.size()]; <span class="comment">//ans是hashSet</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : ans) &#123;</span><br><span class="line">    ansArray[index++] = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列01：应用场景</title>
      <link href="/2024/05/27/introduceOfMQ/"/>
      <url>/2024/05/27/introduceOfMQ/</url>
      
        <content type="html"><![CDATA[<p>尚未开始，别急</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列起始</title>
      <link href="/2024/05/27/mq01/"/>
      <url>/2024/05/27/mq01/</url>
      
        <content type="html"><![CDATA[<p>吸取之前面试美团金融的经验，开始学习消息队列的内容</p><blockquote><p>还记得当时面试官给我出了一道场景题：消息队列中如何避免一个消息被重复消费？</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java容器部分知识点总结（未完待续）</title>
      <link href="/2024/05/27/Java%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2024/05/27/Java%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="一、通用"><a href="#一、通用" class="headerlink" title="一、通用"></a>一、通用</h3><p>分为Collection（存对象） 和 Map（存两个对象之间映射表），两种接口</p><p>如List、Set等都是接口，ArrayList、HashSet、HashMap等才是实现类，所以初始化对象，如<code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code>可以体现出Java中的多态</p><p>java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。</p><span id="more"></span><h3 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h3><p>以键值对的形式存储和操作数据的容器类型</p><p>主要包括四种实现类：TreeMap、HashMap、LinkedHashMap、HashTable</p><p><strong>TreeMap</strong>——基于<strong>红黑树</strong>实现的一种提供顺序访问的Map（中序遍历）</p><h4 id="HashMap："><a href="#HashMap：" class="headerlink" title="HashMap："></a>HashMap：</h4><ul><li>基于散列表，访问速度快。进行 put 或者 get 操作，可以达到常数时间的性能。</li><li>HashMap最多只允许一条记录的键Key为null；但允许多条记录的值Value为null。</li><li>HashMap中节点数据（Java7中为Entry，Java8中是Node），包含key、value、hash、next四个值</li></ul><ol><li><p><strong>Java7 &amp; HashMap——数组+链表</strong></p><p><strong>数据结构</strong>：数组buckets表示hash值数组，链表用于解决元素的hash冲突</p><p><strong>初始化</strong>：指定buckets的初始容量（默认为16）、负载因子（默认为0.75），若entry数量超过 容量*负载因子则需要扩容并重新hash，扩容为原来二倍</p><p><strong>get()方法</strong>：用于找到指定key的value。该方法调用getEntry(key)获取entry，再由entry.getValue()得到value，所以getEntry是核心（hash算buckets下标，在遍历冲突链条即可）</p><p><strong>put()方法</strong>：将指定的key-value对添加到map中。该方法首先会在map中查询该键值对，如果没有则addEntry头插到对应位置</p><p><strong>remove()方法</strong>：删除。。</p></li><li><p><strong>Java8 &amp; HashMap——数组+链表+红黑树</strong></p><p>降冲突链查询过程中的开销，引入红黑树——当<strong>容量达到64</strong>，且<strong>链表中的元素达到8个</strong>时，则链表转为红黑树，时间复杂度为O(logN)</p><p>但是只有小于6个时才会转回来</p></li></ol><p><strong>LinkedHashMap</strong>——HashMap的子类，但链表为双向链表维护元素的顺序（插入 or LRU）</p><p><strong>HashTable</strong>——并发安全但不如ConcurrentHashMap效率高，正常又不如HashMap，尽量不用</p><h3 id="三、List"><a href="#三、List" class="headerlink" title="三、List"></a>三、List</h3><p>顺序储存，允许重复</p><p>主要包括三种实现类：ArrayList、LinkedList、Vector（线程安全，但不推荐使用）</p><ul><li><p><strong>ArrayList</strong>：数组（动态数组）——查询效率高但插入效率低</p><p>有两个参数：</p><ul><li>size 当前实际存储的元素个数；</li><li>capacity 表示数组能容纳的元素个数（初始为0，第一次插入后为10）</li></ul><p><strong>扩容</strong>，每次插入前先看当前数组是否能容纳所有元素，如果不能则扩容——创建一个capacity是原来1.5倍的新数组，将现有数组的数据拷贝到新数组中（要尽量避免扩容的操作！！）</p></li><li><p><strong>LinkedList</strong>：双向链表（正常的双向链表）</p><p>但是要明确一点，如Queue也有LinkedList的实现类，但是两者是不一样的！！</p></li></ul><h3 id="四、Set"><a href="#四、Set" class="headerlink" title="四、Set"></a>四、Set</h3><p>不允许重复</p><p>主要包括三种实现类：TreeSet、HashSet、LinkedHashSet（仔细观察会发现和Map的很像）</p><p><strong>TreeSet</strong>——红黑树，自然顺序访问（自然顺序：调用对象的compareTo方法进行比较，升序排列）</p><p><strong>HashSet</strong>——套壳HashMap（Value统一为常量PRESENT）</p><p>LinkedHashSet——套壳LinkedHashMap（同理）</p><h3 id="五、Queue"><a href="#五、Queue" class="headerlink" title="五、Queue"></a>五、Queue</h3><p>主要是PriorityQueue——优先级队列</p><p>Deque（双端队列，Queue的子接口）其实现类：LinkedList、ArrayDeque</p><h3 id="六、其他总结"><a href="#六、其他总结" class="headerlink" title="六、其他总结"></a>六、其他总结</h3><h4 id="Tip1：List-和-Queue的区别"><a href="#Tip1：List-和-Queue的区别" class="headerlink" title="Tip1：List 和 Queue的区别"></a>Tip1：List 和 Queue的区别</h4><p><strong>List</strong>：更适合在需要频繁索引访问和控制元素精确位置的场景中使用。</p><p><strong>Queue</strong>：更适合在需要管理按特定顺序处理元素的场景中使用，如在多线程环境中管理任务的分发。</p><h4 id="Tip2：容器中的排序问题"><a href="#Tip2：容器中的排序问题" class="headerlink" title="Tip2：容器中的排序问题"></a>Tip2：容器中的排序问题</h4><p>容器中的排序可以分为3类：无序、插入顺序、大小顺序</p><ul><li>HashMap是无序的</li><li>ArrayList是插入顺序，但是可以通过sort方法对已有元素进行排序（改为了大小排序）</li><li>TreeMap可以根据key进行自定义的大小排序（指定Comparator）</li><li>LinkedHashMap默认是插入顺序，也可以初始化时指定为LRU顺序</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024.5.27 刷题日记</title>
      <link href="/2024/05/27/2024-5-27-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/05/27/2024-5-27-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="Question-1-二分查找"><a href="#Question-1-二分查找" class="headerlink" title="Question.1 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/description/">Question.1 二分查找</a></h4><p>一道比较简单的题目，但是看到一个比较有趣的评论：</p><blockquote><p>有一天小明到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把小明拦下，要检查一下哪本书没有登记出借。小明正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是小明背着剩下的书走了。 从此，图书馆丢了 N - 1本书。</p></blockquote><p>二分的本质是由mid分出的两部分分别整体满足不同的性质，对于有序数组就是与目标值的大小关系，对于图书测试就是是否会引起警报</p><p>同时也提了一个醒——二分法的应用场景：有序且唯一</p><span id="more"></span><h4 id="Question-2-移除元素"><a href="#Question-2-移除元素" class="headerlink" title="Question.2 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">Question.2 移除元素</a></h4><p><strong>经典双指针问题</strong>，分为两种：</p><ol><li>快慢指针：一个指针快速向前遍历，另一个指针指向要替换的位置</li><li>左右指针：右侧指针来替换左侧指针可以替换的位置</li></ol><h4 id="Question-3-有序数组的平方-Question-4-长度最小的子数组"><a href="#Question-3-有序数组的平方-Question-4-长度最小的子数组" class="headerlink" title="Question.3 有序数组的平方 &amp;&amp; Question.4 长度最小的子数组"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">Question.3 有序数组的平方</a> &amp;&amp; <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">Question.4 长度最小的子数组</a></h4><p>均为双指针问题</p><h4 id="Question-5-螺旋矩阵II"><a href="#Question-5-螺旋矩阵II" class="headerlink" title="Question.5 螺旋矩阵II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">Question.5 螺旋矩阵II</a></h4><p>定义出对应的边界，一层一层的遍历就行了，不用想的那么复杂（找规律什么的）</p><h4 id="Question-6-移除链表元素"><a href="#Question-6-移除链表元素" class="headerlink" title="Question.6 移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">Question.6 移除链表元素</a></h4><p>链表题目经验：<strong>能不对head操作就不对head操作</strong></p><ul><li>应对方法 1：定义一个dummyHead作为头节点，如<code>ListNode dummyHead = new ListNode(0, head);</code></li><li>应对方案 2：直接新建一个临时头，如<code>ListNode temp = head;</code></li></ul><h4 id="Question-7-设计链表"><a href="#Question-7-设计链表" class="headerlink" title="Question.7 设计链表"></a><a href="https://leetcode.cn/problems/design-linked-list/description/">Question.7 设计链表</a></h4><p>可以直接用ListNode类。。。。 平平无奇的一道题</p>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo&amp;next部署流程</title>
      <link href="/2024/05/26/hexo-next-deploy/"/>
      <url>/2024/05/26/hexo-next-deploy/</url>
      
        <content type="html"><![CDATA[<h2 id="1-服务端"><a href="#1-服务端" class="headerlink" title="1. 服务端"></a>1. 服务端</h2><p>首先看git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br><span class="line">git version</span><br></pre></td></tr></table></figure><p>添加新用户——<code>useradd [username]</code></p><p>添加密码——<code>passwd [username]</code></p><p>切换用户——<code>su [username]</code></p><p>进入用户目录——<code>cd  /home/[username]</code></p><p>创建项目目录</p><p><code>mkdir -p projects/blog</code></p><p><code>mkdir repos &amp;&amp; cd repos</code></p><span id="more"></span><p>创建仓库，并初始化</p><p><code>git init  --bare blog.git</code></p><p><code>cd blog.git/hooks</code></p><p>创建钩子：<code>vim  post-receive </code></p><p>post-receive内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">git --work-tree=/home/[username]/projects/blog --git-dir=/home/[username]/repos/blog.git checkout -f</span><br></pre></td></tr></table></figure><p>之后退出vim，继续进行用户相关的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x post-receive # 添加可执行权限</span><br><span class="line">exit # 返回到root用户</span><br><span class="line">chown -R git:git /home/[username]/repos/blog.git # 给用户添加权限</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone [username]@server_ip:/home/[username]/repos/blog.git</span><br></pre></td></tr></table></figure><p>本地建立ssh信任关系(本地执行)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub [username]@server_ip # 建立信任关系</span><br><span class="line">ssh [username]@server_ip # 试一下能不能免密登录</span><br></pre></td></tr></table></figure><p>但是需要先有ssh key，再.ssh中，使用你电脑的账户获取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;email&quot;</span><br></pre></td></tr></table></figure><p>为了安全起见，这个部署用的用户最好只能用git clone等操作，所以需要更改它默认的shell：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells # 查看 git-shell 是否在登录方式里面</span><br><span class="line">which git-shell # 找到git-shell的路径，记下来</span><br><span class="line">vim /etc/shells # 添加到这个里面</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/passwd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">对[username]的部分将</span></span><br><span class="line">/bin/bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">改为</span></span><br><span class="line">/usr/bin/git-shell</span><br></pre></td></tr></table></figure><h2 id="2-部署上线"><a href="#2-部署上线" class="headerlink" title="2.部署上线"></a>2.部署上线</h2><p>记得安装<code>sudo npm install --save hexo-deployer-git</code>否则没法使用git部署</p><p>修改本地hexo配置_config.yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span> <span class="comment"># github地址</span></span><br><span class="line">    <span class="attr">server_ip:</span> [<span class="string">username</span>]<span class="string">@server_ip:/home/[username]/repos/blog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>编辑<code>package.json</code>文件，修改部署脚本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo generate&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clean&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean &quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;deploy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean&amp;&amp; hexo g -d&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo server&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>然后执行<code>npm run deploy</code>就可以把文件部署上去</p><h2 id="3-宝塔-nignx-域名绑定"><a href="#3-宝塔-nignx-域名绑定" class="headerlink" title="3. 宝塔 nignx 域名绑定"></a>3. 宝塔 nignx 域名绑定</h2><ul><li>dns域名解析到服务器ip</li><li>用宝塔创建一个静态网站</li><li>网站目录选择服务器上的仓库</li></ul><h2 id="4-其他问题"><a href="#4-其他问题" class="headerlink" title="4. 其他问题"></a>4. 其他问题</h2><p><strong>npm install hexo-cli -g一直运行不起来</strong></p><p>node版本问题，教程都是14.17.6</p><p>但是我改成16.20.2就OK了</p><p>ln -s &#x2F;www&#x2F;server&#x2F;nodejs&#x2F;v16.20.2&#x2F;bin&#x2F;hexo &#x2F;usr&#x2F;local&#x2F;bin&#x2F;hexo</p><p>参考连接：<a href="https://developer.aliyun.com/article/775005">https://developer.aliyun.com/article/775005</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>本文待更新</title>
      <link href="/2024/05/26/testForLife/"/>
      <url>/2024/05/26/testForLife/</url>
      
        <content type="html"><![CDATA[<p>本文待更新</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>本栏目介绍</title>
      <link href="/2024/05/26/introduce/"/>
      <url>/2024/05/26/introduce/</url>
      
        <content type="html"><![CDATA[<p>博主的算法题刷题日记</p><p>题目来自leetcode，由代码随想录整理</p><ul><li><p>题目目录：<a href="https://programmercarl.com/">https://programmercarl.com/</a></p></li><li><p>题目讲解视频：<a href="https://space.bilibili.com/525438321/channel/collectiondetail?sid=180037">https://space.bilibili.com/525438321/channel/collectiondetail?sid=180037</a></p></li></ul><p>本栏目的内容为博主二刷过程中对题目的思考、解题思路、总结的方法</p><p>包括如下内容：</p><ol><li>每天刷题的思考与问题（每道题都记录，但是不详细）</li><li>刷题时一时半会做不出来的题目 or  一道题目的多种解法</li><li>各种笔试题的题解</li></ol><p>联系博主：<a href="mailto:&#x79;&#105;&#x6e;&#x68;&#111;&#110;&#x67;&#x79;&#x61;&#x6e;&#103;&#x35;&#x34;&#54;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;">&#x79;&#105;&#x6e;&#x68;&#111;&#110;&#x67;&#x79;&#x61;&#x6e;&#103;&#x35;&#x34;&#54;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;</a></p>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于博主</title>
      <link href="/2024/04/09/introduceMyself/"/>
      <url>/2024/04/09/introduceMyself/</url>
      
        <content type="html"><![CDATA[<p>昵称：4nge1<br>主要方向：Java后端（找工作ing）<br>邮箱：<a href="mailto:&#x79;&#x69;&#x6e;&#x68;&#x6f;&#x6e;&#x67;&#x79;&#x61;&#x6e;&#x67;&#x35;&#52;&#54;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;">&#x79;&#x69;&#x6e;&#x68;&#x6f;&#x6e;&#x67;&#x79;&#x61;&#x6e;&#x67;&#x35;&#52;&#54;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
