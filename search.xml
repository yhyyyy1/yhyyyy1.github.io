<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>后端初始化模板01——实体类</title>
      <link href="/2024/07/06/%E5%90%8E%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/07/06/%E5%90%8E%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本人的后端初始化模板记录</p></blockquote><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>Serializable接口，实现对象的序列化<br>没有定义任何方法，只是表明该类具有序列化的能力。</p><p><strong>序列化</strong>是将对象的状态转换为字节流的过程，从而可以将对象的状态保存到文件、数据库或通过网络传输。反序列化是将字节流转换回对象的过程。</p><h3 id="TableId注解"><a href="#TableId注解" class="headerlink" title="@TableId注解"></a>@TableId注解</h3><p>实体类中用于标识实体类的主键字段。并可以指定主键的生成策略（<code>IdType</code> 枚举中，定义了多种主键生成策略）：</p><ul><li><code>AUTO</code>：数据库ID自增。</li><li><code>NONE</code>：未设置主键生成策略。</li><li><code>INPUT</code>：手动输入ID。</li><li><code>ID_WORKER</code>：使用分布式全局唯一ID策略（已弃用，推荐使用 <code>ASSIGN_ID</code>）。</li><li><code>UUID</code>：使用UUID。</li><li><code>ASSIGN_ID</code>：使用分布式全局唯一ID策略，适用于主键为 <code>Long</code> 类型。</li><li><code>ASSIGN_UUID</code>：使用UUID，适用于主键为 <code>String</code> 类型。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableId(type = IdType.ASSIGN_ID)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><h3 id="NotBlank-NotNull等注解"><a href="#NotBlank-NotNull等注解" class="headerlink" title="@NotBlank &amp; @NotNull等注解"></a>@NotBlank &amp; @NotNull等注解</h3><p>validation注解，判断入参是否符合业务要求，提前做判断，不需要在controller 或者 service层进行操作。</p><p>参数 message：在不满足注解要求是报错的内容</p><p>通常用在做为入参的类中使用</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotNull(message = &quot;id不能为空&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotBlank(message = &quot;用户账号不能为空&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String userAccount;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ACM模式——练习2（浮点数练习）</title>
      <link href="/2024/07/06/ACM%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%BB%83%E4%B9%A02/"/>
      <url>/2024/07/06/ACM%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%BB%83%E4%B9%A02/</url>
      
        <content type="html"><![CDATA[<h3 id="平均绩点"><a href="#平均绩点" class="headerlink" title="平均绩点"></a><a href="https://kamacoder.com/problempage.php?pid=1006">平均绩点</a></h3><p>主要的代码逻辑还是很简单的，但是有一个重点——结果保留两位小数；</p><p>有两种方法：</p><ol><li><p>使用<strong>String.format()方法</strong>，如：<code>String.format(&quot;%.2f&quot;, XXXX);</code>其中，%.2f表示保留两位小数，XXXX为一个浮点数(float or double)</p><p>如%.nf就是保留n位小数</p></li><li><p>使用<strong>DecimalFormat类</strong>，<code>DecimalFormat</code>类的构造参数<code>&quot;0.00&quot;</code>表示保留两位小数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DecimalFormat</span> <span class="variable">decimalFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.00&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">score1</span> <span class="operator">=</span> <span class="number">0.000000</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">formattedScore</span> <span class="operator">=</span> decimalFormat.format(score1);</span><br><span class="line">        System.out.println(formattedScore); <span class="comment">// 输出：0.00</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是要注意，<strong>导入的包为 java.text.DecimalFormat</strong></p></li></ol><p><strong>所以尽量还是用String.format，ju*就可以了</strong></p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// import java.text.DecimalFormat;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            String[] scores = in.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">float</span> <span class="variable">scoreCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isKnown</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (String score : scores) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">                        scoreCount += <span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">                        scoreCount += <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">                        scoreCount += <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;D&quot;</span>:</span><br><span class="line">                        scoreCount += <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;F&quot;</span>:</span><br><span class="line">                        scoreCount += <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        isKnown = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isKnown) &#123;</span><br><span class="line"><span class="comment">//                DecimalFormat decimalFormat = new DecimalFormat(&quot;0.00&quot;);</span></span><br><span class="line"><span class="comment">//                String formattedScore = decimalFormat.format(scoreCount / scores.length);</span></span><br><span class="line"><span class="comment">//                System.out.println(formattedScore);</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">formattedScore</span> <span class="operator">=</span> String.format(<span class="string">&quot;%.2f&quot;</span>, scoreCount / scores.length);</span><br><span class="line">                System.out.println(formattedScore);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring核心知识01：Bean</title>
      <link href="/2024/07/05/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8601/"/>
      <url>/2024/07/05/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8601/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Spring中，构建应用程序主体、由Spring IoC容器管理的对象成为Bean</p><p><strong>Bean是由Spring IoC容器示例化、装配和管理的对象。</strong></p></blockquote><h3 id="什么是Spring-Bean？"><a href="#什么是Spring-Bean？" class="headerlink" title="什么是Spring Bean？"></a>什么是Spring Bean？</h3><p><strong>Bean 代指的就是那些被 IoC 容器所管理的对象。</strong></p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><h3 id="如何用注解将一个类声明成Bean？"><a href="#如何用注解将一个类声明成Bean？" class="headerlink" title="如何用注解将一个类声明成Bean？"></a>如何用注解将一个类声明成Bean？</h3><ul><li><p><code>@Component</code>：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</p></li><li><p><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</p></li><li><p><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p></li><li><p><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 <code>Service</code> 层返回数据给前端页。</p></li></ul><span id="more"></span><h3 id="注入Bean的注解有哪些？（如何用注解注入Bean）"><a href="#注入Bean的注解有哪些？（如何用注解注入Bean）" class="headerlink" title="注入Bean的注解有哪些？（如何用注解注入Bean）"></a>注入Bean的注解有哪些？（如何用注解注入Bean）</h3><ul><li><code>@Autowired</code> Spring内置</li><li><code>@Resource</code> JDK内置</li><li>@<code>Inject</code> JDK内置</li></ul><h3 id="Autowired-和-Resource的区别"><a href="#Autowired-和-Resource的区别" class="headerlink" title="@Autowired  和 @Resource的区别"></a><code>@Autowired</code>  和 <code>@Resource</code>的区别</h3><ul><li><p><code>@Autowired</code> 的默认注入方式为<strong>byType</strong>（根据类型进行匹配）<br><code>@Resource</code> 的默认注入方式为<strong>byName</strong>（根据名称来查找）</p><p>但是两者在面对一个接口有多个实现类的时候，都是束手无策的，常规的方法（如下）是不可行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><p>两者都需要通过具体的名称来匹配对应的Bean：<code>@Autowired</code> 通过 <code>@Qualifier</code>注解显示指定名称；<code>@Resource</code> 可以通过name属性来显示指定名称。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;userServiceImpl&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource(name = &quot;userServiceImpl&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><p>当然更简单的可以：<code>private UserService userServiceImpl;</code></p></li><li><p><code>@Autowired</code> 支持在构造函数、方法、字段和参数上使用。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。（在构造函数 or 方法上使用：）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加@Qualifier注解</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(<span class="meta">@Qualifier(&quot;userDao&quot;)</span> UserDao userDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Bean的作用域有哪些"><a href="#Bean的作用域有哪些" class="headerlink" title="Bean的作用域有哪些"></a>Bean的作用域有哪些</h3><ul><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><p>使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span> <span class="comment">// 任意Bean注解</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON)</span><span class="comment">//配置Bean的作用域</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userServiceImpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java并发面试题01</title>
      <link href="/2024/07/05/Java%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%9801/"/>
      <url>/2024/07/05/Java%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%9801/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习Java并发时的知识点总结</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java并发笔记08：线程池</title>
      <link href="/2024/07/05/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B008/"/>
      <url>/2024/07/05/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B008/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习Java并发时的知识点总结</p></blockquote><p><strong>线程池</strong>—— 是一种开发框架，是一种基于池化思想管理线程的工具（池化：如数据库的连接池）</p><ul><li>降低资源消耗：重复利用已创建的线程，降低线程创建和销毁造成的消耗</li><li>提高响应速度：任务到达时，可以立即执行，不需要等待线程创建</li><li>提高线程可管理性</li></ul><p>归根结底，线程池的作用：<strong>复用线程</strong></p><h3 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h3> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-5-XCCP1.png" alt="2024-7-5-XCCP1" style="zoom:80%;" /><p>线程池分为<strong>核心线程池</strong>和<strong>非核心线程池</strong>（核心线程池只有核心线程池满了才会复用，否则会创建新线程）</p><span id="more"></span><h4 id="线程池工作流程"><a href="#线程池工作流程" class="headerlink" title="线程池工作流程"></a>线程池工作流程</h4><ol><li><strong>首先会判断核心线程池是否已满</strong>：如果没有满，则直接创建新线程来执行任务。如果已经满了，则进行下一步判断，<strong>尝试将任务放入队列</strong>。</li><li><strong>判断队列是否已经满了</strong>：如果没有满，则任务放入队列，结束。如果队列已经满了，则进行下一步判断。</li><li><strong>判断线程池（核心+非核心）是否已经满</strong>：如果没满，则创建新线程来执行任务。如果已经满了，则按照饱和策略来处理任务。</li></ol><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>Java中线程池的核心实现类是ThreadPoolExecutor类</p><h4 id="线程池参数（7个参数）"><a href="#线程池参数（7个参数）" class="headerlink" title="线程池参数（7个参数）"></a>线程池参数（7个参数）</h4><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-5-XCCP2.png" alt="2024-7-5-XCCP2"></p><ul><li><p><strong>corePoolSize</strong>：核心线程池大小</p></li><li><p><strong>maximumPoolSize</strong>：最大线程数——核心+非核心</p></li><li><p><strong>keepAliveTime</strong>：空闲线程存活时间（<strong>只作用于非核心线程</strong>，核心线程不会回收）</p></li><li><p><strong>unit</strong>：时间单位——keepAliveTime的时间单位</p></li><li><p><strong>workQueue</strong>：阻塞队列，用于保存任务</p><p>具体队列类型可以看之前的阻塞队列</p><ul><li><p>ArrayBlockingQueue</p></li><li><p>LinkedBlockingQueue</p></li><li><p>SynchronousQueue</p></li><li><p>PriorityBlockingQueue</p></li></ul></li><li><p><strong>threadFactory</strong>：创建线程的工厂类</p></li><li><p><strong>handler</strong>：饱和策略（拒绝策略）</p><p>线程和阻塞队列都满了，使用handler处理新来的任务</p><ul><li><p><strong>AbortPolicy</strong>：直接抛出异常（默认）</p></li><li><p>CallerRunPolicy：使用任务提交者的线程运行</p></li><li><p>DiscardOldestPolicy：抛弃最老（最早入队的）的线程，并重试提交当前任务</p></li><li><p>DiscardPolicy：不处理丢弃</p></li></ul></li></ul><h4 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h4><p>如下图所示：</p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-5-XCCP3.png" alt="2024-7-5-XCCP3" style="zoom:67%;" /><p>调用线程池主要是使用ThreadPoolExecutor中的execute方法，下面是几种情况：</p><ol><li><strong>如果当前运行的线程少于corePoolSize-核心线程池大小</strong>，也就是核心线程池未满，则创建新线程来执行任务（此时相当于线程池的预热阶段）</li><li><strong>如果运行的线程等于or多于corePoolSize</strong>，则将任务加入BlockingQueue-等待队列中（等待核心线程池中的有空闲线程）</li><li><strong>如果无法将任务加入到BlockingQueue中（队列满了）</strong>，则创建新线程来处理任务</li><li><strong>如果创建新线程将使得运行的线程超出maximumPoolSize-最大线程数</strong>，则任务将根据handler-饱和策略被拒绝，</li></ol><h4 id="常用的三种ThreadPoolExecutor"><a href="#常用的三种ThreadPoolExecutor" class="headerlink" title="常用的三种ThreadPoolExecutor"></a>常用的三种ThreadPoolExecutor</h4><ol><li><p><strong>FixedThreadPool</strong>——控制最大并发（定义的最大线程数）的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JUC中newFixedThreadPool的源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>corePoolSize和maximumPoolSize在线程池<strong>创建时就被指定</strong>（此处是nThreads），而且<strong>相等——核心线程就是总线程</strong>，也就是最大的并发数</p><p>阻塞队列为<strong>LinkedBlockingQueue</strong>（队列容量为Integer.MAX_VALUE，是无界阻塞队列），所以maximumPoolSize是一个无效参数，被设置成corePoolSize，表示非核心线程池大小为0</p><p><strong>keepAliveTime为0L</strong>，因为没有非核心线程。（更加保证了不会有非核心线程，一旦创建就kill）</p></li><li><p><strong>SingleThreadExecutor</strong>——单线程处理的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JUC中newSingleThreadExecutor的源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SingleThreadExecutor的<strong>corePoolSize和maximumPoolSize被设置为1</strong>。</p><p>其他参数与FixedThreadPool相同（如无界队列LinkedBlockingQueue，keepAliveTime为0L等）</p></li><li><p><strong>CachedThreadPool</strong>——可回收缓存的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JUC中newCachedThreadPool的源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CachedThreadPool的<strong>corePoolSize被设置为0</strong>，即corePool为空；<strong>maximumPoolSize被设置为Integer.MAX_VALUE</strong>，即maximumPool是无界的——并发数无限大，但是每个线程都可以回收</p><p><strong>keepAliveTime设置为60L</strong>，意味着CachedThreadPool中的空闲线程等待新任务的最长时间为60秒，空闲线程超过60秒后将会被终止。</p><p>阻塞队列为SynchronousQueue-不存元素的阻塞队列，相当于没有阻塞队列，因为maximumPool是无界的，所以每个任务都会直接创建or复用线程。（所以可能和消耗大量CPU &amp; 内存资源）</p></li></ol><h4 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h4><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-5-XCCP4.png" alt="2024-7-5-XCCP4"></p><ul><li>NEW </li><li>RUNNING</li><li>SHUTDOWN：不收但是还在执行</li><li>STOP：不受不执行，执行中的会中断</li><li>TIDYING：所有任务都销毁了，workerCount &#x3D; 0，会执行terminated方法</li><li>TERMINATED：</li></ul><p>可以对比一下<a href="http://yhy1031.cn/2024/06/05/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B001/">线程的状态</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ACM模式——练习1（A+B问题，输入shu&#39;chu）</title>
      <link href="/2024/07/05/ACM%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%BB%83%E4%B9%A01%EF%BC%88A-B%E9%97%AE%E9%A2%98%EF%BC%89/"/>
      <url>/2024/07/05/ACM%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%BB%83%E4%B9%A01%EF%BC%88A-B%E9%97%AE%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从基础入手，开始练习ACM模式算法题</p></blockquote><h3 id="A-B问题I"><a href="#A-B问题I" class="headerlink" title="A+B问题I"></a><a href="https://kamacoder.com/problempage.php?pid=1000">A+B问题I</a></h3><p>。。。就是每次笔试的时候给出的样例，有种马上如临大敌的感觉哈哈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小发现：</p><p>​nextInt()是不会受到“行”的制约的，所以不需要 <code>in.nextLine()</code>来换行</p></blockquote><span id="more"></span><h3 id="A-B问题II"><a href="#A-B问题II" class="headerlink" title="A+B问题II"></a><a href="https://kamacoder.com/problempage.php?pid=1001">A+B问题II</a></h3><p>结题时注意下面这句话，所以需要使用<code>while (in.hasNext())</code>循环处理多组输入的情况</p><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-5-T2P1.png" alt="2024-7-5-T2P1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            in.nextLine(); <span class="comment">//可有可无</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">                System.out.println(a + b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-B问题III"><a href="#A-B问题III" class="headerlink" title="A+B问题III"></a><a href="https://kamacoder.com/problempage.php?pid=1002">A+B问题III</a></h3><p>多了一步对输入进行检验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-B问题IV"><a href="#A-B问题IV" class="headerlink" title="A+B问题IV"></a><a href="https://kamacoder.com/problempage.php?pid=1003">A+B问题IV</a></h3><p>常规解法如下，也可以使用nextLine()+startsWith()等方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                result += in.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-B问题VII"><a href="#A-B问题VII" class="headerlink" title="A+B问题VII"></a><a href="https://kamacoder.com/problempage.php?pid=1004">A+B问题VII</a></h3><p>和T1相比，多输出一行空行。。。。不知道这个出题的是怎么想的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line"><span class="comment">//System.out.println(a + b + &quot;\n&quot;);</span></span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-B问题VIII"><a href="#A-B问题VIII" class="headerlink" title="A+B问题VIII"></a><a href="https://kamacoder.com/problempage.php?pid=1005">A+B问题VIII</a></h3><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-5-T6P1.png" alt="2024-7-5-T6P1"></p><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-5-T6P2.png" alt="2024-7-5-T6P2"></p><p>根据题目描述相当于把之前的题目合一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">                    result += in.nextInt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i != n - <span class="number">1</span>) System.out.println(result + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> System.out.println(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java并发笔记07：CAS &amp; 乐观锁与悲观锁 &amp; 原子操作类</title>
      <link href="/2024/07/04/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B007/"/>
      <url>/2024/07/04/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B007/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习Java并发时的知识点总结</p></blockquote><h3 id="CAS——Compare-And-Swap"><a href="#CAS——Compare-And-Swap" class="headerlink" title="CAS——Compare-And-Swap"></a>CAS——Compare-And-Swap</h3><p>对比交换，这是一条CPU的原子指令。</p><p><strong>CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。</strong></p><p><strong>CAS是乐观锁</strong>（在操作数据时非常乐观，认为别人不会同时修改数据。因此在执行更新的时候只会判断一下在此期间别人是否修改了数据，如果别人修改了数据则放弃操作，否则执行操作）<strong>，CAS是无锁的</strong>，所以如果线程之间<strong>存在竞争</strong>的时候，就只能通过<strong>自旋的方式来等待</strong></p><p><strong>CAS自旋</strong>：接上，CAS自旋相当于循环+CAS，如果本次CAS(100→50)不成功，则会认为有其他线程的CAS快我一步，我会进行CAS(50→0)，如果还不成功则进行CAS(0→-50)……</p><span id="more"></span><h4 id="CAS的三个主要问题"><a href="#CAS的三个主要问题" class="headerlink" title="CAS的三个主要问题"></a>CAS的三个主要问题</h4><ol><li><p><strong>ABA问题</strong>：如果一个值原来是A，变成了B，又变成了A（A→B→A），那么使用CAS进行检查时会发现它的值没有发生变化。</p><blockquote><p>如：</p><p>某人充值游戏需要花费50￥，此时银行卡中余额有100￥，则要执行CAS(100→50)，因为游戏界面比较卡，多点了几次充值按钮，触发了后台threadA和threadB工作要执行CAS(100→50)，此时threadA的CAS(100→50)执行成功，threadB的会被阻塞。</p><p>如果此时正好，wx零钱提现到账50￥，threadC执行CAS(50→100)且执行成功，银行卡余额又变成了100￥，threadB则会成功执行，使得银行卡余额变成50￥。</p></blockquote><p>解决方法：版本号！在变量前加上版本号，同时判断值与版本号是否相等。</p></li><li><p><strong>循环时间长，开销大</strong></p><p>自旋CAS如果长时间不成功，会给CPU带来很大的执行开销</p></li><li><p><strong>只能保证一个共享变量的原子操作</strong></p><p>多变量只能加锁</p></li></ol><h4 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&amp;悲观锁"></a>乐观锁&amp;悲观锁</h4><h3 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h3><p><strong>原子更新基本类型类</strong>：使用原子的方式<strong>更新基本类型</strong>，包括一下三类：</p><ol><li>AtomicBoolean：原子更新布尔类型</li><li>AtomicInteger：原子更新整型</li><li>AtomicLong：原子更新长整型</li></ol><p>对应的操作：</p><ul><li>public final int **get()**：获取当前的值</li><li>public final int **getAndSet(int newValue)**：获取当前的值，并设置新的值</li><li>public final int **getAndIncrement()**：获取当前的值，并自增1</li><li>public final int **getAndDecrement()**：获取当前的值，并自减1</li><li>public final int **getAndAdd(int delta)**：获取当前的值，并加上预期值delta</li></ul><p><strong>原子更新数组</strong>：通过原子的方式<strong>更新数组里的某个元素</strong>，包括一下三类：</p><ol><li>AtomicIntegerArray：原子更新整型数组</li><li>AtomicLongArray：原子更新长整型数组</li><li>AtomicReferenceArray：原子更新引用类型数组</li></ol><p>对应的操作：</p><ul><li>**get(int index)**：获取索引为index的元素值</li><li>**compareAndSet(int index, E expect, E update)**：如果索引index处的值等于expect，则更新为update</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicIntegerArray</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>先到这里，日后再更新</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列07：消息延迟队列</title>
      <link href="/2024/07/04/MQ07/"/>
      <url>/2024/07/04/MQ07/</url>
      
        <content type="html"><![CDATA[<blockquote><p>怎么实现订单超时自动取消？</p></blockquote><p>kafka不支持延迟消息！但是延迟消息却是经常使用的：</p><p>如在电商、支付等系统中，一般都是先创建订单A or 支付单A，再给用户一定时间进行支付，如果没有按时支付的话，就需要把之前的订单A or 支付单A取消掉。</p><h3 id="延迟队列和延迟消息"><a href="#延迟队列和延迟消息" class="headerlink" title="延迟队列和延迟消息"></a>延迟队列和延迟消息</h3><p>延迟队列是一种特殊的队列，队列中的<strong>每个元素都有一个过期时间</strong>；当元素还<strong>没到过期时间</strong>的时候，如果试图从队列中<strong>获取这个元素</strong>，就会<strong>被阻塞</strong>。而当有<strong>元素过期</strong>时，就会<strong>得到这个元素</strong>——得到的永远是最先过期的元素。</p><p>JDK就自带延迟队列（阻塞队列中的<strong>DelayQueue</strong>）</p><p><strong>延迟消息</strong>，是一种特殊的延迟队列，是<strong>基于消息队列的延迟队列</strong>。——延迟消息指<strong>消息不会立刻被消费，而是经过一段时间后才会被消费。在经过这段时间之前，这个消息一直被存储在消息队列的服务器上</strong>（Question：这个服务器是谁？Producer？Broker？Consumer？）。</p><span id="more"></span><h3 id="如何自己实现延迟消息？"><a href="#如何自己实现延迟消息？" class="headerlink" title="如何自己实现延迟消息？"></a>如何自己实现延迟消息？</h3><p>RabbitMQ中有TTL（Time To Live）即过期时间，可以给消息或者队列设置（若给队列设置则队列中的所有消息都有相同的过期时间），如果队列的生存时间超过设置的TTL则会变成“死信”（Dead Message），放入死信队列中（DLX，Dead-Letter-Exchange）。</p><p>所以，有如下操作：</p><ul><li>准备一个队列Queue，并为这个队列设置过期时间TTL（且这个队列没有消费者）</li><li>将真实的业务biz_Queue绑定到这个Queue，作为它的死信队列</li><li>生产者发送消息到Queue中，因为没有消费者，等TTL时间之后，消息过期，会将消息转发到死信队列biz_Queue中，此时消费者就可以拿到消息了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ACM模式——树的构建</title>
      <link href="/2024/06/29/ACM%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/"/>
      <url>/2024/06/29/ACM%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 起因——近期遇到的一个笔试题需要使用ACM模式构建树来解题， 后面找到“<a href="https://kamacoder.com/">卡码网</a>”练习21-23题+51题（24 25不知道是不是做一下再说）</p></blockquote><p>逐渐理解了ACM模式和核心代码模式的区别与共通部分——<strong>Solution部分相同</strong></p><ul><li>ACM模式在Main类中的main方法中处理输入参数，之后再完成代码执行逻辑</li><li>核心代码模式不需要处理入参，只用完成代码的执行逻辑就OK了（相当于ACM的第二部分）</li></ul><p>二叉树的定义代码：（ACM模式中这些都是自己定义的，所以具体实现的方法比较多样化）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">     <span class="type">int</span> val;<span class="comment">//当前位置</span></span><br><span class="line">     <span class="type">int</span> letter;<span class="comment">//字母标识</span></span><br><span class="line">     TreeNode left;<span class="comment">//左右节点</span></span><br><span class="line">     TreeNode right;</span><br><span class="line">    </span><br><span class="line">     TreeNode() &#123;&#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val,<span class="type">int</span> letter) &#123;</span><br><span class="line">         <span class="built_in">this</span>.val = val; </span><br><span class="line">         <span class="built_in">this</span>.letter = letter; </span><br><span class="line">     &#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">         <span class="built_in">this</span>.val = val;</span><br><span class="line">         <span class="built_in">this</span>.left = left;</span><br><span class="line">         <span class="built_in">this</span>.right = right;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="21-构造二叉树"><a href="#21-构造二叉树" class="headerlink" title="21. 构造二叉树"></a><a href="https://kamacoder.com/problempage.php?pid=1020">21. 构造二叉树</a></h3><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-3-T21P1.png" alt="2024-7-3-T21P1"></p><p>这个题目和<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">leetcode中对应的题目</a>不是一样的问法：此题<strong>只要求返回后序遍历的结果</strong>，所以不需要真的构建二叉树进行操作。</p><p><strong>前序遍历</strong>的特点是：根节点总是在前序遍历的第一个位置。<br><strong>中序遍历</strong>的特点是：根节点总是在左子树和右子树的中间位置。</p><p>所以可以通过前序遍历找到根节点，然后在中序遍历中找到根节点的位置，将中序遍历分为左子树和右子树。然后对左子树和右子树分别进行同样的操作，直到子树为空。    </p><p><strong>后序遍历</strong>的特点是：根节点总是在最后一个位置。<br>所以可以通过<strong>递归</strong>的方式，<strong>先找到左子树和右子树的后序遍历，然后再加上根节点，就可以得到整棵树的后序遍历</strong>。</p><p><strong>详细的解题步骤：</strong></p><ol><li>通过<strong>前序遍历找到根节点的值</strong>。</li><li>在<strong>中序遍历中找到根节点的位置</strong>，将中序遍历分为左子树和右子树。</li><li>对左子树和右子树分别进行同样的操作，直到子树为空。（<strong>递归</strong>）</li><li>通过递归的方式，先找到左子树和右子树的后序遍历，然后再加上根节点，就可以得到整棵树的后序遍历。</li><li>返回后序遍历的结果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">            String[] str = in.nextLine().split(<span class="string">&quot; &quot;</span>); <span class="comment">// 根据示例，每一行是一个测试；多行输入时多个测试情况</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">pre</span> <span class="operator">=</span> str[<span class="number">0</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">mid</span> <span class="operator">=</span> str[<span class="number">1</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">post</span> <span class="operator">=</span> solution.change2Back(pre, mid);</span><br><span class="line">            System.out.println(post);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于核心代码模式要写的内容。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">change2Back</span><span class="params">(String pre, String mid)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre.isEmpty())&#123;<span class="comment">//终止条件 子树为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">root</span> <span class="operator">=</span> pre.charAt(<span class="number">0</span>);<span class="comment">//通过前序遍历找到第一个根</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> mid.indexOf(root);<span class="comment">//再通过中序遍历分为左右子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">leftPre</span> <span class="operator">=</span> pre.substring(<span class="number">1</span>, rootIndex+<span class="number">1</span>);<span class="comment">//对于前序遍历，第一个字符是根节点，所以从第二个字符开始，到根节点在中序遍历中的位置</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">leftMid</span> <span class="operator">=</span> mid.substring(<span class="number">0</span>, rootIndex);<span class="comment">//对于中序遍历，从开始到根节点在中序遍历中的位置，这部分就是左子树的中序遍历。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rightPre</span> <span class="operator">=</span> pre.substring(rootIndex+<span class="number">1</span>);<span class="comment">//当只有一个参数时，表示截取从该参数位置开始到字符串末尾的所有字符。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rightMid</span> <span class="operator">=</span> mid.substring(rootIndex+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//合并遵循 左右根序列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">leftPost</span> <span class="operator">=</span> change2Back(leftPre, leftMid);</span><br><span class="line">        <span class="type">String</span> <span class="variable">rightPost</span> <span class="operator">=</span> change2Back(rightPre, rightMid);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> leftPost + rightPost + root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-二叉树的遍历"><a href="#22-二叉树的遍历" class="headerlink" title="22. 二叉树的遍历"></a><a href="https://kamacoder.com/problempage.php?pid=1021">22. 二叉树的遍历</a></h3><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-4-T22P1.png" alt="2024-7-4-T22P1"></p><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-4-T22P2.png" alt="2024-7-4-T22P2"></p><p>这道题有种似曾相识的感觉，但是忘了在哪里见过了。</p><p>算是一道比较简单的题目：构建二叉树，前中后序遍历二叉树。</p><p>因为是ACM模式，所以需要<strong>自定义二叉树的结构</strong>、<strong>自己处理输入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line"></span><br><span class="line">        in.nextLine(); <span class="comment">//切换到下一行</span></span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer, TreeNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        String[][] str = <span class="keyword">new</span> <span class="title class_">String</span>[n + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//标识数组 用来判断根节点 逻辑：在树中当一个节点不是任何节点的子节点时为根节点</span></span><br><span class="line">        <span class="type">boolean</span>[] isRoot = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(isRoot, <span class="literal">true</span>);<span class="comment">//先全部填充</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建所有节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            str[i] = in.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i, (<span class="type">int</span>) str[i][<span class="number">0</span>].charAt(<span class="number">0</span>) - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            map.put(i, node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据str中的内容，构建节点之间的对应关系</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> map.get(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左子树</span></span><br><span class="line">            <span class="keyword">if</span> (str[i][<span class="number">1</span>].equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">                node.left = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Integer.parseInt(str[i][<span class="number">1</span>]);</span><br><span class="line">                node.left = map.get(left);</span><br><span class="line">                isRoot[left] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//右子树</span></span><br><span class="line">            <span class="keyword">if</span> (str[i][<span class="number">2</span>].equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">                node.right = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Integer.parseInt(str[i][<span class="number">2</span>]);</span><br><span class="line">                node.right = map.get(right);</span><br><span class="line">                isRoot[right] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据isRoot设置根节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRoot[i]) &#123;</span><br><span class="line">                root = map.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前序遍历：</span></span><br><span class="line">        preOrder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        inOrder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        postOrder(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print((<span class="type">char</span>) (root.signal + <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        System.out.print((<span class="type">char</span>) (root.signal + <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder(root.left);</span><br><span class="line">        postOrder(root.right);</span><br><span class="line">        System.out.print((<span class="type">char</span>) (root.signal + <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的二叉树节点数据结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> signal;</span><br><span class="line"></span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val, <span class="type">int</span> signal) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.signal = signal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-二叉树的高度"><a href="#23-二叉树的高度" class="headerlink" title="23. 二叉树的高度"></a><a href="https://kamacoder.com/problempage.php?pid=1022">23. 二叉树的高度</a></h3><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-4-T23P1.png" alt="2024-7-4-T23P1"></p><p>这道题之前遇到过，在<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">LeetCode</a>中，只需要构建出对应的二叉树即可，和这里的第一题（T21）也差不多。</p><p>其实就是，根据前序遍历中第一个字符为root，在中序遍历中找对应的位置分割出左右子树，循环遍历……详见T21中的描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            in.nextLine();</span><br><span class="line">            <span class="comment">// 前序遍历</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">preOrder</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">            <span class="comment">// 中序遍历</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">inOrder</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//构建二叉树</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> solution.createTree(preOrder, inOrder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 得到二叉树的高度</span></span><br><span class="line">            System.out.println(solution.getHeight(root, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">createTree</span><span class="params">(String preOrder, String inOrder, <span class="type">int</span> preLeft, <span class="type">int</span> preRight, <span class="type">int</span> inLeft, <span class="type">int</span> inRight)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preLeft &gt; preRight) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在前序遍历中找到root节点的值</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">rootVal</span> <span class="operator">=</span> preOrder.charAt(preLeft);</span><br><span class="line">        <span class="type">int</span> <span class="variable">inIndex</span> <span class="operator">=</span> inLeft;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到中序遍历中root的位置，区分左右子树；</span></span><br><span class="line">        <span class="keyword">for</span> (; inIndex &lt; inRight; inIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inOrder.charAt(inIndex) == rootVal) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//确定左子树的长度，用于确定左子树的范围</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> inIndex - inLeft;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        root.left = createTree(preOrder, inOrder, preLeft + <span class="number">1</span>, preLeft + leftLength, inLeft, inIndex - <span class="number">1</span>);</span><br><span class="line">        root.right = createTree(preOrder, inOrder, preLeft + leftLength + <span class="number">1</span>, preRight, inIndex + <span class="number">1</span>, inRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有下一层，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> height;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有下一层，则高度++</span></span><br><span class="line">        height++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> root.left == <span class="literal">null</span> ? height : getHeight(root.left, height);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> root.right == <span class="literal">null</span> ? height : getHeight(root.right, height);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">char</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">char</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="51-平移二叉树"><a href="#51-平移二叉树" class="headerlink" title="51. 平移二叉树"></a><a href="https://kamacoder.com/problempage.php?pid=1051">51. 平移二叉树</a></h3><blockquote><p>待完成</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列06：消息积压处理</title>
      <link href="/2024/06/28/MQ06/"/>
      <url>/2024/06/28/MQ06/</url>
      
        <content type="html"><![CDATA[<blockquote><p>线上消息积压了，怎么处理？</p></blockquote><p><strong>消息积压的原因</strong>：系统中某个部分出现了性能问题，来不及处理上游发送的消息，导致消息积压</p><p>消息积压主要引出两个问题——如何避免消息积压？如何处理消息积压？</p><h2 id="优化性能来避免消息积压"><a href="#优化性能来避免消息积压" class="headerlink" title="优化性能来避免消息积压"></a>优化性能来避免消息积压</h2><p>消息队列系统中的性能主要体现在，<strong>生产者发消息和消费者收消息</strong>的业务逻辑中。</p><p>对于大多数业务来说，<strong>消息队列本身的处理能力要远大于业务系统的处理能力</strong>。（消息队列执行的业务主要是收发、而业务系统执行的业务逻辑远比消息队列的复杂，所以处理能力较差）</p><p>于是对于“如何优化性能来避免消息积压？”这个问题，我们要关注的是：<strong>在消息收发的两端，业务代码要怎么和消息队列配合，达到一个最佳的性能。</strong></p><span id="more"></span><h3 id="发送端性能优化"><a href="#发送端性能优化" class="headerlink" title="发送端性能优化"></a>发送端性能优化</h3><p>发送端业务代码的处理性能，实际上和消息队列的关系不大，毕竟是发送端先执行自己的业务逻辑产生消息，然后再发送消息。</p><p>因此对于发送端（发送消息）的业务逻辑，只需要注意<strong>设置合适的并发和批量大小</strong>就行。若要提高性能可以提高并发和批量大小（但是两者有时要进行选择：如在线系统比较注重时延，提高批量大小必然会增大时延，所以选择提高并发量来提高性能；离线系统不关心时延，更注重吞吐量，所以增大批量大小就可以了）</p><h3 id="消费端性能优化"><a href="#消费端性能优化" class="headerlink" title="消费端性能优化"></a>消费端性能优化</h3><p><strong>消息队列的性能问题大部分都出现在消费端！</strong>（消费端的消费速度根本不上发送端发送消息速度，就会造成消息积压）——所以系统的<strong>消费端的消费性能要高于生产端的发送性能</strong></p><p>消费端的消费性能提高的方法：</p><ol><li>优化消费业务逻辑</li><li><strong>增加消费端的并发数</strong>（增加Consumer的实例数量），且要同步增加主题中分区的数量，保证Consumer的实例数的分区数量是相等的。（每个分区上只支持单线程消费）</li></ol><h2 id="处理消息积压"><a href="#处理消息积压" class="headerlink" title="处理消息积压"></a>处理消息积压</h2><p>对于系统发生消息积压的情况，需要先解决积压，再分析原因，毕竟保证系统的可用性是首先要解决的问题。快速解决积压的方法就是通过水平扩容增加 Consumer 的实例数量。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java并发笔记06：其余并发安全容器</title>
      <link href="/2024/06/13/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B006/"/>
      <url>/2024/06/13/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B006/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习Java并发时的知识点总结</p></blockquote><p>JUC中除了ConcurrentHashMap之外还有其他的并发安全容器：</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>JUC中主要的<strong>线程安全List</strong></p><p><strong>CopyOnWrite</strong>——当容器需要被修改时，不直接修改当前容器，而是先将当前容器进行Copy，复制出一个新的容器，然后修改新的容器，<strong>修改完成后，再将原容器的引用指向新的容器</strong>（相当于MySQL中的写时复制技术）</p><p>CopyOnWrite的适用场景——<strong>读多写少</strong>；<strong>要求读操作快</strong>，而写操作慢一点也没关系</p><p>ArrayList的经典问题——迭代期间是否允许修改结合内容？</p><ul><li><strong>ArrayList</strong>在迭代期间如果修改结合内容，会<strong>抛出异常</strong>（ConcurrentModificationException）</li><li><strong>CopyOnWriteArrayList</strong>在迭代期间如果修改结合内容，<strong>不会抛出异常</strong>，因为就数据依旧存在，迭代器使用的还是旧数组，不过旧数据可能已经过时了。</li></ul><p>CopyOnWriteArrayList的缺点：</p><ul><li><strong>内存占用</strong>：正如MySQL中的写时复制技术一样，因为要复制，所以内容中会同时有两个对象的内容，会占用内存。</li><li><strong>数据一致性的问题</strong>：因为是CopyOnWrite的逻辑是先修改副本，导致修改的内容对于其他的线程来说不能实时看到，只能修改完成后才能可见。</li></ul><span id="more"></span><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>线程安全队列，且ConcurrentLinkedQueue是<strong>非阻塞队列</strong>，使用<strong>循环<a href="http://yhy1031.cn/2024/07/04/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B007/">CAS</a>实现</strong></p><p><strong>入队过程：（一个死循环）</strong></p><ul><li>定位尾节点</li><li>使用CAS算法将入队节点设置为尾节点的next节点，如果不成功则重试</li></ul><p><strong>适合用在不需要阻塞功能，且并发不是特别剧烈的场景</strong></p><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p><strong>阻塞队列</strong>是支持阻塞的插入和移除方法的队列</p><p><strong>阻塞的插入</strong>：当队列满时，队列会阻塞插入元素的线程，等待队不满（队列中有出队的情况）</p><p><strong>阻塞的移除</strong>：队列为空时，队列会阻塞获取元素的线程，等待队列变为非空</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-2-BQ01.png" alt="2024-7-2-BQ01"></p><p>和常规queue的操作比较类似（add remove<strong>抛异常</strong>、offer poll会<strong>返回值</strong>true or null）</p><h4 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h4><ul><li><strong>ArrayBlockingQueue</strong>：由数据结构组成的有界阻塞队列</li><li><strong>LinkedBlockingQueue</strong>：由链表结构组成的有界阻塞队列。队列的默认和最大长度为Integer.MAX_VALUE</li><li><strong>PriorityBlockingQueue</strong>：支持优先级排序的无界阻塞队列，默认为自然顺序升序排列，但是可以通过重写compareTo()方法实现指定顺序排序</li><li><strong>DelayQueue</strong>：使用优先级队列实现的无界阻塞队列。队列使用PriorityQueue来实现。且<strong>实现Delayed接口</strong>，可以在创建元素时指定多久才能从队列中获取当前元素（缓存有效期、定时任务调度）</li><li><strong>SynchronousQueue</strong>：不存元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。队列本身不存放任何元素（随放随拿）</li><li><strong>LinkedTransferQueue</strong>：链表结构组成的单向无界阻塞队列</li><li><strong>LinkedBlockingDeque</strong>：由链表组成的双向阻塞链表（如Deque）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列05：消息幂等性</title>
      <link href="/2024/06/13/MQ05/"/>
      <url>/2024/06/13/MQ05/</url>
      
        <content type="html"><![CDATA[<blockquote><p>怎么避免消息重复消费？（当时面试时的问题）</p></blockquote><p>消息重复消费场景——伴随着消息传递失败重新发送而发生</p><p>比如说，一个消费订单消息，统计下单金额的微服务，如果没有正确处理重复消息，那就会出现重复统计，导致统计结果错误。</p><h3 id="消息队列的现状"><a href="#消息队列的现状" class="headerlink" title="消息队列的现状"></a>消息队列的现状</h3><p>我们现在常用的大多数消息队列提供的服务质量都是<strong>At least once</strong>（至少一次。消息在传递时，至少会被送达一次；也就是说不会丢消息，<strong>保证了可见性但无法保证消息不会重复</strong>）</p><p>我们期待的是 Exactly once（恰好一次，不允许丢失和重复），但是目前没有厂商能做到这一点</p><h3 id="用幂等性解决重复消息问题"><a href="#用幂等性解决重复消息问题" class="headerlink" title="用幂等性解决重复消息问题"></a>用幂等性解决重复消息问题</h3><blockquote><p> 一般解决重复消息的办法是，在消费端，让我们消费消息的操作具备<strong>幂等性</strong>。<br><strong>At least once + 幂等操作  &#x3D; Exactly once</strong></p></blockquote><p>幂等性，想起了学HTTP的时候，Post和Get关于幂等性和安全性和讨论</p><p><strong>幂等</strong>：用于描述一个操作、方法or服务；幂等操作，<strong>其任意多次执行所产生的影响均与一次执行的影响相同</strong>——所以对于幂等操作，不用担心重复执行会对系统造成任何改变</p><span id="more"></span><h2 id="常用设计幂等操作的方法"><a href="#常用设计幂等操作的方法" class="headerlink" title="常用设计幂等操作的方法"></a>常用设计幂等操作的方法</h2><h3 id="利用数据库的唯一约束实现幂等"><a href="#利用数据库的唯一约束实现幂等" class="headerlink" title="利用数据库的唯一约束实现幂等"></a>利用数据库的唯一约束实现幂等</h3><p>数据库的唯一约束可限定对应字段的记录在数据库中不可能存在第二条！</p><p>根据这条特性，我们可以<strong>设计一个和待消费消息匹配的表</strong>，<strong>将特异性字段设置唯一约束</strong>，保证只存在一条这样的记录，从而保证了消息的幂等性</p><p>如针对转账消息（包括转账单ID、账户ID、变更金额），我们可以创建一张流水转账表（包括这些字段），将转账单ID 和 账户ID 两个字段联合创建唯一约束，保证了表中对于相同转账单ID 和 账户ID 的记录最多只能存在一条</p><p>同样的，Redis中SETNX也可以实现</p><h3 id="为更新的数据设置前置条件"><a href="#为更新的数据设置前置条件" class="headerlink" title="为更新的数据设置前置条件"></a>为更新的数据设置前置条件</h3><p><strong>给数据变更设置一个前置条件，如果满足条件就更新数据，否则拒绝更新数据</strong>。（但是这种操作对消息设计的要求比较高）</p><p>这样设置保证了第一次消费时满足条件可以执行，之后的消费会因为无法满足条件而不能执行（第一次执行后导致了判断条件不再满足）</p><p>另外，如果要更新的数据不是数值，我们可以<strong>将前置条件改为数据的版本号，和当前版本号一致则可更新</strong></p><h3 id="记录并检查操作——Token机制-or-GUID-全局唯一ID-机制"><a href="#记录并检查操作——Token机制-or-GUID-全局唯一ID-机制" class="headerlink" title="记录并检查操作——Token机制 or GUID(全局唯一ID)机制"></a>记录并检查操作——Token机制 or GUID(全局唯一ID)机制</h3><p>思路：<strong>在执行数据更新操作之前，先检查是否执行过这个更新操作</strong>（我当时面试的时候就是往这个方向回答的）</p><p>具体的实现方式：在发送消息时，<strong>给每条消息指定一个全局唯一的ID</strong>；消费时，<strong>先根据这个ID检查这条消息是否被消费过</strong>；如果没有消费过，才更新数据，然后<strong>将消费状态置为已消费</strong></p><p>但是这个方案很难实现，GUID就很难实现了；“检查消费状态”、“更新数据”、“设置消费状态”这三个操作很显然要保证原子性，用事务？锁？都可以，但是都不好解决</p><p>所以这种方法属于是迫不得已的方法了</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列04：消息有序性</title>
      <link href="/2024/06/11/MQ04/"/>
      <url>/2024/06/11/MQ04/</url>
      
        <content type="html"><![CDATA[<blockquote><p>业务上需要顺序消费，怎么保证消息的有序性？</p></blockquote><h2 id="消息顺序消费的困难——时钟有序"><a href="#消息顺序消费的困难——时钟有序" class="headerlink" title="消息顺序消费的困难——时钟有序"></a>消息顺序消费的困难——时钟有序</h2><p>消息队列中，Producer、Broker、Consumer可能分布在不同的服务器上，不同机器的本地时钟会存在时钟偏斜等问题，<strong>本地时间会不一致</strong>，所以不能用消息发送和到达的时间戳作为时序判断的标准</p><p>分布式系统，<strong>缺乏全局时钟</strong>，使用绝对的时间顺序很困难</p><p>如果发生<strong>消息重传</strong>，也会出现消息乱序的情况</p><span id="more"></span><h2 id="不同消息队列对顺序消费的保证——时钟有序"><a href="#不同消息队列对顺序消费的保证——时钟有序" class="headerlink" title="不同消息队列对顺序消费的保证——时钟有序"></a>不同消息队列对顺序消费的保证——时钟有序</h2><p>当前大部分消息队列的应用场景都是集群部署，在全局有序的情况下，无法使用多分区进行性能的优化。在实际开发中，一般是应用<strong>局部有序</strong>，<strong>把业务消息分发到一个固定的分区，也就是单个队列内传输的方式，实现业务上对有序的要求。</strong></p><h3 id="Kafka-顺序消息"><a href="#Kafka-顺序消息" class="headerlink" title="Kafka 顺序消息"></a>Kafka 顺序消息</h3><p>Kafka 保证消息在 Partition 内的顺序，对于需要确保顺序的消息，<strong>发送到同一个 Partition 中</strong>就可以。（单分区天然满足，多分区就要保证上述内容了）</p><p>例如，电商系统中的订单流转信息，我们在写入 Kafka 时通过订单 ID 进行分发，<strong>保证同一个订单 ID 的消息都会被发送到同一个 Partition 中</strong>，这样消费端在消费的时候，可以保证取出数据时是有序的。</p><h3 id="RocketMQ-顺序消息"><a href="#RocketMQ-顺序消息" class="headerlink" title="RocketMQ 顺序消息"></a>RocketMQ 顺序消息</h3><p>RocketMQ 保证消息在同一个 Queue 中的顺序性，也就是可以满足队列的先进先出原则（和Kafka类似）</p><p>如果把对应一个业务主键的消息都路由到同一个 Queue 中就可以实现消息的有序传输，并且 RocketMQ 额外支持 Tag 的方式，可以对业务消息做进一步的拆分，在消费时相对更加灵活。</p><h2 id="消息顺序消费的困难——业务有序"><a href="#消息顺序消费的困难——业务有序" class="headerlink" title="消息顺序消费的困难——业务有序"></a>消息顺序消费的困难——业务有序</h2><p>业务有序就是指<strong>业务的执行流程是有序的</strong></p><p>比如在一个订单状态消息流转的业务场景中，订单会有创建成功、待付款、已支付、已发货的状态，这几个状态之间是单调流动的，也就是说，订单状态的更新需要保证有序性。</p><h3 id="业务有序的实现："><a href="#业务有序的实现：" class="headerlink" title="业务有序的实现："></a>业务有序的实现：</h3><p>除了消息队列自身的顺序消费机制，我们可以合理地对消息进行改造，从业务上实现有序的目的。具体的方式有以下几种。</p><ul><li><p><strong>根据不同的业务场景，以发送端或者消费端时间戳为准</strong></p><p>比如在电商大促的秒杀场景中，如果要对秒杀的请求进行排队，就可以使用秒杀提交时服务端的时间戳，虽然服务端不一定保证时钟一致，但是在这个场景下，我们不需要保证绝对的有序。</p></li><li><p><strong>每次消息发送时生成唯一递增的 ID</strong></p><p>在每次写入消息时，可以考虑添加一个单调递增的序列 ID，在消费端进行消费时，缓存最大的序列 ID，只消费超过当前最大的序列 ID 的消息。这个方案和分布式算法中的 Paxos 很像，虽然无法实现绝对的有序，但是可以保证每次只处理最新的数据，避免一些业务上的不一致问题。</p></li><li><p><strong>通过缓存时间戳的方式</strong></p><p>这种方式的机制和递增 ID 是一致的，即当生产者在发送消息时，添加一个时间戳，消费端在处理消息时，通过缓存时间戳的方式，判断消息产生的时间是否最新，如果不是则丢弃，否则执行下一步。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java并发笔记05：ConcurrentHashMap</title>
      <link href="/2024/06/11/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B005/"/>
      <url>/2024/06/11/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B005/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习Java并发时的知识点总结</p></blockquote><p>之前学习HashMap时，知道HashMap是线程不安全的（Hashtable是线程安全的，但是用的是Synchronized加锁，效率低下），于是引出了JUC中的<strong>ConcurrentHashMap</strong></p><h3 id="锁分段技术——ConcurrentHashMap的并发思想"><a href="#锁分段技术——ConcurrentHashMap的并发思想" class="headerlink" title="锁分段技术——ConcurrentHashMap的并发思想"></a>锁分段技术——ConcurrentHashMap的并发思想</h3><p>将数据分成一段一段的存储，然后给每一段的数据配一把锁，<strong>当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</strong></p><p>解决了HashMap在并发环境中，因为单锁竞争导致效率低下的问题</p><span id="more"></span><h2 id="ConcurrentHashMap——JDK1-7"><a href="#ConcurrentHashMap——JDK1-7" class="headerlink" title="ConcurrentHashMap——JDK1.7"></a>ConcurrentHashMap——JDK1.7</h2><p><strong>Java使用了上面的分段锁机制实现了ConcurrentHashMap</strong></p><p>ConcurrentHashMap在对象中保存了一个<strong>Segment数组——将整个Hash表划分为为多个分段</strong>；每个Segment元素——划分出来的分段，类似一个Hashtable。</p><p>执行操作时，首先根据hash算法定位到元素属于哪个Segment，<strong>对具体的Segment加锁</strong>即可；同时其他的Segment可以被其他线程访问，整个HashMap是不受影响的。</p><p>下图为ConcurrentHashMap的结构，ConcurrentHashMap是由Segment数据结构和HashEntry数据结构组成；<strong>Segment是一种可重入锁</strong>，HashEntry就是存储K-V</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-11-CCHM1.png" alt="2024-6-11-CCHM1"></p><h3 id="初始化（JDK1-7）new-ConcurrentHashMap"><a href="#初始化（JDK1-7）new-ConcurrentHashMap" class="headerlink" title="初始化（JDK1.7）new ConcurrentHashMap( )"></a>初始化（JDK1.7）new ConcurrentHashMap( )</h3><p><strong>初始化参数：</strong></p><ul><li><strong>concurrencyLevel</strong>：并发数，CHM中<strong>Segment的数量</strong>（Segment[]的大小），初始化确定后就不能再变化了，默认为16</li><li><strong>initialCapacity</strong>：初始容量，CHM的初始<strong>HashEntry的总数量</strong>，之后要平均分给每个Segment</li><li><strong>loadFactor</strong>：负载因子，用于<strong>每个Segment内部的HashEntry[]扩容</strong>（Segment[]不能扩容）</li></ul><p><strong>new ConcurrentHashMap( )无参构造函数执行初始化后：</strong></p><ul><li>Segment[]长度为16，默认</li><li>每一个分段 Segment[i]的默认大小为2，且负载因子默认为0.75（这里很有说法，2*0.75&#x3D;1.5取整后为1，也就是初始阈值为1；插入第一个元素不会触发扩容；插入第二个元素会触发第一次扩容）</li><li>初始化了segment[0]，但其他位置还是null</li><li>定义了 segmentShift 移位数 和 segmentMask 掩码，用于之后定位Segment</li></ul><h3 id="定位Segment-——插入or获取元素的前提"><a href="#定位Segment-——插入or获取元素的前提" class="headerlink" title="定位Segment  ——插入or获取元素的前提"></a>定位Segment  ——插入or获取元素的前提</h3><p>segmentFor(hash)</p><p>ConcurrentHashMap会对元素的hashCode进行再散列，得到新的hash值，并使用这个hash值 结合之前的segmentShift 和 segmentMask 进行后续的定位（包括定位segment和entry），其实就是得到确定的Segment下标</p><h3 id="ConcurrentHashMap的操作"><a href="#ConcurrentHashMap的操作" class="headerlink" title="ConcurrentHashMap的操作"></a>ConcurrentHashMap的操作</h3><ol><li><p><strong>get操作</strong></p><p>先算hashcode再经过一次散列得到hash，最后用hash定位Segment，根据key得到value</p><p>这个过程是很<strong>高效</strong>的，因为<strong>不需要加锁！</strong>——将要使用的共享变量都定义为了volatile（弱一致性，不会像读写互斥锁一样保证强一致性，当前共享内存中是什么值，就读取什么值）</p></li><li><p><strong>put操作</strong></p><p>put要写入内容，肯定是<strong>要加锁</strong>的。</p><p>put方法首先要定位到segment（segmentFor方法），然后再Segment中插入（分为：判断是否要扩容、定位插入位置插入）</p><p><strong>扩容时机</strong>：插入前判断是否需要扩容（和hashmap不一样，hashmap是插入后判断是否要扩容）</p></li><li><p><strong>size操作</strong></p><p>要统计整个ConcurrentHashMap的大小，就要统计所有Segment中元素大小求和。</p><p>思路如下：</p><ol><li>Segment中是有全局变量count的，直接<strong>把所有count直接相加</strong>，但是这种方法过程中<strong>count可能会变化</strong></li><li>在上述过程中，<strong>将所有Segment的put、remove、clean方法全部锁住</strong>；保证count不会变化，但是<strong>效率很低</strong></li></ol><p><strong>最终流程：</strong>Segment中是有全局变量count的，直接把所有count直接相加，累计做3次；如果这个过程中，容器的count变化了，那就通过加锁的方式来统计count</p><p><strong>累计做3次的解释：</strong></p><ul><li>如果本次尝试末端Count没有发生变化，就直接返回，不用再尝试了</li><li>如果有变化就进行下一次的尝试，直到尝试3次之后，如果还不行，就加锁</li></ul></li></ol><h2 id="ConcurrentHashMap——JDK1-8"><a href="#ConcurrentHashMap——JDK1-8" class="headerlink" title="ConcurrentHashMap——JDK1.8"></a>ConcurrentHashMap——JDK1.8</h2><p>和JDK1.7的ConcurrentHashMap相比，<strong>移除了Segment</strong>！！</p><p><strong>实现方式</strong>和1.8的HashMap类似——<strong>数组+链表+红黑树</strong></p><p><strong>加锁方式</strong>——**<a href="http://yhy1031.cn/2024/07/04/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B007/">CAS</a>和Synchronized**</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>每个 Node 里面是 key-value 的形式，并且把 value 用 volatile 修饰，以便保证可见性</p><p><strong>执行put操作时：</strong></p><ul><li>如果hash值对应数组位置为<strong>null</strong>，则<strong>用CAS</strong>放入新值（CAS保证单个变量修改的原子性）</li><li>只有对应槽点<strong>有值</strong>的时候，需要<strong>Synchronized加锁</strong>（针对写操作；不会锁住）</li></ul><p></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java并发笔记04：AQS</title>
      <link href="/2024/06/06/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B004/"/>
      <url>/2024/06/06/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B004/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习Java并发时的知识点总结</p></blockquote><p><strong>AQS 即队列同步器</strong>，是用来构建锁 or 其他同步组件的基础框架，AQS<strong>使用一个volatile int成员变量表示同步状态 state</strong>，通过<strong>内置的FIFO队列完成要获取资源的线程的排队工作</strong></p><p><strong>Lock 和 AQS 的关系：</strong></p><p>Lock是面向锁的使用者的，他定义了使用者与锁的交互接口，隐藏了实现细节。</p><p>AQS是面向锁的实现者的，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待与唤醒等底层操作。</p><p>锁和同步器很好的隔离 了使用者和实现者所需关注的领域。</p><span id="more"></span><h3 id="AQS的实现原理分析"><a href="#AQS的实现原理分析" class="headerlink" title="AQS的实现原理分析"></a>AQS的实现原理分析</h3><p>如上所示，AQS中有两个主要的组成</p><ul><li>volatile类型的整数state来表示同步状态<ul><li>state &#x3D; 0 表示没有线程占用同步资源</li><li>state &gt; 0 表示有线程占用资源；&gt; 1 表示该同步资源被占用了很多次（如ReentrantLock，每重入一次就 state++ ）</li></ul></li><li>双向链表的同步队列，通过将等待线程加入同步队列中（只用到FIFO，所以是尾插法），然后再释放同步状态的时候，从同步队列中唤醒等待线程，从而实现了同步机制</li></ul><h3 id="AQS和Monitor的区别"><a href="#AQS和Monitor的区别" class="headerlink" title="AQS和Monitor的区别"></a>AQS和Monitor的区别</h3><p>乍一看两者特别相似——尤其是Monitor中计数器的概念和AQS的state几乎是一样的</p><p>就我目前的理解来看，AQS是Lock（JUC）同步机制的底层实现，Monitor是Synchronized同步机制的底层实现，两者的区别就是Lock和Synchronized的区别</p><h4 id="Lock（ReentrantLock）和Synchronized的异同"><a href="#Lock（ReentrantLock）和Synchronized的异同" class="headerlink" title="Lock（ReentrantLock）和Synchronized的异同"></a>Lock（ReentrantLock）和Synchronized的异同</h4><p><strong>同</strong>：锁的功能是可以实现的（如保护资源线程的安全、可见性、可重入）</p><p><strong>异</strong>：</p><ul><li>Synchronized的加锁和解锁是由内置的Jvm实现的、而Lock需要引入JUC，且加解锁需要lock和unlock手动控制</li><li>Synchronized不如Lock灵活，Lock有lockInterruptibly方法，可以直接退出 or tryLock方法，能获取就获取不能获取就干别的事情；而Synchronized只能等待，直接释放</li><li>Lock有读写锁，读锁可以有多个线程同时拥有，而Synchronized的锁只能被一个线程同时拥有</li><li>Lock可以设置公平 or 非公平</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java并发笔记03：Lock</title>
      <link href="/2024/06/06/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B003/"/>
      <url>/2024/06/06/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B003/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习Java并发时的知识点总结</p></blockquote><p><strong>锁Lock是显示的加锁解锁</strong>，而Synchronized是隐式的锁；Lock的实现在 java.util.concurrent包中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">//如果要多个线程操作同一个系统资源，需要定义全局锁，将锁对象定义为共享资源</span></span><br><span class="line">    lock.lock(); <span class="comment">// 这才是加锁，上面的只是声明了锁对象</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        count += n;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意：</p><ul><li><strong>解锁一定要放在finally中</strong>，确保无论如何都可以解锁</li><li><strong>加锁一定要放在try-catch外</strong>，因为加锁过程如果发生异常，也会进入finally块导致锁无故释放（当然，如果程序本身就不会抛出异常，那么没必要try-catch）</li></ul><p>Lock接口基本是由AQS实现的（下篇文章主要介绍）</p><span id="more"></span><h3 id="重入锁-ReentrantLock"><a href="#重入锁-ReentrantLock" class="headerlink" title="重入锁 ReentrantLock"></a>重入锁 ReentrantLock</h3><p><strong>什么是重入？</strong>：指任意线程在获取到锁之后，能再次获取该锁而不会被锁阻塞</p><p>主要是两个问题：线程再次获取锁、锁的最终释放（对AQS的状态累加实现）</p><h4 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁 &amp; 非公平锁"></a>公平锁 &amp; 非公平锁</h4><blockquote><p>公平 &amp; 非公平只是锁的获取方式！！！</p></blockquote><p>ReentrantLock类内部有三个类</p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/90ac22daf22e0537cb9264567f7ee5c.png" alt="90ac22daf22e0537cb9264567f7ee5c" style="zoom:80%;" /><p><strong>公平锁：</strong>每个线程获取锁的顺序是按照线程访问锁的先后顺序获取的，最前面的线程总是最先获取到锁。 （<strong>保证了时间上的绝对顺序，但是性能差、上下文切换更频繁</strong>）</p><p><strong>非公平锁：</strong>每个线程获取锁的顺序是随机的，并不会遵循先来先得的规则，所有线程会竞争获取锁。（<strong>性能好、但是可能会“饿死”某些线程</strong>）</p><p>和公平锁相比，非公平锁实现tryAcquire() 方法时多了一个hasQueuedPredecessor()方法，用于判断同步队列中是否有前驱节点，用于实现公平</p><p>ReentrantLock默认为非公平锁（且默认实现就是非公平锁）</p><h4 id="公平锁-非公平锁对比"><a href="#公平锁-非公平锁对比" class="headerlink" title="公平锁 &amp; 非公平锁对比"></a>公平锁 &amp; 非公平锁对比</h4><p><strong>公平锁执行流程：</strong></p><p>获取锁时，线程A先将自己添加到同步队列的队尾并休眠；当前持有锁的线程执行完毕释放锁后，会唤醒同步队列中队头线程去获取锁；直到线程A成为队头时，才会被唤醒获取锁（先后顺序）</p><p><strong>非公平锁执行流程：</strong></p><p>线程获取锁时，会<strong>先通过<a href="http://yhy1031.cn/2024/07/04/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B007/">CAS</a>尝试获取锁</strong>，如果获取成功则持有锁，如果获取失败则添加到同步队列的队尾并休眠……后续和公平锁相同（不遵循先后顺序）</p><p><strong>非公平锁比公平锁性能好：</strong></p><p>因为获取公平锁时，一定会<strong>使线程进入同步队列并休眠，在之后轮到这个线程后又唤醒并获取锁</strong>；这个过程中线程会<strong>经过运行状态——休眠状态——运行状态的转变</strong>，这个状态的转变<strong>需要从用户态转换成内核态</strong>（线程切换的调度器在内核中），这个状态转换很慢。</p><p>而获取非公平锁时，每个线程都会先通过 CAS 尝试获取锁，可能直接获取锁继续执行了；<strong>避免了部分线程休眠和恢复的操作，减少状态转换的次数</strong>，所以性能好</p><h3 id="读写锁-ReentrantReadWriteLock"><a href="#读写锁-ReentrantReadWriteLock" class="headerlink" title="读写锁 ReentrantReadWriteLock"></a>读写锁 ReentrantReadWriteLock</h3><p>是一种共享锁（之前的ReentrantLock是独占锁，Mutex互斥锁也是独占的）</p><p>读写锁中在同一时间可以允许多个读线程访问（多个线程持有读锁），但是在写线程访问时，所有的读线程和写线程均被阻塞</p><p>分为readLock() 和 writeLock() 可以获取</p><h4 id="读写锁特性"><a href="#读写锁特性" class="headerlink" title="读写锁特性"></a>读写锁特性</h4><p><strong>公平性</strong>：支持公平和非公平（默认）两种锁的获取方式</p><p><strong>重入</strong>：支持重入、同一线程获取读锁后还能再次获取、同一线程获取写锁后还能再次获取写锁 or 读锁</p><p><strong>锁降级：</strong>按照获取写锁，再获取读锁，再释放写锁的顺序，写锁能够降级为读锁</p><p>但是不支持锁升级，因为从读锁升级为写锁，需要等待所有读锁的释放（如果两个线程都想升级，那就都会等待对方的读锁释放，会死锁）</p><h4 id="读写锁特性——锁降级"><a href="#读写锁特性——锁降级" class="headerlink" title="读写锁特性——锁降级"></a>读写锁特性——锁降级</h4><p>如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。<strong>锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程，最后释放读锁的过程。</strong></p><p>假设一个线程已经持有写锁，<strong>锁降级的步骤</strong>通常如下： 获取写锁——获取读锁——释放写锁——释放读锁</p><ul><li><strong>获取写锁：</strong>首先，线程获取写锁以确保对共享数据的独占访问。 </li><li>写入数据：然后，线程进行数据写入操作。</li><li><strong>获取读锁：</strong>在释放写锁之前，线程获取读锁。 </li><li><strong>释放写锁：</strong>接着，线程释放写锁。此时，由于读锁已经被获取，即使其他线程可以开始获取读锁，但写锁仍然不可用。 </li><li>执行读操作：线程可以安全地执行基于最新数据的读操作。 </li><li><strong>释放读锁：</strong>最后，完成读操作后释放读锁。</li></ul><p><strong>为什么要实现锁降级呢？</strong></p><p>如果当前线程不获取读锁而是直接释放写锁， 假设此刻<strong>另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新</strong>。</p><p>如果当前线程获取读锁，即<strong>遵循锁降级的步骤，则线程T将会被阻塞</strong>，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。（保证了本线程后续操作的可见性，一定是最新的数据）</p><h3 id="Lock-和-Synchronized对比"><a href="#Lock-和-Synchronized对比" class="headerlink" title="Lock 和 Synchronized对比"></a>Lock 和 Synchronized对比</h3><p><strong>相同点</strong></p><ol><li>都是用来保护资源线程安全的（作用相同）</li><li>都可以保证可见性</li><li>Synchronized 和 ReentrantLock 都拥有可重入的特点</li></ol><p><strong>不同点：</strong></p><ol><li><strong>加解锁控制差别：</strong>synchronized的加解锁是由Jvm实现的（属于内置锁），Lock的加解锁需要手动控制，通过lock() 和 unlock() 实现</li><li><strong>Synchronized不够灵活：</strong> <strong>synchronized</strong>一个线程获取锁之后，其他线程想要获取锁<strong>只能等待，只能进入阻塞状态，直到持有锁的线程释放这个锁</strong>，可能这个等待过程会持续很久。 <strong>Lock</strong>可以<strong>使用lockInterruptibly方法</strong>，不想等了可以中断退出，也可以<strong>使用tryLock</strong>获取锁，能获取就获取，不能获取线程也可以去干别的事情，更加灵活。</li><li>Synchronized锁只能同时被一个线程拥有，但是Lock锁没有这个限制：如读锁可以被多个线程同时拥有</li><li>ReentrantLock可以根据自己的需求设置公平锁or非公平锁，但是Synchronized 则不能</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();  <span class="comment">// 创建一个静态锁，所有实例共享</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">testThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(test);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">testThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(test);</span><br><span class="line">        testThread1.start();</span><br><span class="line">        testThread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();  <span class="comment">// 确保锁会被释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java并发笔记02：Synchronized &amp; Volatile</title>
      <link href="/2024/06/05/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B002/"/>
      <url>/2024/06/05/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B002/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习Java并发时的知识点总结</p></blockquote><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>Java中对悲观锁的实现，是synchronized同步块</p><h3 id="Synchronized-之-锁的竞争与升级"><a href="#Synchronized-之-锁的竞争与升级" class="headerlink" title="Synchronized 之 锁的竞争与升级"></a>Synchronized 之 锁的竞争与升级</h3><p>一般来说，锁是不能降级的</p><p>Synchronized的锁有4种状态——无锁、偏向锁、轻量级锁、重量级锁</p><h4 id="底层如何区分呢？"><a href="#底层如何区分呢？" class="headerlink" title="底层如何区分呢？"></a>底层如何区分呢？</h4><p>Synchronized用的锁存储在Java对象头的<strong>Mark word</strong>中</p><p>其中包括指向当前获取锁的对象的指针（轻、重是指针，偏向锁是线程ID）</p><ol><li>锁标志位（2 bit）：轻量级锁为 00，重量级锁为 10，无锁和偏向锁都是 01，11 为GC的标记</li><li>偏向锁标志（1 bit）：未启用偏向锁为0，启用为1——锁标志位无法区分无锁和偏向锁，所以使用偏向锁标志（在锁标志位前 1 bit）</li></ol><p>另外，是否启用偏向锁是提前定义好的，并且有偏向锁启动延迟（延迟之内自动认为没有偏向锁）</p><span id="more"></span><h4 id="偏向锁的竞争与升级"><a href="#偏向锁的竞争与升级" class="headerlink" title="偏向锁的竞争与升级"></a>偏向锁的竞争与升级</h4><p>对象头Mark word中记录的有线程ID，当前线程要访问同步块就需要<strong>竞争偏向锁</strong>：</p><ol><li>当前线程的ID和Mark word中的相同，则放行</li><li>如果不同，则执行CAS操作（<a href="http://yhy1031.cn/2024/07/04/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B007/">CAS介绍</a>），尝试替换Mark word中的线程ID<ol><li>替换成功，则当前线程获得了偏向锁，放行（前一个线程执行完毕 or 当前线程是第一个线程）</li><li>CAS不成功，则要升级为轻量级锁</li></ol></li></ol><p><strong>升级</strong>：将偏向锁撤销（标志位改为0），升级为轻量级锁&#x2F;重量级锁（看后续）</p><h4 id="轻量级锁的竞争与升级"><a href="#轻量级锁的竞争与升级" class="headerlink" title="轻量级锁的竞争与升级"></a>轻量级锁的竞争与升级</h4><p><strong>竞争</strong>：</p><p>（如果没有偏向锁，就自动到这个阶段）</p><p>线程通过 <strong>自旋 + CAS 的方式来竞争轻量级锁</strong>（自旋：占用CPU来反复尝试获取锁，直到获取成功；CAS：compare and swap，详见后续）</p><p>同时竞争的线程，<strong>竞争成功就获得了锁；失败的就自旋等待</strong>（默认认为很快就能释放锁，就在门口等一会）</p><p><strong>升级</strong>：线程<strong>自旋等待了一段时间后</strong>，还是没有获得锁，就将锁升级为重量级锁，自己进入阻塞状态。</p><h4 id="重量级锁的竞争"><a href="#重量级锁的竞争" class="headerlink" title="重量级锁的竞争"></a>重量级锁的竞争</h4><p>重量级锁，线程加锁失败会进入阻塞状态，等待前驱获得线程的锁执行完之后唤醒。</p><h4 id="锁的对比"><a href="#锁的对比" class="headerlink" title="锁的对比"></a>锁的对比</h4><table><thead><tr><th align="left">锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td align="left">偏向锁</td><td>加锁和解锁不需要额外的消耗，执行很快</td><td>如果线程之间存在锁竞争，则锁撤销会有额外的消耗</td><td>适用于只有一个线程访问同步块的场景</td></tr><tr><td align="left">轻量级锁</td><td>竞争锁的线程不会阻塞，提高程序的响应速度</td><td>始终得不到锁的线程，会一直占用CPU自旋</td><td>追求响应时间，同步块执行速度很快</td></tr><tr><td align="left">重量级锁</td><td>线程竞争不会自旋，不消耗CPU</td><td>线程竞争会阻塞，响应时间缓慢</td><td>追求吞吐量，同步块执行速度较慢</td></tr></tbody></table><h3 id="Synchronized-之-Monitor机制"><a href="#Synchronized-之-Monitor机制" class="headerlink" title="Synchronized 之 Monitor机制"></a>Synchronized 之 Monitor机制</h3><p>Monitor机制是synchronized同步块锁机制升级为重量级锁之后的工作机制：</p><p>每个对象都有一个监视器锁。每个Synchronized修饰过的代码当它的monitor被占用时就会处于锁定状态，执行完毕后释放monitor，由其他线程重新获取monitor的所有权</p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>volatile主要作用是保证可见性、而volatile修饰的long 和 double可以保证其原子性</p><p>如果一个字段被声明称volatile，java线程模型（JMM）确保所有线程看到这个变量的值是一样的</p><ul><li><strong>volatile字段修改时</strong>：JMM会<strong>立刻</strong>把该线程对应的本地内存中共享变量值<strong>刷新到主内存中</strong></li><li><strong>当读到一个volatile变量时</strong>：JMM会把该线程<strong>对应的本地内存</strong>置为无效，<strong>线程会从主线程读取共享变量</strong>（保证是新的）</li></ul><p>但是很多时候是不太好用的，如对volatile修饰的int型变量count，count++，会提示Non-atomic operation on volatile field ‘count’，表示不能保证操作的原子性（看之后的原子类 or 加锁）</p><h3 id="Volatile-读写顺序重排规则："><a href="#Volatile-读写顺序重排规则：" class="headerlink" title="Volatile 读写顺序重排规则："></a>Volatile 读写顺序重排规则：</h3><table><thead><tr><th><strong>是否能重排序</strong></th><th><strong>操作二</strong></th><th></th><th></th></tr></thead><tbody><tr><td><strong>操作一</strong></td><td><strong>普通读&#x2F;写</strong></td><td><strong>volatile读</strong></td><td><strong>volatile写</strong></td></tr><tr><td><strong>普通读&#x2F;写</strong></td><td></td><td></td><td><strong>NO</strong></td></tr><tr><td><strong>volatile读</strong></td><td><strong>NO</strong></td><td><strong>NO</strong></td><td><strong>NO</strong></td></tr><tr><td><strong>volatile写</strong></td><td></td><td><strong>NO</strong></td><td><strong>NO</strong></td></tr></tbody></table><p>​<strong>总结：</strong></p><ol><li><strong>volatile读之后的读写操作不能重排到volatile读之前。 （volatile读之后的操作都是最新的数据）</strong></li><li><strong>volatile 写之前的读写操作不能重排到 volatile 写之后。（volatile写之前的操作，经过volatile写之后会更新到共享内存中）</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java并发笔记01：基础</title>
      <link href="/2024/06/05/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B001/"/>
      <url>/2024/06/05/Java%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文用于记录博主在学习Java并发时的知识点总结</p></blockquote><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p><strong>优点</strong>：（Why）</p><ul><li>提高多核CPU的利用率、充分利用多核CPU的计算能力</li><li>方便进行业务拆分、提高业务性能</li></ul><p><strong>缺点</strong>：</p><ul><li>内存泄漏（看下面的线程变量-ThreadLocal）</li><li>线程安全</li><li>死锁</li></ul><p><strong>三个必要因素</strong>：（满足这三个性质，来保证多线程的线程安全）</p><ul><li>可见性（Volatile、Synchronized、Lock）</li><li>原子性（锁、Synchronized）</li><li>有序性（Happens-Before）</li></ul><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>老生常谈的一个概念——<strong>进程是操作系统资源分配的基本单位</strong>、<strong>线程是操作系统调度资源的基本单位</strong></p><p>同一个类的线程共享代码和数据空间</p><span id="more"></span><p>面试被问过</p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/image-20240605153703397.png" alt="image-20240605153703397" style="zoom: 80%;" /><ul><li><strong>NEW</strong>：<strong>初始状态</strong>，线程被创建，但是还没有调用start()方法</li><li><strong>RUNNABLE</strong>：<ul><li><strong>READY</strong>：当线程对象调用了<code>start()</code>方法之后，线程处于<strong>就绪状态</strong>，就绪意味着该线程<strong>可以执行</strong></li><li><strong>RUNNING</strong>：处于就绪状态的线程获得了CPU之后，<strong>真正开始执行run()方法的线程执行体时</strong>，意味着该线程就已经处于<strong>运行状态</strong></li></ul></li><li><strong>BLOCKED</strong>：<strong>阻塞状态</strong>，表示线程阻塞于锁。</li><li><strong>WAITING</strong>：<strong>等待状态</strong>，表示线程进入等待状态（如执行wait join等方法），进入该状态表示当前线程需要等待其他线程做出一些等待动作（通知或中断）</li><li><strong>TIMED_WAITING</strong>：<strong>超时等待状态</strong>，（wait join等方法中设定等待时长）该状态不同于WAITING状态，它可以在指定的时间自行返回。</li><li><strong>TERMINATED</strong>：<strong>终止状态</strong>，表示当前线程已经执行完毕。</li></ul><p>RUNNABLE中READY与RUNNING状态的一次切换，就是一次<strong>上下文切换</strong>：<br>    因为多线程编程中线程个数一般大于CPU核心个数，所以CPU使用时间片轮转的方法实现大量线程有效执行（宏观并行，微观串行）；CPU为每个线程分批时间片，当时间片执行完后，线程会保存自己的状态，并切换到READY状态，让出CPU给其他xian’cheng</p><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>只掌握两种方式：继承Thread &amp; 实现Runnable接口</p><h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><p>要重写run方法（public）</p><p>因为是继承Thread类，所以直接<strong>new一个该类的实例就可以当作一个线程操作</strong>了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;继承Thread类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        instance.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h4><p>实现 Runnable 的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的</p><p>所以<strong>需要new一个Thread对象</strong>（应该是在Runnable中集成的）来实现</p><p>并且<strong>将类的实例传到 Thread 类中</strong>实现线程操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PS：实现Runnable接口比继承Thread类合适</strong></p><ol><li><strong>Java不支持多继承</strong>，如果用extends的话，就不能再继承其他父类，但是可以实现多个接口</li><li>类的线程有可能只要求可执行，如果继承整个Thread类，开销过大</li></ol><h3 id="线程中断——Interrupted"><a href="#线程中断——Interrupted" class="headerlink" title="线程中断——Interrupted"></a>线程中断——Interrupted</h3><p>线程中断不同于阻塞等待这些，它是一个线程的标识（可以用isInterrupted()方法判断），线程可以选择如何去处理这个标识（识别到中断后，不停止，而是去执行后续的操作）</p><p><strong>主要是对处于休眠or阻塞状态的线程进行 Interrupt</strong>：如sleep、wait等方法使线程休眠，而处于休眠状态的线程被中断，则线程可以感受到中短信号——<strong>抛出InterruptedException异常</strong>，在这之前需要把中断标志位消除（即<code>isInterrupted()</code> 判断为falue）再抛出InterruptedException异常</p><p>因为还需要执行后续的内容（try-catch以外的部分），如下图所示</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-6-Interrupted.png" alt="2024-6-6-Interrupted"></p><p>这部分也就意味着不能让线程强行停止，让被中断的线程自行判断下一步怎么进行（如何响应中断，不能贸然停止）</p><h3 id="线程变量——ThreadLocal"><a href="#线程变量——ThreadLocal" class="headerlink" title="线程变量——ThreadLocal"></a>线程变量——ThreadLocal</h3><p>以ThreadLocal对象为key、任意对象为value的存储结构（k-v对，ThreadLocalMap）</p><p><strong>当一个Key-Value对被存储之后，会一直附带在该线程上</strong>（只有这个线程可见）；可以在线程执行的任何位置通过这个ThreadLocal对象取到存入的值（set、get）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrintTimeUtil</span> &#123;</span><br><span class="line">        <span class="comment">// 创建的ThreadLocal对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; OBJECT = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">timeBegin</span><span class="params">()</span>&#123;</span><br><span class="line">            OBJECT.set(System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">timeEnd</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis() - OBJECT.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        PrintTimeUtil.timeBegin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> PrintTimeUtil.timeEnd();</span><br><span class="line">        System.out.println(time + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：5006毫秒</p><h4 id="ThreadLocal的常见用法：在一个线程中传递一些上下文参数"><a href="#ThreadLocal的常见用法：在一个线程中传递一些上下文参数" class="headerlink" title="ThreadLocal的常见用法：在一个线程中传递一些上下文参数"></a>ThreadLocal的常见用法：在一个线程中传递一些上下文参数</h4><p>如：<strong>传递一些请求参数</strong><br>    例如有这样的一个调用：方法的请求入口 → 方法1 → 方法2  → …… → 方法n；<br>    如果<strong>在请求入口处，将请求信息和用户信息放入ThreadLocal中</strong>，那么你可以在这个线程执行的任何地方调用Threadlocal对这些数据进行存取；<br>    否则你需要从请求入口处，通过方法参数的方式，一层一层的传递下来~</p><h4 id="ThreadLocal在不同线程中的应用"><a href="#ThreadLocal在不同线程中的应用" class="headerlink" title="ThreadLocal在不同线程中的应用"></a>ThreadLocal在不同线程中的应用</h4><p><strong>不同线程可以实现访问的是同一个ThreadLocal对象，但是他们针对这个对象的存取结果，也是分开的，线程隔离的。</strong></p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-6-TLP1.png" alt="2024-7-6-TLP1"></p><h4 id="Threadlocal可能会导致内存泄漏"><a href="#Threadlocal可能会导致内存泄漏" class="headerlink" title="Threadlocal可能会导致内存泄漏"></a>Threadlocal可能会导致内存泄漏</h4><p>ThreadLocalMap中key为弱引用、Value为强引用；如果ThreadLocal对象没有被外界强引用，GC时会清理掉key，但是value不会；导致key &#x3D; null而value!&#x3D;null；可能内存泄漏</p><p>（详细原因看之后JVM相关的内容，GC）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列03：消息可靠性</title>
      <link href="/2024/06/01/MQ03/"/>
      <url>/2024/06/01/MQ03/</url>
      
        <content type="html"><![CDATA[<blockquote><p>怎么保证消息不会丢失？</p></blockquote><p>目前主流的消息队列产品都提供了完善的消息可靠性保证机制，完全可以做到在消息传递过程中，即使发生网络中断或者硬件故障，也能确保消息的可靠传递，不丢消息。</p><p>不同的消息队列提供的API不同、配置不同，但是<strong>保证消息可靠传递的实现原理是相同的</strong></p><h2 id="检测消息丢失的方法"><a href="#检测消息丢失的方法" class="headerlink" title="检测消息丢失的方法"></a>检测消息丢失的方法</h2><p><strong>利用消息队列的有序性来验证是否有消息丢失</strong>，在 Producer 给每个发出的消息附加一个连续递增的序号，在 Consumer 端检查这个序号的连续性；和TCP的sqlNum比较相似，如果不连续那就是丢消息了；甚至可以用缺失的序号确定丢失的是哪条消息</p><span id="more"></span><h2 id="确保消息可靠传递"><a href="#确保消息可靠传递" class="headerlink" title="确保消息可靠传递"></a>确保消息可靠传递</h2><p>MQ01中，我们知道消息队列分为三个存成部分：Producer——Broker——Consumer</p><p>同样的，一条消息从生产到消费完成这个过程，可以划分三个阶段：</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-9-MQP1V2.png" alt="2024-6-9-MQP1V2"></p><ul><li>生产阶段：消息从Producer中创建出来，经网络传输发送到Broker端</li><li>存储阶段：消息在Broker中存储</li><li>消费阶段：Consumer从Broker上拉取消息，经网络传输发送给Consumer</li></ul><h3 id="生产阶段"><a href="#生产阶段" class="headerlink" title="生产阶段"></a>生产阶段</h3><p>如图所示，在生产阶段，<strong>MQ通过</strong>最常用的<strong>请求确认机制</strong>（ACK，又是类似TCP），来<strong>保证消息的可靠传输</strong></p><p>当发送消息的方法被调用时，消息队列会把消息发送到Broker，Broker收到消息后会给客户端（此处是Producer）返回一个确认响应（ACK），表明消息已经收到了，客户端收到响应后，就是完成了一次正常的消息发送</p><p>Producer长时间没收到确认响应时，会自动重试；如果重试再失败会告知用户</p><h3 id="存储阶段"><a href="#存储阶段" class="headerlink" title="存储阶段"></a>存储阶段</h3><p>正常情况下，只要Broker正常运行就不会有丢失消息的问题，但是如果Broker出现了故障，如服务器宕机，可能会丢失消息的</p><p><strong>可以通过配置 Broker 参数来避免因为宕机丢消息。</strong></p><p>如配置Broker参数，在收到消息后，<strong>将消息写入磁盘后，再给Producer返回确认响应</strong></p><h3 id="消费阶段"><a href="#消费阶段" class="headerlink" title="消费阶段"></a>消费阶段</h3><p>如图所示，同样为<strong>请求确认机制</strong>保证消息的可靠传输，过程同生产阶段</p><p>但是，<strong>不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。</strong></p><blockquote><p>附：检查 和 添加序号的操作放在拦截器中执行</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2024/06/01/KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2024/06/01/KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>前言：之前上算法课 + 自己刷题都遇到过，每次都感叹KMP的巧妙，但是每次都是看过就过了，下次遇到还是感叹“woc nb”，特记录完整的思路</p><h3 id="什么是KMP"><a href="#什么是KMP" class="headerlink" title="什么是KMP"></a>什么是KMP</h3><p>KMP主要应用在字符串匹配上。主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong>、</p><p><strong>前缀</strong>：对于字符串 abcdxxxxxxyz，abcd就是该字符串的一个前缀</p><p><strong>后缀</strong>：对于字符串 abcdxxxxxxyz，xyz就是该字符串的一个后缀</p><h3 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h3><p>也就是KMP中常说的next数组，<strong>用来回退的</strong>，<strong>它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p><span id="more"></span><h3 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h3><p>假设原串为abcababeabf，匹配串为abeabf</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-KMPP1.png" alt="2024-6-1-KMPP1"></p><h4 id="先看不用KMP，会怎么匹配：（暴力，且不用substring）"><a href="#先看不用KMP，会怎么匹配：（暴力，且不用substring）" class="headerlink" title="先看不用KMP，会怎么匹配：（暴力，且不用substring）"></a>先看不用KMP，会怎么匹配：（暴力，且不用substring）</h4><p>首先在 原串和匹配串分割各自有一个指针执行当前匹配的位置（如图的箭头）：</p><p>第一次匹配的出发点是第一个字符 ‘a’，显然后面的字符是相等的，于是向右移动——直到出现第一个不同的位置（红色箭头）</p><p><img src="C:/Users/14505/Desktop/2024-6-1-KMPP2.png" alt="2024-6-1-KMPP2"></p><p>后面的逻辑就是 暴力匹配 和 <strong>KMP</strong> 不同的地方：</p><p><strong>暴力匹配：</strong></p><ol><li>先将原串的指针移动到本次出发点（’a’）的下一个位置 ‘b’，并且匹配串移动到起始位置</li><li>重复之前的步骤，直到能够匹配成功</li></ol><p>也就是说，对于暴力匹配，一旦匹配失败，<strong>之前遍历的内容就作废</strong>了，换一个出发点重新匹配</p><p><strong>时间复杂度</strong>：O(m * n)</p><h4 id="KMP匹配过程"><a href="#KMP匹配过程" class="headerlink" title="KMP匹配过程"></a>KMP匹配过程</h4><p><strong>首先匹配串会检查之前已经匹配成功的部分中里是否存在相同的「前缀」和「后缀」。如果存在，则跳转到「前缀」的下一个位置继续往下匹配：</strong></p><p>如下图，当前（原串和匹配串）匹配成功的部分为 abcab，其中前缀ab和后缀ab相同，所以可以跳转</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-KMPP3.png" alt="2024-6-1-KMPP3"></p><p>跳转到下一匹配位置后，尝试匹配，发现两个指针的字符对不上，并且此时匹配串指针前面 ab 不存在相同的「前缀」和「后缀」，这时候只能回到匹配串的起始位置重新开始。。。（依次进行循环）</p><p><strong>KMP比暴力快的原因：</strong></p><ul><li>KMP利用已匹配的部分中相同的「前缀」和「后缀」来加速下一次的匹配</li><li>KMP的原串不会进行回溯（没有暴力中回到下一个出发点的过程）</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>和常规的暴力相比，KMP增加了检查「前缀」和「后缀」的过程，其目的是「为了确定匹配串中的下一段开始匹配的位置」，所以要考虑如何实现这个检查</p><p>有这么一个结论——<strong>对于匹配串的任意一个位置而言，由该位置发起的下一个匹配点位置其实与原串无关。</strong></p><p>怎么理解呢？</p><p>就拿本文的例子来说，对于匹配串 abeabf 中的字符 f 来说，由它发起的下一个匹配点跳转必然是字符 e 的位置，因为 f 位置的相同「前缀」和「后缀」字符 ab 的下一个位置就是字符 c</p><p>所以要预处理出前缀表——next数组（用于跳转，当前字符i不匹配了，则next[i]就是同前缀的点，是可以跳转的位置）</p><h4 id="next数组的构建"><a href="#next数组的构建" class="headerlink" title="next数组的构建"></a>next数组的构建</h4><p>对于本题的匹配串 aaabbab</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-nextP1.png" alt="2024-6-1-nextP1"></p><p>起始时next[0] &#x3D; 0，j指针从0位置开始，i指针从1位置开始；</p><ul><li><p>如果p[j] &#x3D;&#x3D; p[i]，则next[i] &#x3D; j+1，且 i 和 j 同时向后移动</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-nextP2.png" alt="2024-6-1-nextP2"></p></li><li><p>如果p[j] !&#x3D; p[i]：将j指针指向迁移位置的next数字多对应的位置——j &#x3D; next[j - 1]，并重新判断p[j] !和 p[i]，直到p[j] &#x3D;&#x3D; p[i] 或者 j &#x3D;&#x3D; 0；且j &#x3D;&#x3D; 0时，next[i] &#x3D; 0，之后 j 不动，i 向后移动</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-nextP3.png" alt="2024-6-1-nextP3"></p></li></ul><p>之后就是循环两种情况</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-nextP4.png" alt="2024-6-1-nextP4"></p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-nextP5.png" alt="2024-6-1-nextP5"></p><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KMP 算法实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ss 原串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pp 匹配串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 匹配串在原串中第一次出现的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String ss, String pp)</span> &#123;</span><br><span class="line">    <span class="comment">// 字符串转为char数组方便操作</span></span><br><span class="line">    <span class="type">char</span>[] s = ss.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] p = pp.toCharArray();</span><br><span class="line">    <span class="type">int</span>[] next = getNext(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匹配过程，用i指针指向原串遍历的位置，j指针是匹配串遍历的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != p[j])</span><br><span class="line">            j = next[j - <span class="number">1</span>]; <span class="comment">// 如果不等，则利用next数组进行跳转</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j == p.length) <span class="keyword">return</span> i - p.length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * next数组构建</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] getNext(<span class="type">char</span>[] p) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> p.length;</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完全按照next构建描述中实现</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">// 定义出对应的i j 指针</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j]) j++;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列02：消息队列选型</title>
      <link href="/2024/06/01/MQ02/"/>
      <url>/2024/06/01/MQ02/</url>
      
        <content type="html"><![CDATA[<blockquote><p>你的项目为什么选择用 rocketmq &#x2F; kafka &#x2F; rabbitmq作为消息队列组件？而不是其他的呢？</p></blockquote><p>选择消息队列的前提：开源、不冷门、消息的可靠传递、Cluster、性能好</p><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ul><li><strong>主题（Topic）</strong> ：消息的种类称为主题，可以说一个主题代表了一类消息，相当于是对消息进行分类，主题就像是数据库中的表。</li><li><strong>分区（partition）</strong> ：主题可以被分为若干个分区，同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的伸缩性。</li><li><strong>批次</strong>：为了提高效率， 消息会分批次写入 Kafka，批次就代指的是一组消息</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>Kafka 与周边生态系统的兼容性是最好的没有之</strong>一，尤其在大数据和流计算领域，几乎所有的相关开源软件系统都会优先支持 Kafka。</p><p>Kafka的<strong>性能很高</strong>（不过和RocketMQ没有量级上的差距），几十万条&#x2F;s</p><p>但是是异步批量的设计，导致同步收发消息的响应时延较高（kafka会把消息攒一批发送）——<strong>不适合在线业务场景</strong></p><p>如果你需要处理海量的消息，像收集日志、监控信息或是前端的埋点这类数据，或是你的应用场景大量使用了大数据、流计算相关的开源产品，那 Kafka 是最适合你的消息队列。</p><span id="more"></span><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><ul><li><strong>Name 服务器（NameServer）</strong> ：充当注册中心，类似 Kafka 中的 Zookeeper。</li><li><strong>Broker</strong>: 一个独立的 RocketMQ 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量。</li><li><strong>主题（Topic）</strong> ：消息的第一级类型，一条消息必须有一个 Topic。</li><li><strong>子主题（Tag）</strong> ：消息的第二级类型，同一业务模块不同目的的消息就可以用相同 Topic 和不同的 Tag 来标识。</li><li><strong>分组（Group）</strong> ：一个组可以订阅多个 Topic，包括生产者组（Producer Group）和消费者组（Consumer Group）。</li><li><strong>队列（Queue）</strong> ：可以类比 Kafka 的分区 Partition。</li></ul><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>阿里巴巴使用Java开发的；<strong>没什么突出的优点，也没什么明显的缺点</strong></p><p>优点：<strong>响应时延要求很高的场景，应该选择使用 RocketMQ。</strong></p><p>缺点：与周边生态系统的集成和兼容程度要略逊一筹。</p><p>如果你的系统使用消息队列主要场景是处理在线业务，比如在交易系统中用消息队列传递订单，那 RocketMQ 的低延迟和金融级的稳定性是你需要的。</p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><strong>优点：</strong></p><ol><li>相当轻量级、容易部署和使用（是大多个人项目选择RabbitMQ的主要原因了吧）</li><li>路由配置很灵活</li><li>支持的编程语言很多</li><li>有插件支持延迟消息</li></ol><p><strong>缺点：</strong></p><ol><li>RabbitMQ对消息堆积的支持不好、消息堆积会导致其性能下降</li><li>RabbitMQ的性能是这几个中最差的（但是也够用了）</li><li>RabbitMQ用Erlang写的，小众；不方便扩展</li></ol><p>消息队列并不是你将要构建系统的主角之一，你对消息队列功能和性能都没有很高的要求，只需要一个开箱即用易于维护的产品，建议使用 RabbitMQ</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-6-1-刷题日记</title>
      <link href="/2024/06/01/2024-6-1-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/06/01/2024-6-1-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="Question-1-反转字符串II"><a href="#Question-1-反转字符串II" class="headerlink" title="Question.1 反转字符串II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/description/">Question.1 反转字符串II</a></h4><blockquote><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul></blockquote><p>整体流程如下：</p><ul><li>剩余字符数目 &gt;2*k，则反转前k个，剩余的k个不变</li><li>k &lt;&#x3D; 剩余字符数目 &lt;2*k，则反转前k个，剩余的不变</li><li>剩余字符数目&lt;k，则全部反转</li></ul><p>总结就是：前k个一定要反转，不满k也要反转；反转完成就向后走2*k格</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">char</span>[] ansArray = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无论后面是多少，总要反转前k个，如果不满k就都反转</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(length - <span class="number">1</span>, start + k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> ansArray[start];</span><br><span class="line">            ansArray[start] = ansArray[end];</span><br><span class="line">            ansArray[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ansArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-2-找出字符串中第一个匹配项的下标"><a href="#Question-2-找出字符串中第一个匹配项的下标" class="headerlink" title="Question.2 找出字符串中第一个匹配项的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">Question.2 找出字符串中第一个匹配项的下标</a></h4><blockquote><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p></blockquote><p>很容易想到，一个个匹配的暴力解法。</p><p>但是可以用字符串匹配算法——<a href="http://yhy1031.cn/2024/06/01/KMP%E7%AE%97%E6%B3%95/">KMP</a></p><h4 id="Question-3-重复的子字符串"><a href="#Question-3-重复的子字符串" class="headerlink" title="Question.3 重复的子字符串"></a><a href="https://leetcode.cn/problems/repeated-substring-pattern/">Question.3 重复的子字符串</a></h4><blockquote><p>给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p></blockquote><p>（自己不会KMP时，用的substring）</p><p>同理，使用KMP算法，但是要明白这个题目的转换</p><p>题目问该字符串是否可以通过由它的一个子串重复多次构成，如果直接用kmp，那么就要不停的分割来用，不合适</p><p>所以就有s+s（去除第一个元素和最后一个元素），来匹配s，</p><p>去除首尾之后，就不会匹配到第一个s和第二个s了</p><p>（代码去看KMP，唯一不一样的为<code>for (int i = 1, j = 0; i &lt; s.length - 1; i++)</code>）</p>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-5-30-刷题日记</title>
      <link href="/2024/05/30/2024-5-30-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/05/30/2024-5-30-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="Question-1-快乐数"><a href="#Question-1-快乐数" class="headerlink" title="Question.1 快乐数"></a><a href="https://leetcode.cn/problems/happy-number/description/">Question.1 快乐数</a></h4><blockquote><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p></blockquote><p>这道题还是挺意思的</p><p><strong>解析如下：</strong></p><p>对于一个数字来说，每个数的平方和显然不会不会一直增大，如9999-&gt;324，表明四位数的平方和最大值为324，所以一个比较大的数是必定会往下掉的</p><p><strong>所以n只有两种情况：</strong>要分析为什么会返回false</p><ol><li>最后变为1</li><li>在一个不大的数字243（999的平方和）以下循环，返回false</li></ol><p>所以，本题就转变成一个链表判断是否有环的题目了</p><span id="more"></span><ol><li><p><strong>常规的HashSet解法</strong>（每次结果塞进去，直到出现1 or 重复）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !seen.contains(n))&#123;</span><br><span class="line">        seen.add(n);</span><br><span class="line">        n = getNext(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">        totalSum += d * d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>快慢指针</strong></p><p>如之前链表的题目，一块一满两个指针，一定会相遇（如<a href="http://yhy1031.cn/2024/05/28/leetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/">环形链表II</a>）</p><p>对于判断条件<code>fastRunner != 1</code>，因为fastrunner跑得快，且如果为1，则下次的 getNext(n) 还是为1，所以用fastrunner是很合适的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slowRunner</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fastRunner</span> <span class="operator">=</span> getNext(n);</span><br><span class="line">    <span class="keyword">while</span> (fastRunner != <span class="number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;</span><br><span class="line">        slowRunner = getNext(slowRunner);</span><br><span class="line">        fastRunner = getNext(getNext(fastRunner));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fastRunner == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">        totalSum += d * d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Question-2-两数之和"><a href="#Question-2-两数之和" class="headerlink" title="Question.2 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/description/">Question.2 两数之和</a></h4><p>map的应用，（关于map的内容可以看，<a href="http://yhy1031.cn/2024/05/27/Java%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">我的文章</a>）</p><p>主要是用到了containsKey方法，判断是否能组成目标和，不能就把当前的数组值放进map中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">complement</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; map.get(complement), i &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-3-四数相加II"><a href="#Question-3-四数相加II" class="headerlink" title="Question.3 四数相加II"></a><a href="https://leetcode.cn/problems/4sum-ii/description/">Question.3 四数相加II</a></h4><p>上面这题的plus版本</p><p>思路也是一样的，定义一个map去存就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">            map.put(i + j, map.getOrDefault(i + j, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> -i - j;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum))</span><br><span class="line">                res += map.get(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-4-赎金信"><a href="#Question-4-赎金信" class="headerlink" title="Question.4 赎金信"></a><a href="https://leetcode.cn/problems/ransom-note/description/">Question.4 赎金信</a></h4><p>和之前的有效的<a href="https://leetcode.cn/problems/valid-anagram/description/">字母异位词</a>比较像，都是定义一个字母表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lengthRansomNote</span> <span class="operator">=</span> ransomNote.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">lengthMagazine</span> <span class="operator">=</span> magazine.length();</span><br><span class="line">    <span class="keyword">if</span> (lengthRansomNote &gt; lengthMagazine)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lengthMagazine; i++) &#123;</span><br><span class="line">        array[magazine.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lengthRansomNote; i++) &#123;</span><br><span class="line">        array[ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span> (array[ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-5-三数之和"><a href="#Question-5-三数之和" class="headerlink" title="Question.5 三数之和"></a><a href="https://leetcode.cn/problems/3sum/description/">Question.5 三数之和</a></h4><blockquote><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p></blockquote><p>乍一看挺吓人的，不让重复，还要和为0，还要拿到结果组成的List</p><p>但是仔细一看，要返回的是值组成的List，而不是下标，所以可以放心的对数组进行操作了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; length - <span class="number">2</span>; k++) &#123;</span><br><span class="line">        <span class="comment">// 第一个一定要是负数</span></span><br><span class="line">        <span class="keyword">if</span> (nums[k] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>, j = length - <span class="number">1</span>;<span class="comment">// 从左右向中间遍历（i只能向右，nums[i]只能变大，j只能向左，nums[j]只能变小）</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[k] + nums[i] + nums[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 整体小了，需要让i向左移</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i])</span><br><span class="line">                    ;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 整体大了，需要j向右移</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j])</span><br><span class="line">                    ;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(nums[k], nums[i], nums[j])));</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j])</span><br><span class="line">                    ;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i])</span><br><span class="line">                    ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-6-四数之和"><a href="#Question-6-四数之和" class="headerlink" title="Question.6 四数之和"></a><a href="https://leetcode.cn/problems/4sum/description/">Question.6 四数之和</a></h4><blockquote><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul></blockquote><p>这个一看，岂不是和上面的题一样嘛，不要下标，不相同，目标和固定，思路相同嘛</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; length - <span class="number">3</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[k + <span class="number">1</span>] + nums[k + <span class="number">2</span>] + nums[k + <span class="number">3</span>] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 后面只会更大</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再嵌套一个三数之和 哈哈哈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> k + <span class="number">1</span>; j &lt; length - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; k + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>, right = length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[k] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[k], nums[j], nums[left], nums[right]));</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[++left])</span><br><span class="line">                        ;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[--right])</span><br><span class="line">                        ;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[++left])</span><br><span class="line">                        ;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[--right])</span><br><span class="line">                        ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ACM模式——Scanner方法</title>
      <link href="/2024/05/28/ACM%E6%A8%A1%E5%BC%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Scanner%E6%96%B9%E6%B3%95/"/>
      <url>/2024/05/28/ACM%E6%A8%A1%E5%BC%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Scanner%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Scanner类是Java标准库提供的一个用于读取输入的类。它可以通过不同的方法从标准输入、文件和字符串等来源读取数据。</p><p>要使用Scanner类，需要先导入java.util包。然后，可以创建一个Scanner对象，并将输入源传递给它进行读取。</p><p>Scanner对象创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="next-与-nextLine"><a href="#next-与-nextLine" class="headerlink" title="next() 与 nextLine()"></a>next() 与 nextLine()</h3><p>两者都是用来读取字符串的</p><p> <strong>next():</strong></p><ul><li>1、一定要读取到有效字符后才可以结束输入。</li><li>2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。</li><li>3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li><li>4、next() 不能得到带有空格的字符串</li></ul><p><strong>nextLine()：</strong></p><ul><li>1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li><li>2、可以获得空白。</li><li>可以用nextLine()方法，只实现换行而不赋值</li></ul><h3 id="常见场景："><a href="#常见场景：" class="headerlink" title="常见场景："></a>常见场景：</h3><p>单行，多行，数值，字符串</p><h4 id="1-单行输入多个参数"><a href="#1-单行输入多个参数" class="headerlink" title="1. 单行输入多个参数"></a>1. 单行输入多个参数</h4><p>以空格等符号进行分割</p><p><strong>输入如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABB CCC DDD  EEE <span class="number">123</span> <span class="number">435</span></span><br></pre></td></tr></table></figure><p><strong>程序如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myScanner</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;输入：&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine();  <span class="comment">// 读取一行</span></span><br><span class="line">System.out.println(<span class="string">&quot;输出：&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">String[] strIn = str.trim().split(<span class="string">&quot; &quot;</span>);  <span class="comment">// 以空格分割</span></span><br><span class="line">System.out.println(Arrays.toString(strIn));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-多行输入多个参数，每行参数个数不定"><a href="#2-多行输入多个参数，每行参数个数不定" class="headerlink" title="2. 多行输入多个参数，每行参数个数不定"></a>2. 多行输入多个参数，每行参数个数不定</h4><p>多行输入元素，其中第一行几个数字表示下面几行的个数，每行可能输入不等数量的参数</p><p>以三行输入为例，第一行输入两个数字m，n，分别表示数组num1和num2的长度，第二行和第三行输入num1和num2的元素，以空格分隔。</p><p><strong>输入如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">10</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">11</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>程序如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Scanner2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;输入：&quot;</span>);</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">// 换成其他数据类型也一样，其他数值类型就修改int跟nextInt就可以了，</span></span><br><span class="line">        <span class="comment">//String就把nextInt()换成next()</span></span><br><span class="line">        </span><br><span class="line">System.out.println(m);</span><br><span class="line">System.out.println(n);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] num1 = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"><span class="type">int</span>[] num2 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">num1[i] = sc.nextInt();  <span class="comment">// 一个一个读取</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(num1));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">num2[i] = sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(num2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：句子缩写"><a href="#例题：句子缩写" class="headerlink" title="例题：句子缩写"></a>例题：<a href="https://kamacoder.com/problempage.php?pid=1013">句子缩写</a></h3><p> <img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-7-8-T14P1.png" alt="2024-7-8-T14P1"></p><p>整个代码以及代码逻辑是很简单的，不过其中“单词之间可能有多个空格”，需要使用正则表达式来分割<code>String[] inputStr = input.split(&quot;\\s+&quot;);</code></p><p>根据本题的输入模式：n + n行，肯定需要有一个<code>int n = in.nextInt(); </code>，之后需要输入题目的词组，而<strong>两者之间一定要换行</strong>，执行<code>in.nextLine();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt(); </span><br><span class="line">        in.nextLine(); <span class="comment">// 重要！！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">            String[] inputStr = input.split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; inputStr.length; j++) &#123;</span><br><span class="line">                System.out.print(Character.toUpperCase(inputStr[j].charAt(<span class="number">0</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一次笔试之后的碎碎念</title>
      <link href="/2024/05/28/%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AF%95%E4%B9%8B%E5%90%8E%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2024/05/28/%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AF%95%E4%B9%8B%E5%90%8E%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>嗐</p><p>时至今日，多次笔试之后，面对ACM模式的代码题还是不大行</p><p>就拿今天的笔试举例，如果不是ACM模式，第一道题30min就AC了，但是因为对Scanner不熟悉，不懂各种读取数据方式的区别。</p><p>本想着最近算法题练的很多了，可以多A几道题，但是不会Scanner。。。。。。折戟沉沙了</p><p>做完第一道题之后心态就不对了。。（真被别人说对了，不练就是不行！！）</p><p>之后还是好好练吧，特别是ACM模式，最近的三次笔试都是ACM模式，但是没练过（自己的问题）</p><p>明天好好看一下相关的内容</p><p>Good Night gays~~</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列01：消息队列基础 &amp; 应用场景</title>
      <link href="/2024/05/28/MQ01/"/>
      <url>/2024/05/28/MQ01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>你的项目为什么用到消息队列？起到什么作用？</p></blockquote><h2 id="消息队列基础"><a href="#消息队列基础" class="headerlink" title="消息队列基础"></a>消息队列基础</h2><p><strong>消息队列是在消息的传输过程中保存消息的容器</strong>，用于接收消息并以文件的方式存储，<strong>一个消息队列可以被一个也可以被多个消费者消费</strong>，包含以下 3 元素：</p><ul><li><strong>Producer：消息生产者</strong>，负责产生和发送消息到 Broker；</li><li><strong>Broker：消息处理中心</strong>，负责消息存储、确认、重试等，一般其中会包含多个 Queue；</li><li><strong>Consumer：消息消费者</strong>，负责从 Broker 中获取消息，并进行相应处理。</li></ul><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/image-20240601180428745.png" alt="image-20240601180428745"></p><p>消息队列包括两种模式——点对点、发布&#x2F;订阅</p><ul><li><p><strong>点对点模式</strong>：多个生产者可以向同一个消息队列发送消息，一个具体的消息只能由一个消费者消费。（不可重复消费）</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-MQP1.png" alt="2024-6-1-MQP1"></p></li><li><p><strong>发布&#x2F;订阅模式</strong>：单个消息可以被多个订阅者并发的获取和处理。</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/2024-6-1-MQP2.png" alt="2024-6-1-MQP2"></p></li></ul><span id="more"></span><h2 id="消息队列的应用场景"><a href="#消息队列的应用场景" class="headerlink" title="消息队列的应用场景"></a>消息队列的应用场景</h2><p>消息队列最常被使用的三种场景：<strong>异步处理</strong>、<strong>服务解耦</strong>和<strong>流量控制</strong>（削峰）</p><p><strong>基本上一切消息队列的应用场景，都是围绕异步、解耦和削峰三个特性来设计的</strong>。反过来也可以说，如果你有一些需要异步、解耦和削峰的需求，那么消息队列就是最合适的工具。</p><p>用秒杀系统深入理解消息队列的作用</p><h3 id="流量控制、削峰——削去秒杀场景下的峰值写流量"><a href="#流量控制、削峰——削去秒杀场景下的峰值写流量" class="headerlink" title="流量控制、削峰——削去秒杀场景下的峰值写流量"></a>流量控制、削峰——削去秒杀场景下的峰值写流量</h3><p>如果没有消息队列，在秒杀场景下，短时间之内数据库的写流量会很高，如果仅对数据做分库分表、数据迁移、活动结束后的缩表则过于麻烦了！！</p><p>所以引入消息队列，来抗住海量的流量——<strong>将秒杀请求暂存在消息队列中，然后业务服务器会响应用户“秒杀结果正在计算中”，释放了系统资源之后再处理其它用户的请求</strong></p><p>我们可以在后台启动多个队列处理程序，执行后续的消费等程序（但是处理程序有限，如果请求过多队列会满，则超出的请求就会被丢弃）</p><p>这就是消息队列在秒杀系统中最主要的作用：<strong>削峰填谷，</strong>也就是说它可以削平短暂的流量高峰，虽说堆积会造成请求被短暂延迟处理，但是只要我们时刻监控消息队列中的堆积长度，在堆积量超过一定量时，增加队列处理机数量，来提升消息的处理能力就好了。（这种设计的优点是：能根据下游的处理能力自动调节流量）</p><h3 id="异步处理——通过异步处理简化秒杀请求中的业务流程"><a href="#异步处理——通过异步处理简化秒杀请求中的业务流程" class="headerlink" title="异步处理——通过异步处理简化秒杀请求中的业务流程"></a>异步处理——通过异步处理简化秒杀请求中的业务流程</h3><p>秒杀场景下，<strong>会有主要的业务逻辑，也会有次要的业务逻辑：</strong>比如说，主要的流程是生成订单、扣减库存；次要的流程可能是我们在下单购买成功之后会给用户发放优惠券，会增加用户的积分等。</p><p>所以当服务端完成前面 2 个步骤，确定本次请求的秒杀结果后，就可以马上给用户返回响应，然后把请求的数据放入消息队列中，由消息队列异步地进行后续的操作。</p><p><strong>消息队列被用于实现服务的异步处理。</strong>这样做的好处是：</p><ul><li>可以更快地返回结果；</li><li>减少等待，自然实现了步骤之间的并发，提升系统总体的性能。</li></ul><h3 id="服务解耦——解耦实现秒杀系统模块之间松耦合"><a href="#服务解耦——解耦实现秒杀系统模块之间松耦合" class="headerlink" title="服务解耦——解耦实现秒杀系统模块之间松耦合"></a>服务解耦——解耦实现秒杀系统模块之间松耦合</h3><p>使用消息队列降低业务系统和数据系统的直接耦合度。</p><p>订单服务在订单变化时发送一条消息到消息队列的一个主题 Order 中，所有下游系统都订阅主题 Order，这样每个下游系统都可以获得一份实时完整的订单数据。</p><h3 id="面试题：为什么一定要用消息队列呢？同步调用不行吗"><a href="#面试题：为什么一定要用消息队列呢？同步调用不行吗" class="headerlink" title="面试题：为什么一定要用消息队列呢？同步调用不行吗"></a>面试题：为什么一定要用消息队列呢？同步调用不行吗</h3><p>其实就是在问：<strong>在这个业务场景下，不异步、不解耦或者不削峰会有什么问题</strong>？</p><ol><li><p><strong>不异步</strong>——<strong>性能差</strong></p><p>因为需要停下来等全部调用完成才可以返回响应。</p><ul><li><p>追问：但是我可以并发调用啊~</p><p>在并发调用的情况下，性能取决于最坏的那个同步调用什么时候返回结果。而正常我们丢一个消息到消息中间件上是很快的。</p><p>但是即便性能损耗可以接收，但是扩展性和可用性就不行了</p></li></ul></li><li><p><strong>不解耦</strong>——扩展性</p><p>在使用消息队列的方案中，新增的下游只需要订阅对应的消息队列就行了；但是同步调用需要新增的下游提供一堆东西很麻烦</p><ul><li>在使用消息队列的情况下，消息发送者完全不关心谁会去消费这些消息。同样地，如果有一个新的业务方要订阅这个消息，它可以自主完成。</li><li>同步调用的时候，上游必须知道下游的接口，然后要知道如何构造请求、如何解析响应，还要联调、测试、上线，整个过程都得和下游密切合作，因此效率特别低，可扩展性很差。</li></ul></li><li><p><strong>不削峰</strong>——可用性</p><p>在使用消息队列的方案中，只需要确保自己把消息发送到了消息队列上，就认为操作已经成功了。（容错高）</p><p>但是，在同步调用方案中，你必须要确保调用所有的下游都成功了才算是成功了。所以你还需要额外考虑部分成功部分失败的问题。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetCode_142_环形链表II</title>
      <link href="/2024/05/28/leetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/"/>
      <url>/2024/05/28/leetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/</url>
      
        <content type="html"><![CDATA[<p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</br><br>如下为修改示例：</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/LeetCode142P1.png" alt="LeetCode142P1"></p><span id="more"></span><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>假设入环前长度为 lengthPre，环的长度为lengthCycle，满指针遍历的节点数为 s，快指针遍历的节点数为 f</p><p>想要找到入环的节点，也就是遍历 lengthPre + k * lengthCycle个节点可以到达，</p><p><strong>相遇情况分析：</strong></p><ol><li><p>fast指针和slow指针不会相遇——fast指针遍历到null，则无环</p></li><li><p><strong>fast &#x3D;&#x3D; slow也即首次相遇</strong>，则 <strong>f &#x3D; 2s</strong> 且 快指针在环中一直在套圈，所以 <strong>f &#x3D; s + n * lengthCycle</strong>——可以得到 f &#x3D; 2n * lengthCycle，s &#x3D; n * lengthCycle</p><p>也就是说，如果<strong>让慢指针（快指针也OK）再走lengthPre长度</strong>，就能凑成lengthPre + k * lengthCycle，到入环节点了</p><p>那么怎么找到这个lengthPre长度呢？那还得是双指针啊！</p></li><li><p><strong>第二次相遇流程</strong></p><ul><li>第一次相遇之后，让快指针重新指向链表头</li><li>每轮快慢指针都只走一个节点</li><li>当走了lengthPre步之后，两者同时到入环节点——再次相遇，且此处为入环节点</li></ul></li></ol><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            <span class="comment">// 第一次相遇</span></span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第二次相遇</span></span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or 下面的可能逻辑更清晰一点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-5-28-刷题日记</title>
      <link href="/2024/05/28/2024-5-28-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/05/28/2024-5-28-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>（捅了链表的老巢了。。。。）</p><h4 id="Question-1-反转链表"><a href="#Question-1-反转链表" class="headerlink" title="Question.1 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">Question.1 反转链表</a></h4><p>常规思路迭代还是挺简单的，选节点+头插法阿巴阿巴~~但是借助了外部空间</p><p>下面是一种<strong>原地反转</strong>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义pre、cur、tmp节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 当前遍历节点的前节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head; </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 临时存储后序的节点</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        tmp = cur.next;</span><br><span class="line">        cur.next = pre; <span class="comment">// 改变了链表的箭头方向</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是题目说可以尝试<strong>递归</strong>，感谢大佬的题解：<a href="https://leetcode.cn/problems/reverse-linked-list/solutions/36710/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">https://leetcode.cn/problems/reverse-linked-list/solutions/36710/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/</a></p><span id="more"></span><p><strong>主要思路：</strong></p><ul><li>也是将指针改为指向前一个node，但是具体实现为：<code>head.next.next = head;</code>（对应的node是head.next，将其指针改为指向head）</li><li>因为是递归，肯定是进入最底层再回溯；所以是从尾部向前反转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) &#123; <span class="comment">// head==null专门为head为空设计的</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的cur就是最后一个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    <span class="comment">//防止链表循环，需要将head.next设置为空</span></span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-2-两两交换链表中的节点"><a href="#Question-2-两两交换链表中的节点" class="headerlink" title="Question.2 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">Question.2 两两交换链表中的节点</a></h4><p>正好用到了递归的思想，和Q1中的思想挺符合的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 这道题好像递归好一点</span></span><br><span class="line">    <span class="keyword">while</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> swapPairs(head.next.next);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    head.next = tail;</span><br><span class="line">    temp.next = head;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-3-删除链表的倒数第-N-个结点"><a href="#Question-3-删除链表的倒数第-N-个结点" class="headerlink" title="Question.3 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">Question.3 删除链表的倒数第 N 个结点</a></h4><p>这个题是我第一次面试出的算法题，印象很深——双指针嘛</p><p>很经典的双指针题目，用双指针实现对倒数第n个元素这个条件进行替换，n + length &#x3D; length + n，所以最后剩下的正好是n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        right = right.next; <span class="comment">// 到了第n-1个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right.next != <span class="literal">null</span>) &#123; <span class="comment">//</span></span><br><span class="line">        right = right.next;</span><br><span class="line">        left = left.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 期望找到倒数第n+1个元素，进行删除操作</span></span><br><span class="line">    left.next = left.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-4-链表相交"><a href="#Question-4-链表相交" class="headerlink" title="Question.4 链表相交"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">Question.4 链表相交</a></h4><p>同为双指针，找相同关系：lengthA + length同 + lengthB &#x3D; lengthB + length同 + lengthA，如果有相交则，一定会有相等的点</p><p>特别厉害的思路和实现逻辑：</p><ul><li>如果不相交，则 <code>lengthA+lengthB = lengthB + lengthA</code> or <code>lengthA = lengthB</code> 两者长度一样，肯定会同时为null，也即相等，跳出循环</li><li>如果相交，则同理，<code>lengthA + length同 + lengthB = lengthB + length同 + lengthA</code>，之后一定是相同的，或者<code>lengthA = lengthB</code>则会提前相交</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> headA;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> headB;</span><br><span class="line">    <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">        left = left == <span class="literal">null</span> ? headB : left.next;</span><br><span class="line">        right = right == <span class="literal">null</span> ? headA : right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-5-环形链表-II"><a href="#Question-5-环形链表-II" class="headerlink" title="Question.5 环形链表 II"></a><a href="http://yhy1031.cn/2024/05/28/leetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/">Question.5 环形链表 II</a></h4><p>同为双指针，快慢指针（点击标题看详解~）</p><h4 id="Question-6-有效的字母异位词"><a href="#Question-6-有效的字母异位词" class="headerlink" title="Question.6 有效的字母异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/description/">Question.6 有效的字母异位词</a></h4><p>平平无奇 字母表</p><h4 id="Question-7-两个数组的交集"><a href="#Question-7-两个数组的交集" class="headerlink" title="Question.7 两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">Question.7 两个数组的交集</a></h4><p>同理，平平无奇，用Set就行，但是有一点：</p><p>如果是Set转为数组的话是不能直接转为基本数据类型的，如int等，只能是String、Integer等包装类</p><p>只能一个个取出对应的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ansArray = <span class="keyword">new</span> <span class="title class_">int</span>[ans.size()]; <span class="comment">//ans是hashSet</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : ans) &#123;</span><br><span class="line">    ansArray[index++] = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列起始</title>
      <link href="/2024/05/27/introduceOfMQ/"/>
      <url>/2024/05/27/introduceOfMQ/</url>
      
        <content type="html"><![CDATA[<p>吸取之前面试美团金融的经验，开始学习消息队列的内容</p><blockquote><p>还记得当时面试官给我出了一道场景题：消息队列中如何避免一个消息被重复消费？</p></blockquote><p>带着这个问题去学习MQ</p><p>老生常谈的两个问题：消息队列是什么？为什么要用消息队列（解决了什么问题）？</p><p><strong>消息队列可以看作暂时存储数据的一个容器，消息队列是一个平衡低速系统和高速系统处理任务时间差的工具</strong></p><p>基本上一切消息队列的应用场景，都是围绕异步、解耦和削峰三个特性来设计的。反过来也可以说，如果你有一些需要异步、解耦和削峰的需求，那么消息队列就是最合适的工具。</p><blockquote><p>PS：博主目前还没有具体用过消息队列，等之后用了会具体某些部分</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java容器部分知识点总结（未完待续）</title>
      <link href="/2024/05/27/Java%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2024/05/27/Java%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="一、通用"><a href="#一、通用" class="headerlink" title="一、通用"></a>一、通用</h3><p>分为Collection（存对象） 和 Map（存两个对象之间映射表），两种接口</p><p>如List、Set等都是接口，ArrayList、HashSet、HashMap等才是实现类，所以初始化对象，如<code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code>可以体现出Java中的多态</p><p>java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。</p><span id="more"></span><h3 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h3><p>以键值对的形式存储和操作数据的容器类型</p><p>主要包括四种实现类：TreeMap、HashMap、LinkedHashMap、HashTable</p><p><strong>TreeMap</strong>——基于<strong>红黑树</strong>实现的一种提供顺序访问的Map（中序遍历）</p><h4 id="HashMap："><a href="#HashMap：" class="headerlink" title="HashMap："></a>HashMap：</h4><ul><li>基于散列表，访问速度快。进行 put 或者 get 操作，可以达到常数时间的性能。</li><li>HashMap最多只允许一条记录的键Key为null；但允许多条记录的值Value为null。</li><li>HashMap中节点数据（Java7中为Entry，Java8中是Node），包含key、value、hash、next四个值</li></ul><ol><li><p><strong>Java7 &amp; HashMap——数组+链表</strong></p><p><strong>数据结构</strong>：数组buckets表示hash值数组，链表用于解决元素的hash冲突</p><p><strong>初始化</strong>：指定buckets的初始容量（默认为16）、负载因子（默认为0.75），若entry数量超过 容量*负载因子则需要扩容并重新hash，扩容为原来二倍</p><p><strong>get()方法</strong>：用于找到指定key的value。该方法调用getEntry(key)获取entry，再由entry.getValue()得到value，所以getEntry是核心（hash算buckets下标，在遍历冲突链条即可）</p><p><strong>put()方法</strong>：将指定的key-value对添加到map中。该方法首先会在map中查询该键值对，如果没有则addEntry头插到对应位置（插入之后要判断是否需要扩容）</p><p><strong>remove()方法</strong>：删除。。</p></li><li><p><strong>Java8 &amp; HashMap——数组+链表+红黑树</strong></p><p>降冲突链查询过程中的开销，引入红黑树——当<strong>容量达到64</strong>，且<strong>链表中的元素达到8个</strong>时，则链表转为红黑树，时间复杂度为O(logN)</p><p>但是只有小于6个时才会转回来</p></li></ol><p><strong>LinkedHashMap</strong>——HashMap的子类，但链表为双向链表维护元素的顺序（插入 or LRU）</p><p><strong>HashTable</strong>——并发安全但不如ConcurrentHashMap效率高，正常又不如HashMap，尽量不用</p><h3 id="三、List"><a href="#三、List" class="headerlink" title="三、List"></a>三、List</h3><p>顺序储存，允许重复</p><p>主要包括三种实现类：ArrayList、LinkedList、Vector（线程安全，但不推荐使用）</p><ul><li><p><strong>ArrayList</strong>：数组（动态数组）——查询效率高但插入效率低</p><p>有两个参数：</p><ul><li>size 当前实际存储的元素个数；</li><li>capacity 表示数组能容纳的元素个数（初始为0，第一次插入后为10）</li></ul><p><strong>扩容</strong>，每次插入前先看当前数组是否能容纳所有元素，如果不能则扩容——创建一个capacity是原来1.5倍的新数组，将现有数组的数据拷贝到新数组中（要尽量避免扩容的操作！！）</p></li><li><p><strong>LinkedList</strong>：双向链表（正常的双向链表）</p><p>但是要明确一点，如Queue也有LinkedList的实现类，但是两者是不一样的！！</p></li></ul><h3 id="四、Set"><a href="#四、Set" class="headerlink" title="四、Set"></a>四、Set</h3><p>不允许重复</p><p>主要包括三种实现类：TreeSet、HashSet、LinkedHashSet（仔细观察会发现和Map的很像）</p><p><strong>TreeSet</strong>——红黑树，自然顺序访问（自然顺序：调用对象的compareTo方法进行比较，升序排列）</p><p><strong>HashSet</strong>——套壳HashMap（Value统一为常量PRESENT）</p><p>LinkedHashSet——套壳LinkedHashMap（同理）</p><h3 id="五、Queue"><a href="#五、Queue" class="headerlink" title="五、Queue"></a>五、Queue</h3><p>主要是PriorityQueue——优先级队列</p><p>Deque（双端队列，Queue的子接口）其实现类：LinkedList、ArrayDeque</p><h3 id="六、其他总结"><a href="#六、其他总结" class="headerlink" title="六、其他总结"></a>六、其他总结</h3><h4 id="Tip0：List、Set、Map之间的区别"><a href="#Tip0：List、Set、Map之间的区别" class="headerlink" title="Tip0：List、Set、Map之间的区别"></a>Tip0：List、Set、Map之间的区别</h4><table><thead><tr><th>比较项目</th><th>List</th><th>Set</th><th>Map</th></tr></thead><tbody><tr><td>继承接口</td><td>Collection</td><td>Collection</td><td>就是自己（没有继承）</td></tr><tr><td>常见实现类</td><td>ArrayList、LinkedList、Vector（继承自AbstractList）</td><td>HashSet、LinkedHashSet、TreeSet（继承自AbstractSet）</td><td>HashMap、HashTable</td></tr><tr><td>常见方法</td><td>add()、remove()、clear()、get()、contains()、size()</td><td>add()、remove()、clear()、contains()、size()</td><td>put()、get()、remove()、clear()、containsKey()、containsValue()、keySet()、values()、size()、</td></tr><tr><td>元素特性</td><td>可重复</td><td>不可重复（使用equals判断）</td><td>不可重复</td></tr><tr><td>顺序</td><td>有序</td><td>无序（实际上用HashCode决定）</td><td></td></tr></tbody></table><h4 id="Tip1：List-和-Queue的区别"><a href="#Tip1：List-和-Queue的区别" class="headerlink" title="Tip1：List 和 Queue的区别"></a>Tip1：List 和 Queue的区别</h4><p><strong>List</strong>：更适合在需要频繁索引访问和控制元素精确位置的场景中使用。</p><p><strong>Queue</strong>：更适合在需要管理按特定顺序处理元素的场景中使用，如在多线程环境中管理任务的分发。</p><h4 id="Tip2：容器中的排序问题"><a href="#Tip2：容器中的排序问题" class="headerlink" title="Tip2：容器中的排序问题"></a>Tip2：容器中的排序问题</h4><p>容器中的排序可以分为3类：无序、插入顺序、大小顺序</p><ul><li>HashMap是无序的</li><li>ArrayList是插入顺序，但是可以通过sort方法对已有元素进行排序（改为了大小排序）</li><li>TreeMap可以根据key进行自定义的大小排序（指定Comparator）</li><li>LinkedHashMap默认是插入顺序，也可以初始化时指定为LRU顺序</li></ul><h4 id="Tip3：其他常用方法：-待补充，记录自己想用但不知道的方法"><a href="#Tip3：其他常用方法：-待补充，记录自己想用但不知道的方法" class="headerlink" title="Tip3：其他常用方法：(待补充，记录自己想用但不知道的方法)"></a>Tip3：其他常用方法：(待补充，记录自己想用但不知道的方法)</h4><ul><li><p><strong>数组和List转换</strong></p><ul><li><p><strong>数组转list</strong>：<code>Arrays.asList(array)</code>不推荐，如果硬要用的话需要数组为包装类数组（基本数据类型不能放进容器中，见文章开头），而且不能对新List进行修改；</p><p>如果硬要用就<code>List&lt;XXX&gt; list = new ArrayList&lt;&gt;(Arrays.asList(array))</code></p><p>详见 <a href="https://www.jianshu.com/p/2b113f487e5e">https://www.jianshu.com/p/2b113f487e5e</a></p></li><li><p><strong>List转数组</strong>：使用List中的toArray方法，<code>list.toArray()</code>，同样如果是ArrayList&lt;Integer&gt;的数组转int数组，也会因为是包装类而不能直接转换，尝试使用<code>inputList.stream().mapToInt(i -&gt; i).toArray()</code></p></li></ul></li><li><p><strong>在map中匹配，有则+1，无则新建</strong>：<code>map.getOrDefault(key, defaultValue;</code>，即<code>map.put(key, map.getOrDefault(key, 0) + 1);</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024.5.27 刷题日记</title>
      <link href="/2024/05/27/2024-5-27-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/05/27/2024-5-27-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="Question-1-二分查找"><a href="#Question-1-二分查找" class="headerlink" title="Question.1 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/description/">Question.1 二分查找</a></h4><p>一道比较简单的题目，但是看到一个比较有趣的评论：</p><blockquote><p>有一天小明到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把小明拦下，要检查一下哪本书没有登记出借。小明正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是小明背着剩下的书走了。 从此，图书馆丢了 N - 1本书。</p></blockquote><p>二分的本质是由mid分出的两部分分别整体满足不同的性质，对于有序数组就是与目标值的大小关系，对于图书测试就是是否会引起警报</p><p>同时也提了一个醒——二分法的应用场景：有序且唯一</p><span id="more"></span><h4 id="Question-2-移除元素"><a href="#Question-2-移除元素" class="headerlink" title="Question.2 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">Question.2 移除元素</a></h4><p><strong>经典双指针问题</strong>，分为两种：</p><ol><li>快慢指针：一个指针快速向前遍历，另一个指针指向要替换的位置</li><li>左右指针：右侧指针来替换左侧指针可以替换的位置</li></ol><h4 id="Question-3-有序数组的平方-Question-4-长度最小的子数组"><a href="#Question-3-有序数组的平方-Question-4-长度最小的子数组" class="headerlink" title="Question.3 有序数组的平方 &amp;&amp; Question.4 长度最小的子数组"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">Question.3 有序数组的平方</a> &amp;&amp; <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">Question.4 长度最小的子数组</a></h4><p>均为双指针问题</p><h4 id="Question-5-螺旋矩阵II"><a href="#Question-5-螺旋矩阵II" class="headerlink" title="Question.5 螺旋矩阵II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">Question.5 螺旋矩阵II</a></h4><p>定义出对应的边界，一层一层的遍历就行了，不用想的那么复杂（找规律什么的）</p><h4 id="Question-6-移除链表元素"><a href="#Question-6-移除链表元素" class="headerlink" title="Question.6 移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">Question.6 移除链表元素</a></h4><p>链表题目经验：<strong>能不对head操作就不对head操作</strong></p><ul><li>应对方法 1：定义一个dummyHead作为头节点，如<code>ListNode dummyHead = new ListNode(0, head);</code></li><li>应对方案 2：直接新建一个临时头，如<code>ListNode temp = head;</code></li></ul><h4 id="Question-7-设计链表"><a href="#Question-7-设计链表" class="headerlink" title="Question.7 设计链表"></a><a href="https://leetcode.cn/problems/design-linked-list/description/">Question.7 设计链表</a></h4><p>可以直接用ListNode类。。。。 平平无奇的一道题</p>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo&amp;next部署流程</title>
      <link href="/2024/05/26/hexo-next-deploy/"/>
      <url>/2024/05/26/hexo-next-deploy/</url>
      
        <content type="html"><![CDATA[<h2 id="1-服务端"><a href="#1-服务端" class="headerlink" title="1. 服务端"></a>1. 服务端</h2><p>首先看git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br><span class="line">git version</span><br></pre></td></tr></table></figure><p>添加新用户——<code>useradd [username]</code></p><p>添加密码——<code>passwd [username]</code></p><p>切换用户——<code>su [username]</code></p><p>进入用户目录——<code>cd  /home/[username]</code></p><p>创建项目目录</p><p><code>mkdir -p projects/blog</code></p><p><code>mkdir repos &amp;&amp; cd repos</code></p><span id="more"></span><p>创建仓库，并初始化</p><p><code>git init  --bare blog.git</code></p><p><code>cd blog.git/hooks</code></p><p>创建钩子：<code>vim  post-receive </code></p><p>post-receive内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">git --work-tree=/home/[username]/projects/blog --git-dir=/home/[username]/repos/blog.git checkout -f</span><br></pre></td></tr></table></figure><p>之后退出vim，继续进行用户相关的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x post-receive # 添加可执行权限</span><br><span class="line">exit # 返回到root用户</span><br><span class="line">chown -R git:git /home/[username]/repos/blog.git # 给用户添加权限</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone [username]@server_ip:/home/[username]/repos/blog.git</span><br></pre></td></tr></table></figure><p>本地建立ssh信任关系(本地执行)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub [username]@server_ip # 建立信任关系</span><br><span class="line">ssh [username]@server_ip # 试一下能不能免密登录</span><br></pre></td></tr></table></figure><p>但是需要先有ssh key，再.ssh中，使用你电脑的账户获取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;email&quot;</span><br></pre></td></tr></table></figure><p>为了安全起见，这个部署用的用户最好只能用git clone等操作，所以需要更改它默认的shell：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells # 查看 git-shell 是否在登录方式里面</span><br><span class="line">which git-shell # 找到git-shell的路径，记下来</span><br><span class="line">vim /etc/shells # 添加到这个里面</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/passwd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">对[username]的部分将</span></span><br><span class="line">/bin/bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">改为</span></span><br><span class="line">/usr/bin/git-shell</span><br></pre></td></tr></table></figure><h2 id="2-部署上线"><a href="#2-部署上线" class="headerlink" title="2.部署上线"></a>2.部署上线</h2><p>记得安装<code>sudo npm install --save hexo-deployer-git</code>否则没法使用git部署</p><p>修改本地hexo配置_config.yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span> <span class="comment"># github地址</span></span><br><span class="line">    <span class="attr">server_ip:</span> [<span class="string">username</span>]<span class="string">@server_ip:/home/[username]/repos/blog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>编辑<code>package.json</code>文件，修改部署脚本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo generate&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clean&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean &quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;deploy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean&amp;&amp; hexo g -d&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo server&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>然后执行<code>npm run deploy</code>就可以把文件部署上去</p><h2 id="3-宝塔-nignx-域名绑定"><a href="#3-宝塔-nignx-域名绑定" class="headerlink" title="3. 宝塔 nignx 域名绑定"></a>3. 宝塔 nignx 域名绑定</h2><ul><li>dns域名解析到服务器ip</li><li>用宝塔创建一个静态网站</li><li>网站目录选择服务器上的仓库</li></ul><h2 id="4-其他问题"><a href="#4-其他问题" class="headerlink" title="4. 其他问题"></a>4. 其他问题</h2><p><strong>npm install hexo-cli -g一直运行不起来</strong></p><p>node版本问题，教程都是14.17.6</p><p>但是我改成16.20.2就OK了</p><p>ln -s &#x2F;www&#x2F;server&#x2F;nodejs&#x2F;v16.20.2&#x2F;bin&#x2F;hexo &#x2F;usr&#x2F;local&#x2F;bin&#x2F;hexo</p><p>参考连接：<a href="https://developer.aliyun.com/article/775005">https://developer.aliyun.com/article/775005</a></p><p><strong>图床</strong> 和Typora一样，使用github做图床了</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>本栏目介绍</title>
      <link href="/2024/05/26/introduce/"/>
      <url>/2024/05/26/introduce/</url>
      
        <content type="html"><![CDATA[<p>博主的算法题刷题日记</p><p>题目来自leetcode，由代码随想录整理</p><ul><li><p>题目目录：<a href="https://programmercarl.com/">https://programmercarl.com/</a></p></li><li><p>题目讲解视频：<a href="https://space.bilibili.com/525438321/channel/collectiondetail?sid=180037">https://space.bilibili.com/525438321/channel/collectiondetail?sid=180037</a></p></li></ul><p>本栏目的内容为博主二刷过程中对题目的思考、解题思路、总结的方法</p><p>包括如下内容：</p><ol><li>每天刷题的思考与问题（每道题都记录，但是不详细）</li><li>刷题时一时半会做不出来的题目 or  一道题目的多种解法</li><li>各种笔试题的题解</li></ol><p>联系博主：<a href="mailto:&#x79;&#x69;&#110;&#x68;&#111;&#110;&#103;&#x79;&#x61;&#110;&#x67;&#53;&#x34;&#54;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;">&#x79;&#x69;&#110;&#x68;&#111;&#110;&#103;&#x79;&#x61;&#110;&#x67;&#53;&#x34;&#54;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;</a></p>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于博主</title>
      <link href="/2024/04/09/introduceMyself/"/>
      <url>/2024/04/09/introduceMyself/</url>
      
        <content type="html"><![CDATA[<p>昵称：4nge1<br>主要方向：Java后端（找工作ing）<br>邮箱：<a href="mailto:&#x79;&#105;&#110;&#104;&#111;&#x6e;&#x67;&#121;&#97;&#x6e;&#x67;&#53;&#52;&#54;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;">&#x79;&#105;&#110;&#104;&#111;&#x6e;&#x67;&#121;&#97;&#x6e;&#x67;&#53;&#52;&#54;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
