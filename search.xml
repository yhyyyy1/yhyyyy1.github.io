<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2024-5-30-刷题日记</title>
      <link href="/2024/05/30/2024-5-30-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/05/30/2024-5-30-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="Question-1-快乐数"><a href="#Question-1-快乐数" class="headerlink" title="Question.1 快乐数"></a><a href="https://leetcode.cn/problems/happy-number/description/">Question.1 快乐数</a></h4><blockquote><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p></blockquote><p>这道题还是挺意思的</p><p><strong>解析如下：</strong></p><p>对于一个数字来说，每个数的平方和显然不会不会一直增大，如9999-&gt;324，表明四位数的平方和最大值为324，所以一个比较大的数是必定会往下掉的</p><p><strong>所以n只有两种情况：</strong>要分析为什么会返回false</p><ol><li>最后变为1</li><li>在一个不大的数字243（999的平方和）以下循环，返回false</li></ol><p>所以，本题就转变成一个链表判断是否有环的题目了</p><span id="more"></span><ol><li><p><strong>常规的HashSet解法</strong>（每次结果塞进去，直到出现1 or 重复）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !seen.contains(n))&#123;</span><br><span class="line">        seen.add(n);</span><br><span class="line">        n = getNext(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">        totalSum += d * d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>快慢指针</strong></p><p>如之前链表的题目，一块一满两个指针，一定会相遇（如<a href="http://yhy1031.cn/2024/05/28/leetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/">环形链表II</a>）</p><p>对于判断条件<code>fastRunner != 1</code>，因为fastrunner跑得快，且如果为1，则下次的 getNext(n) 还是为1，所以用fastrunner是很合适的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slowRunner</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fastRunner</span> <span class="operator">=</span> getNext(n);</span><br><span class="line">    <span class="keyword">while</span> (fastRunner != <span class="number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;</span><br><span class="line">        slowRunner = getNext(slowRunner);</span><br><span class="line">        fastRunner = getNext(getNext(fastRunner));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fastRunner == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">        totalSum += d * d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Question-2-两数之和"><a href="#Question-2-两数之和" class="headerlink" title="Question.2 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/description/">Question.2 两数之和</a></h4><p>map的应用，（关于map的内容可以看，<a href="http://yhy1031.cn/2024/05/27/Java%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">我的文章</a>）</p><p>主要是用到了containsKey方法，判断是否能组成目标和，不能就把当前的数组值放进map中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">complement</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; map.get(complement), i &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-3-四数相加II"><a href="#Question-3-四数相加II" class="headerlink" title="Question.3 四数相加II"></a><a href="https://leetcode.cn/problems/4sum-ii/description/">Question.3 四数相加II</a></h4><p>上面这题的plus版本</p><p>思路也是一样的，定义一个map去存就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">            map.put(i + j, map.getOrDefault(i + j, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> -i - j;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum))</span><br><span class="line">                res += map.get(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-4-赎金信"><a href="#Question-4-赎金信" class="headerlink" title="Question.4 赎金信"></a><a href="https://leetcode.cn/problems/ransom-note/description/">Question.4 赎金信</a></h4><p>和之前的有效的<a href="https://leetcode.cn/problems/valid-anagram/description/">字母异位词</a>比较像，都是定义一个字母表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lengthRansomNote</span> <span class="operator">=</span> ransomNote.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">lengthMagazine</span> <span class="operator">=</span> magazine.length();</span><br><span class="line">    <span class="keyword">if</span> (lengthRansomNote &gt; lengthMagazine)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lengthMagazine; i++) &#123;</span><br><span class="line">        array[magazine.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lengthRansomNote; i++) &#123;</span><br><span class="line">        array[ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span> (array[ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-5-三数之和"><a href="#Question-5-三数之和" class="headerlink" title="Question.5 三数之和"></a><a href="https://leetcode.cn/problems/3sum/description/">Question.5 三数之和</a></h4><blockquote><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p></blockquote><p>乍一看挺吓人的，不让重复，还要和为0，还要拿到结果组成的List</p><p>但是仔细一看，要返回的是值组成的List，而不是下标，所以可以放心的对数组进行操作了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; length - <span class="number">2</span>; k++) &#123;</span><br><span class="line">        <span class="comment">// 第一个一定要是负数</span></span><br><span class="line">        <span class="keyword">if</span> (nums[k] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>, j = length - <span class="number">1</span>;<span class="comment">// 从左右向中间遍历（i只能向右，nums[i]只能变大，j只能向左，nums[j]只能变小）</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[k] + nums[i] + nums[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 整体小了，需要让i向左移</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i])</span><br><span class="line">                    ;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 整体大了，需要j向右移</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j])</span><br><span class="line">                    ;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(nums[k], nums[i], nums[j])));</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[--j])</span><br><span class="line">                    ;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[++i])</span><br><span class="line">                    ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-6-四数之和"><a href="#Question-6-四数之和" class="headerlink" title="Question.6 四数之和"></a><a href="https://leetcode.cn/problems/4sum/description/">Question.6 四数之和</a></h4><blockquote><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul></blockquote><p>这个一看，岂不是和上面的题一样嘛，不要下标，不相同，目标和固定，思路相同嘛</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; length - <span class="number">3</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[k + <span class="number">1</span>] + nums[k + <span class="number">2</span>] + nums[k + <span class="number">3</span>] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 后面只会更大</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再嵌套一个三数之和 哈哈哈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> k + <span class="number">1</span>; j &lt; length - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; k + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>, right = length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[k] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[k], nums[j], nums[left], nums[right]));</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[++left])</span><br><span class="line">                        ;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[--right])</span><br><span class="line">                        ;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[++left])</span><br><span class="line">                        ;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[--right])</span><br><span class="line">                        ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ACM模式算法Scanner方法学习</title>
      <link href="/2024/05/28/ACM%E6%A8%A1%E5%BC%8F%E7%AE%97%E6%B3%95Scanner%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/05/28/ACM%E6%A8%A1%E5%BC%8F%E7%AE%97%E6%B3%95Scanner%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Scanner类是Java标准库提供的一个用于读取输入的类。它可以通过不同的方法从标准输入、文件和字符串等来源读取数据。</p><p>要使用Scanner类，需要先导入java.util包。然后，可以创建一个Scanner对象，并将输入源传递给它进行读取。</p><p>Scanner对象创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="next-与-nextLine"><a href="#next-与-nextLine" class="headerlink" title="next() 与 nextLine()"></a>next() 与 nextLine()</h3><p>两者都是用来读取字符串的</p><p> <strong>next():</strong></p><ul><li>1、一定要读取到有效字符后才可以结束输入。</li><li>2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。</li><li>3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li><li>4、next() 不能得到带有空格的字符串</li></ul><p><strong>nextLine()：</strong></p><ul><li>1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li><li>2、可以获得空白。</li><li>可以用nextLine()方法，只实现换行而不赋值</li></ul><h3 id="常见场景："><a href="#常见场景：" class="headerlink" title="常见场景："></a>常见场景：</h3><p>单行，多行，数值，字符串</p><h4 id="1-单行输入多个参数"><a href="#1-单行输入多个参数" class="headerlink" title="1. 单行输入多个参数"></a>1. 单行输入多个参数</h4><p>以空格等符号进行分割</p><p><strong>输入如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABB CCC DDD  EEE <span class="number">123</span> <span class="number">435</span></span><br></pre></td></tr></table></figure><p><strong>程序如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myScanner</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;输入：&quot;</span>);</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine();  <span class="comment">// 读取一行</span></span><br><span class="line">System.out.println(<span class="string">&quot;输出：&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">String[] strIn = str.trim().split(<span class="string">&quot; &quot;</span>);  <span class="comment">// 以空格分割</span></span><br><span class="line">System.out.println(Arrays.toString(strIn));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-多行输入多个参数，每行参数个数不定"><a href="#2-多行输入多个参数，每行参数个数不定" class="headerlink" title="2. 多行输入多个参数，每行参数个数不定"></a>2. 多行输入多个参数，每行参数个数不定</h4><p>多行输入元素，其中第一行几个数字表示下面几行的个数，每行可能输入不等数量的参数</p><p>以三行输入为例，第一行输入两个数字m，n，分别表示数组num1和num2的长度，第二行和第三行输入num1和num2的元素，以空格分隔。</p><p><strong>输入如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">10</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">11</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>程序如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Scanner2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;输入：&quot;</span>);</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">// 换成其他数据类型也一样，其他数值类型就修改int跟nextInt就可以了，</span></span><br><span class="line">        <span class="comment">//String就把nextInt()换成next()</span></span><br><span class="line">        </span><br><span class="line">System.out.println(m);</span><br><span class="line">System.out.println(n);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] num1 = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"><span class="type">int</span>[] num2 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">num1[i] = sc.nextInt();  <span class="comment">// 一个一个读取</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(num1));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">num2[i] = sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(num2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一次笔试之后的碎碎念</title>
      <link href="/2024/05/28/%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AF%95%E4%B9%8B%E5%90%8E%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2024/05/28/%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AF%95%E4%B9%8B%E5%90%8E%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>嗐</p><p>时至今日，多次笔试之后，面对ACM模式的代码题还是不大行</p><p>就拿今天的笔试举例，如果不是ACM模式，第一道题30min就AC了，但是因为对Scanner不熟悉，不懂各种读取数据方式的区别。</p><p>本想着最近算法题练的很多了，可以多A几道题，但是不会Scanner。。。。。。折戟沉沙了</p><p>做完第一道题之后心态就不对了。。（真被别人说对了，不练就是不行！！）</p><p>之后还是好好练吧，特别是ACM模式，最近的三次笔试都是ACM模式，但是没练过（自己的问题）</p><p>明天好好看一下相关的内容</p><p>Good Night gays~~</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列01：消息队列的应用场景</title>
      <link href="/2024/05/28/MQ01/"/>
      <url>/2024/05/28/MQ01/</url>
      
        <content type="html"><![CDATA[<p>消息队列最常被使用的三种场景：<strong>异步处理</strong>、<strong>服务解耦</strong>和<strong>流量控制</strong>（削峰）</p><p><strong>基本上一切消息队列的应用场景，都是围绕异步、解耦和削峰三个特性来设计的</strong>。反过来也可以说，如果你有一些需要异步、解耦和削峰的需求，那么消息队列就是最合适的工具。</p><p>用秒杀系统深入理解消息队列的作用</p><span id="more"></span><h3 id="流量控制、削峰——削去秒杀场景下的峰值写流量"><a href="#流量控制、削峰——削去秒杀场景下的峰值写流量" class="headerlink" title="流量控制、削峰——削去秒杀场景下的峰值写流量"></a>流量控制、削峰——削去秒杀场景下的峰值写流量</h3><p>如果没有消息队列，在秒杀场景下，短时间之内数据库的写流量会很高，如果仅对数据做分库分表、数据迁移、活动结束后的缩表则过于麻烦了！！</p><p>所以引入消息队列——<strong>将秒杀请求暂存在消息队列中，然后业务服务器会响应用户“秒杀结果正在计算中”，释放了系统资源之后再处理其它用户的请求</strong></p><p>我们可以在后台启动多个队列处理程序，执行后续的消费等程序（但是处理程序有限，如果请求过多队列会满，则超出的请求就会被丢弃）</p><p>这就是消息队列在秒杀系统中最主要的作用：<strong>削峰填谷，</strong>也就是说它可以削平短暂的流量高峰，虽说堆积会造成请求被短暂延迟处理，但是只要我们时刻监控消息队列中的堆积长度，在堆积量超过一定量时，增加队列处理机数量，来提升消息的处理能力就好了。（这种设计的优点是：能根据下游的处理能力自动调节流量）</p><h3 id="异步处理——通过异步处理简化秒杀请求中的业务流程"><a href="#异步处理——通过异步处理简化秒杀请求中的业务流程" class="headerlink" title="异步处理——通过异步处理简化秒杀请求中的业务流程"></a>异步处理——通过异步处理简化秒杀请求中的业务流程</h3><p>秒杀场景下，<strong>会有主要的业务逻辑，也会有次要的业务逻辑：</strong>比如说，主要的流程是生成订单、扣减库存；次要的流程可能是我们在下单购买成功之后会给用户发放优惠券，会增加用户的积分等。</p><p>所以当服务端完成前面 2 个步骤，确定本次请求的秒杀结果后，就可以马上给用户返回响应，然后把请求的数据放入消息队列中，由消息队列异步地进行后续的操作。</p><p><strong>消息队列被用于实现服务的异步处理。</strong>这样做的好处是：</p><ul><li>可以更快地返回结果；</li><li>减少等待，自然实现了步骤之间的并发，提升系统总体的性能。</li></ul><h3 id="服务解耦——解耦实现秒杀系统模块之间松耦合"><a href="#服务解耦——解耦实现秒杀系统模块之间松耦合" class="headerlink" title="服务解耦——解耦实现秒杀系统模块之间松耦合"></a>服务解耦——解耦实现秒杀系统模块之间松耦合</h3><p>使用消息队列降低业务系统和数据系统的直接耦合度。</p><p>订单服务在订单变化时发送一条消息到消息队列的一个主题 Order 中，所有下游系统都订阅主题 Order，这样每个下游系统都可以获得一份实时完整的订单数据。</p><h3 id="面试题：为什么一定要用消息队列呢？同步调用不行吗"><a href="#面试题：为什么一定要用消息队列呢？同步调用不行吗" class="headerlink" title="面试题：为什么一定要用消息队列呢？同步调用不行吗"></a>面试题：为什么一定要用消息队列呢？同步调用不行吗</h3><p>其实就是在问：<strong>在这个业务场景下，不异步、不解耦或者不削峰会有什么问题</strong>？</p><ol><li><p><strong>不异步</strong>——<strong>性能差</strong></p><p>因为需要停下来等全部调用完成才可以返回响应。</p><ul><li><p>追问：但是我可以并发调用啊~</p><p>在并发调用的情况下，性能取决于最坏的那个同步调用什么时候返回结果。而正常我们丢一个消息到消息中间件上是很快的。</p><p>但是即便性能损耗可以接收，但是扩展性和可用性就不行了</p></li></ul></li><li><p><strong>不解耦</strong>——扩展性</p><p>在使用消息队列的方案中，新增的下游只需要订阅对应的消息队列就行了；但是同步调用需要新增的下游提供一堆东西很麻烦</p><ul><li>在使用消息队列的情况下，消息发送者完全不关心谁会去消费这些消息。同样地，如果有一个新的业务方要订阅这个消息，它可以自主完成。</li><li>同步调用的时候，上游必须知道下游的接口，然后要知道如何构造请求、如何解析响应，还要联调、测试、上线，整个过程都得和下游密切合作，因此效率特别低，可扩展性很差。</li></ul></li><li><p><strong>不削峰</strong>——可用性</p><p>在使用消息队列的方案中，只需要确保自己把消息发送到了消息队列上，就认为操作已经成功了。（容错高）</p><p>但是，在同步调用方案中，你必须要确保调用所有的下游都成功了才算是成功了。所以你还需要额外考虑部分成功部分失败的问题。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetCode_142_环形链表II</title>
      <link href="/2024/05/28/leetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/"/>
      <url>/2024/05/28/leetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/</url>
      
        <content type="html"><![CDATA[<p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</br><br>如下为修改示例：</p><p><img src="https://raw.githubusercontent.com/yhyyyy1/MyTypora/master/img/LeetCode142P1.png" alt="LeetCode142P1"></p><span id="more"></span><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>假设入环前长度为 lengthPre，环的长度为lengthCycle，满指针遍历的节点数为 s，快指针遍历的节点数为 f</p><p>想要找到入环的节点，也就是遍历 lengthPre + k * lengthCycle个节点可以到达，</p><p><strong>相遇情况分析：</strong></p><ol><li><p>fast指针和slow指针不会相遇——fast指针遍历到null，则无环</p></li><li><p><strong>fast &#x3D;&#x3D; slow也即首次相遇</strong>，则 <strong>f &#x3D; 2s</strong> 且 快指针在环中一直在套圈，所以 <strong>f &#x3D; s + n * lengthCycle</strong>——可以得到 f &#x3D; 2n * lengthCycle，s &#x3D; n * lengthCycle</p><p>也就是说，如果<strong>让慢指针（快指针也OK）再走lengthPre长度</strong>，就能凑成lengthPre + k * lengthCycle，到入环节点了</p><p>那么怎么找到这个lengthPre长度呢？那还得是双指针啊！</p></li><li><p><strong>第二次相遇流程</strong></p><ul><li>第一次相遇之后，让快指针重新指向链表头</li><li>每轮快慢指针都只走一个节点</li><li>当走了lengthPre步之后，两者同时到入环节点——再次相遇，且此处为入环节点</li></ul></li></ol><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            <span class="comment">// 第一次相遇</span></span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第二次相遇</span></span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or 下面的可能逻辑更清晰一点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-5-28-刷题日记</title>
      <link href="/2024/05/28/2024-5-28-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/05/28/2024-5-28-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>（捅了链表的老巢了。。。。）</p><h4 id="Question-1-反转链表"><a href="#Question-1-反转链表" class="headerlink" title="Question.1 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">Question.1 反转链表</a></h4><p>常规思路迭代还是挺简单的，选节点+头插法阿巴阿巴~~但是借助了外部空间</p><p>下面是一种<strong>原地反转</strong>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义pre、cur、tmp节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 当前遍历节点的前节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head; </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 临时存储后序的节点</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        tmp = cur.next;</span><br><span class="line">        cur.next = pre; <span class="comment">// 改变了链表的箭头方向</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是题目说可以尝试<strong>递归</strong>，感谢大佬的题解：<a href="https://leetcode.cn/problems/reverse-linked-list/solutions/36710/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">https://leetcode.cn/problems/reverse-linked-list/solutions/36710/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/</a></p><span id="more"></span><p><strong>主要思路：</strong></p><ul><li>也是将指针改为指向前一个node，但是具体实现为：<code>head.next.next = head;</code>（对应的node是head.next，将其指针改为指向head）</li><li>因为是递归，肯定是进入最底层再回溯；所以是从尾部向前反转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) &#123; <span class="comment">// head==null专门为head为空设计的</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的cur就是最后一个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    <span class="comment">//防止链表循环，需要将head.next设置为空</span></span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-2-两两交换链表中的节点"><a href="#Question-2-两两交换链表中的节点" class="headerlink" title="Question.2 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">Question.2 两两交换链表中的节点</a></h4><p>正好用到了递归的思想，和Q1中的思想挺符合的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 这道题好像递归好一点</span></span><br><span class="line">    <span class="keyword">while</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> swapPairs(head.next.next);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    head.next = tail;</span><br><span class="line">    temp.next = head;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-3-删除链表的倒数第-N-个结点"><a href="#Question-3-删除链表的倒数第-N-个结点" class="headerlink" title="Question.3 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">Question.3 删除链表的倒数第 N 个结点</a></h4><p>这个题是我第一次面试出的算法题，印象很深——双指针嘛</p><p>很经典的双指针题目，用双指针实现对倒数第n个元素这个条件进行替换，n + length &#x3D; length + n，所以最后剩下的正好是n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        right = right.next; <span class="comment">// 到了第n-1个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right.next != <span class="literal">null</span>) &#123; <span class="comment">//</span></span><br><span class="line">        right = right.next;</span><br><span class="line">        left = left.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 期望找到倒数第n+1个元素，进行删除操作</span></span><br><span class="line">    left.next = left.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-4-链表相交"><a href="#Question-4-链表相交" class="headerlink" title="Question.4 链表相交"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">Question.4 链表相交</a></h4><p>同为双指针，找相同关系：lengthA + length同 + lengthB &#x3D; lengthB + length同 + lengthA，如果有相交则，一定会有相等的点</p><p>特别厉害的思路和实现逻辑：</p><ul><li>如果不相交，则 <code>lengthA+lengthB = lengthB + lengthA</code> or <code>lengthA = lengthB</code> 两者长度一样，肯定会同时为null，也即相等，跳出循环</li><li>如果相交，则同理，<code>lengthA + length同 + lengthB = lengthB + length同 + lengthA</code>，之后一定是相同的，或者<code>lengthA = lengthB</code>则会提前相交</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> headA;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> headB;</span><br><span class="line">    <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">        left = left == <span class="literal">null</span> ? headB : left.next;</span><br><span class="line">        right = right == <span class="literal">null</span> ? headA : right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question-5-环形链表-II"><a href="#Question-5-环形链表-II" class="headerlink" title="Question.5 环形链表 II"></a><a href="http://yhy1031.cn/2024/05/28/leetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/">Question.5 环形链表 II</a></h4><p>同为双指针，快慢指针（点击标题看详解~）</p><h4 id="Question-6-有效的字母异位词"><a href="#Question-6-有效的字母异位词" class="headerlink" title="Question.6 有效的字母异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/description/">Question.6 有效的字母异位词</a></h4><p>平平无奇 字母表</p><h4 id="Question-7-两个数组的交集"><a href="#Question-7-两个数组的交集" class="headerlink" title="Question.7 两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">Question.7 两个数组的交集</a></h4><p>同理，平平无奇，用Set就行，但是有一点：</p><p>如果是Set转为数组的话是不能直接转为基本数据类型的，如int等，只能是String、Integer等包装类</p><p>只能一个个取出对应的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ansArray = <span class="keyword">new</span> <span class="title class_">int</span>[ans.size()]; <span class="comment">//ans是hashSet</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : ans) &#123;</span><br><span class="line">    ansArray[index++] = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列起始</title>
      <link href="/2024/05/27/introduceOfMQ/"/>
      <url>/2024/05/27/introduceOfMQ/</url>
      
        <content type="html"><![CDATA[<p>吸取之前面试美团金融的经验，开始学习消息队列的内容</p><blockquote><p>还记得当时面试官给我出了一道场景题：消息队列中如何避免一个消息被重复消费？</p></blockquote><p>老生常谈的两个问题：消息队列是什么？为什么要用消息队列（解决了什么问题）？</p><p><strong>消息队列可以看作暂时存储数据的一个容器，消息队列是一个平衡低速系统和高速系统处理任务时间差的工具</strong></p><p>基本上一切消息队列的应用场景，都是围绕异步、解耦和削峰三个特性来设计的。反过来也可以说，如果你有一些需要异步、解耦和削峰的需求，那么消息队列就是最合适的工具。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java容器部分知识点总结（未完待续）</title>
      <link href="/2024/05/27/Java%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2024/05/27/Java%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="一、通用"><a href="#一、通用" class="headerlink" title="一、通用"></a>一、通用</h3><p>分为Collection（存对象） 和 Map（存两个对象之间映射表），两种接口</p><p>如List、Set等都是接口，ArrayList、HashSet、HashMap等才是实现类，所以初始化对象，如<code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code>可以体现出Java中的多态</p><p>java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。</p><span id="more"></span><h3 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h3><p>以键值对的形式存储和操作数据的容器类型</p><p>主要包括四种实现类：TreeMap、HashMap、LinkedHashMap、HashTable</p><p><strong>TreeMap</strong>——基于<strong>红黑树</strong>实现的一种提供顺序访问的Map（中序遍历）</p><h4 id="HashMap："><a href="#HashMap：" class="headerlink" title="HashMap："></a>HashMap：</h4><ul><li>基于散列表，访问速度快。进行 put 或者 get 操作，可以达到常数时间的性能。</li><li>HashMap最多只允许一条记录的键Key为null；但允许多条记录的值Value为null。</li><li>HashMap中节点数据（Java7中为Entry，Java8中是Node），包含key、value、hash、next四个值</li></ul><ol><li><p><strong>Java7 &amp; HashMap——数组+链表</strong></p><p><strong>数据结构</strong>：数组buckets表示hash值数组，链表用于解决元素的hash冲突</p><p><strong>初始化</strong>：指定buckets的初始容量（默认为16）、负载因子（默认为0.75），若entry数量超过 容量*负载因子则需要扩容并重新hash，扩容为原来二倍</p><p><strong>get()方法</strong>：用于找到指定key的value。该方法调用getEntry(key)获取entry，再由entry.getValue()得到value，所以getEntry是核心（hash算buckets下标，在遍历冲突链条即可）</p><p><strong>put()方法</strong>：将指定的key-value对添加到map中。该方法首先会在map中查询该键值对，如果没有则addEntry头插到对应位置</p><p><strong>remove()方法</strong>：删除。。</p></li><li><p><strong>Java8 &amp; HashMap——数组+链表+红黑树</strong></p><p>降冲突链查询过程中的开销，引入红黑树——当<strong>容量达到64</strong>，且<strong>链表中的元素达到8个</strong>时，则链表转为红黑树，时间复杂度为O(logN)</p><p>但是只有小于6个时才会转回来</p></li></ol><p><strong>LinkedHashMap</strong>——HashMap的子类，但链表为双向链表维护元素的顺序（插入 or LRU）</p><p><strong>HashTable</strong>——并发安全但不如ConcurrentHashMap效率高，正常又不如HashMap，尽量不用</p><h3 id="三、List"><a href="#三、List" class="headerlink" title="三、List"></a>三、List</h3><p>顺序储存，允许重复</p><p>主要包括三种实现类：ArrayList、LinkedList、Vector（线程安全，但不推荐使用）</p><ul><li><p><strong>ArrayList</strong>：数组（动态数组）——查询效率高但插入效率低</p><p>有两个参数：</p><ul><li>size 当前实际存储的元素个数；</li><li>capacity 表示数组能容纳的元素个数（初始为0，第一次插入后为10）</li></ul><p><strong>扩容</strong>，每次插入前先看当前数组是否能容纳所有元素，如果不能则扩容——创建一个capacity是原来1.5倍的新数组，将现有数组的数据拷贝到新数组中（要尽量避免扩容的操作！！）</p></li><li><p><strong>LinkedList</strong>：双向链表（正常的双向链表）</p><p>但是要明确一点，如Queue也有LinkedList的实现类，但是两者是不一样的！！</p></li></ul><h3 id="四、Set"><a href="#四、Set" class="headerlink" title="四、Set"></a>四、Set</h3><p>不允许重复</p><p>主要包括三种实现类：TreeSet、HashSet、LinkedHashSet（仔细观察会发现和Map的很像）</p><p><strong>TreeSet</strong>——红黑树，自然顺序访问（自然顺序：调用对象的compareTo方法进行比较，升序排列）</p><p><strong>HashSet</strong>——套壳HashMap（Value统一为常量PRESENT）</p><p>LinkedHashSet——套壳LinkedHashMap（同理）</p><h3 id="五、Queue"><a href="#五、Queue" class="headerlink" title="五、Queue"></a>五、Queue</h3><p>主要是PriorityQueue——优先级队列</p><p>Deque（双端队列，Queue的子接口）其实现类：LinkedList、ArrayDeque</p><h3 id="六、其他总结"><a href="#六、其他总结" class="headerlink" title="六、其他总结"></a>六、其他总结</h3><h4 id="Tip0：List、Set、Map之间的区别"><a href="#Tip0：List、Set、Map之间的区别" class="headerlink" title="Tip0：List、Set、Map之间的区别"></a>Tip0：List、Set、Map之间的区别</h4><table><thead><tr><th>比较项目</th><th>List</th><th>Set</th><th>Map</th></tr></thead><tbody><tr><td>继承接口</td><td>Collection</td><td>Collection</td><td>就是自己（没有继承）</td></tr><tr><td>常见实现类</td><td>ArrayList、LinkedList、Vector（继承自AbstractList）</td><td>HashSet、LinkedHashSet、TreeSet（继承自AbstractSet）</td><td>HashMap、HashTable</td></tr><tr><td>常见方法</td><td>add()、remove()、clear()、get()、contains()、size()</td><td>add()、remove()、clear()、contains()、size()</td><td>put()、get()、remove()、clear()、containsKey()、containsValue()、keySet()、values()、size()、</td></tr><tr><td>元素特性</td><td>可重复</td><td>不可重复（使用equals判断）</td><td>不可重复</td></tr><tr><td>顺序</td><td>有序</td><td>无序（实际上用HashCode决定）</td><td></td></tr></tbody></table><h4 id="Tip1：List-和-Queue的区别"><a href="#Tip1：List-和-Queue的区别" class="headerlink" title="Tip1：List 和 Queue的区别"></a>Tip1：List 和 Queue的区别</h4><p><strong>List</strong>：更适合在需要频繁索引访问和控制元素精确位置的场景中使用。</p><p><strong>Queue</strong>：更适合在需要管理按特定顺序处理元素的场景中使用，如在多线程环境中管理任务的分发。</p><h4 id="Tip2：容器中的排序问题"><a href="#Tip2：容器中的排序问题" class="headerlink" title="Tip2：容器中的排序问题"></a>Tip2：容器中的排序问题</h4><p>容器中的排序可以分为3类：无序、插入顺序、大小顺序</p><ul><li>HashMap是无序的</li><li>ArrayList是插入顺序，但是可以通过sort方法对已有元素进行排序（改为了大小排序）</li><li>TreeMap可以根据key进行自定义的大小排序（指定Comparator）</li><li>LinkedHashMap默认是插入顺序，也可以初始化时指定为LRU顺序</li></ul><h4 id="Tip3：其他常用方法：-待补充，记录自己想用但不知道的方法"><a href="#Tip3：其他常用方法：-待补充，记录自己想用但不知道的方法" class="headerlink" title="Tip3：其他常用方法：(待补充，记录自己想用但不知道的方法)"></a>Tip3：其他常用方法：(待补充，记录自己想用但不知道的方法)</h4><p>数组转list：<code>Arrays.asList(array)</code>不推荐，但是前面加上new ArrayLsit()就行，如<code>List list = new ArrayList(Arrays.asList(array));</code></p><p>List转数组：使用List中的toArray方法，<code>list.toArray()</code></p><p>在map中匹配，有则+1，无则新建：<code>map.getOrDefault(key, defaultValue;</code>，即<code>map.put(key, map.getOrDefault(key, 0) + 1);</code></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024.5.27 刷题日记</title>
      <link href="/2024/05/27/2024-5-27-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/05/27/2024-5-27-%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="Question-1-二分查找"><a href="#Question-1-二分查找" class="headerlink" title="Question.1 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/description/">Question.1 二分查找</a></h4><p>一道比较简单的题目，但是看到一个比较有趣的评论：</p><blockquote><p>有一天小明到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把小明拦下，要检查一下哪本书没有登记出借。小明正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是小明背着剩下的书走了。 从此，图书馆丢了 N - 1本书。</p></blockquote><p>二分的本质是由mid分出的两部分分别整体满足不同的性质，对于有序数组就是与目标值的大小关系，对于图书测试就是是否会引起警报</p><p>同时也提了一个醒——二分法的应用场景：有序且唯一</p><span id="more"></span><h4 id="Question-2-移除元素"><a href="#Question-2-移除元素" class="headerlink" title="Question.2 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">Question.2 移除元素</a></h4><p><strong>经典双指针问题</strong>，分为两种：</p><ol><li>快慢指针：一个指针快速向前遍历，另一个指针指向要替换的位置</li><li>左右指针：右侧指针来替换左侧指针可以替换的位置</li></ol><h4 id="Question-3-有序数组的平方-Question-4-长度最小的子数组"><a href="#Question-3-有序数组的平方-Question-4-长度最小的子数组" class="headerlink" title="Question.3 有序数组的平方 &amp;&amp; Question.4 长度最小的子数组"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">Question.3 有序数组的平方</a> &amp;&amp; <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">Question.4 长度最小的子数组</a></h4><p>均为双指针问题</p><h4 id="Question-5-螺旋矩阵II"><a href="#Question-5-螺旋矩阵II" class="headerlink" title="Question.5 螺旋矩阵II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">Question.5 螺旋矩阵II</a></h4><p>定义出对应的边界，一层一层的遍历就行了，不用想的那么复杂（找规律什么的）</p><h4 id="Question-6-移除链表元素"><a href="#Question-6-移除链表元素" class="headerlink" title="Question.6 移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">Question.6 移除链表元素</a></h4><p>链表题目经验：<strong>能不对head操作就不对head操作</strong></p><ul><li>应对方法 1：定义一个dummyHead作为头节点，如<code>ListNode dummyHead = new ListNode(0, head);</code></li><li>应对方案 2：直接新建一个临时头，如<code>ListNode temp = head;</code></li></ul><h4 id="Question-7-设计链表"><a href="#Question-7-设计链表" class="headerlink" title="Question.7 设计链表"></a><a href="https://leetcode.cn/problems/design-linked-list/description/">Question.7 设计链表</a></h4><p>可以直接用ListNode类。。。。 平平无奇的一道题</p>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo&amp;next部署流程</title>
      <link href="/2024/05/26/hexo-next-deploy/"/>
      <url>/2024/05/26/hexo-next-deploy/</url>
      
        <content type="html"><![CDATA[<h2 id="1-服务端"><a href="#1-服务端" class="headerlink" title="1. 服务端"></a>1. 服务端</h2><p>首先看git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br><span class="line">git version</span><br></pre></td></tr></table></figure><p>添加新用户——<code>useradd [username]</code></p><p>添加密码——<code>passwd [username]</code></p><p>切换用户——<code>su [username]</code></p><p>进入用户目录——<code>cd  /home/[username]</code></p><p>创建项目目录</p><p><code>mkdir -p projects/blog</code></p><p><code>mkdir repos &amp;&amp; cd repos</code></p><span id="more"></span><p>创建仓库，并初始化</p><p><code>git init  --bare blog.git</code></p><p><code>cd blog.git/hooks</code></p><p>创建钩子：<code>vim  post-receive </code></p><p>post-receive内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">git --work-tree=/home/[username]/projects/blog --git-dir=/home/[username]/repos/blog.git checkout -f</span><br></pre></td></tr></table></figure><p>之后退出vim，继续进行用户相关的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x post-receive # 添加可执行权限</span><br><span class="line">exit # 返回到root用户</span><br><span class="line">chown -R git:git /home/[username]/repos/blog.git # 给用户添加权限</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone [username]@server_ip:/home/[username]/repos/blog.git</span><br></pre></td></tr></table></figure><p>本地建立ssh信任关系(本地执行)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub [username]@server_ip # 建立信任关系</span><br><span class="line">ssh [username]@server_ip # 试一下能不能免密登录</span><br></pre></td></tr></table></figure><p>但是需要先有ssh key，再.ssh中，使用你电脑的账户获取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;email&quot;</span><br></pre></td></tr></table></figure><p>为了安全起见，这个部署用的用户最好只能用git clone等操作，所以需要更改它默认的shell：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells # 查看 git-shell 是否在登录方式里面</span><br><span class="line">which git-shell # 找到git-shell的路径，记下来</span><br><span class="line">vim /etc/shells # 添加到这个里面</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/passwd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">对[username]的部分将</span></span><br><span class="line">/bin/bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">改为</span></span><br><span class="line">/usr/bin/git-shell</span><br></pre></td></tr></table></figure><h2 id="2-部署上线"><a href="#2-部署上线" class="headerlink" title="2.部署上线"></a>2.部署上线</h2><p>记得安装<code>sudo npm install --save hexo-deployer-git</code>否则没法使用git部署</p><p>修改本地hexo配置_config.yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span> <span class="comment"># github地址</span></span><br><span class="line">    <span class="attr">server_ip:</span> [<span class="string">username</span>]<span class="string">@server_ip:/home/[username]/repos/blog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>编辑<code>package.json</code>文件，修改部署脚本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo generate&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clean&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean &quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;deploy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean&amp;&amp; hexo g -d&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo server&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>然后执行<code>npm run deploy</code>就可以把文件部署上去</p><h2 id="3-宝塔-nignx-域名绑定"><a href="#3-宝塔-nignx-域名绑定" class="headerlink" title="3. 宝塔 nignx 域名绑定"></a>3. 宝塔 nignx 域名绑定</h2><ul><li>dns域名解析到服务器ip</li><li>用宝塔创建一个静态网站</li><li>网站目录选择服务器上的仓库</li></ul><h2 id="4-其他问题"><a href="#4-其他问题" class="headerlink" title="4. 其他问题"></a>4. 其他问题</h2><p><strong>npm install hexo-cli -g一直运行不起来</strong></p><p>node版本问题，教程都是14.17.6</p><p>但是我改成16.20.2就OK了</p><p>ln -s &#x2F;www&#x2F;server&#x2F;nodejs&#x2F;v16.20.2&#x2F;bin&#x2F;hexo &#x2F;usr&#x2F;local&#x2F;bin&#x2F;hexo</p><p>参考连接：<a href="https://developer.aliyun.com/article/775005">https://developer.aliyun.com/article/775005</a></p><p><strong>图床</strong> 和Typora一样，使用github做图床了</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>本栏目介绍</title>
      <link href="/2024/05/26/introduce/"/>
      <url>/2024/05/26/introduce/</url>
      
        <content type="html"><![CDATA[<p>博主的算法题刷题日记</p><p>题目来自leetcode，由代码随想录整理</p><ul><li><p>题目目录：<a href="https://programmercarl.com/">https://programmercarl.com/</a></p></li><li><p>题目讲解视频：<a href="https://space.bilibili.com/525438321/channel/collectiondetail?sid=180037">https://space.bilibili.com/525438321/channel/collectiondetail?sid=180037</a></p></li></ul><p>本栏目的内容为博主二刷过程中对题目的思考、解题思路、总结的方法</p><p>包括如下内容：</p><ol><li>每天刷题的思考与问题（每道题都记录，但是不详细）</li><li>刷题时一时半会做不出来的题目 or  一道题目的多种解法</li><li>各种笔试题的题解</li></ol><p>联系博主：<a href="mailto:&#x79;&#x69;&#x6e;&#104;&#111;&#110;&#x67;&#x79;&#97;&#110;&#103;&#53;&#52;&#x36;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;">&#x79;&#x69;&#x6e;&#104;&#111;&#110;&#x67;&#x79;&#97;&#110;&#103;&#53;&#52;&#x36;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;</a></p>]]></content>
      
      
      <categories>
          
          <category> 刷题日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于博主</title>
      <link href="/2024/04/09/introduceMyself/"/>
      <url>/2024/04/09/introduceMyself/</url>
      
        <content type="html"><![CDATA[<p>昵称：4nge1<br>主要方向：Java后端（找工作ing）<br>邮箱：<a href="mailto:&#121;&#x69;&#110;&#x68;&#x6f;&#110;&#103;&#121;&#97;&#110;&#103;&#53;&#x34;&#54;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;">&#121;&#x69;&#110;&#x68;&#x6f;&#110;&#103;&#121;&#97;&#110;&#103;&#53;&#x34;&#54;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
